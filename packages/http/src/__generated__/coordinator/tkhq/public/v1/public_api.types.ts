/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/public/v1/query/get_activity": {
    /** Get details about an Activity */
    post: operations["PublicApiService_GetActivity"];
  };
  "/public/v1/query/get_organization": {
    /** Get details about an Organization */
    post: operations["PublicApiService_GetOrganization"];
  };
  "/public/v1/query/get_user": {
    /** Get details about a User */
    post: operations["PublicApiService_GetUser"];
  };
  "/public/v1/query/list_keys": {
    /** List all Private Keys within an Organization */
    post: operations["PublicApiService_GetKeys"];
  };
  "/public/v1/query/list_users": {
    /** List all Users within an Organization */
    post: operations["PublicApiService_GetUsers"];
  };
  "/public/v1/query/whoami": {
    /** Get basic information about your current API user and your organization */
    post: operations["PublicApiService_GetWhoami"];
  };
  "/public/v1/submit/create_api_keys": {
    /** Add api keys to an existing User */
    post: operations["PublicApiService_CreateApiKeys"];
  };
  "/public/v1/submit/create_invitations": {
    /** Create Invitations to join an existing Organization */
    post: operations["PublicApiService_CreateInvitations"];
  };
  "/public/v1/submit/create_keys": {
    /** Create new Private Keys */
    post: operations["PublicApiService_CreateKeys"];
  };
  "/public/v1/submit/create_policy": {
    /** Create a new Policy */
    post: operations["PublicApiService_CreatePolicy"];
  };
  "/public/v1/submit/create_users": {
    /** Create new API Users */
    post: operations["PublicApiService_CreateUsers"];
  };
  "/public/v1/submit/delete_api_keys": {
    /** Remove api keys from a User */
    post: operations["PublicApiService_DeleteApiKeys"];
  };
  "/public/v1/submit/delete_invitations": {
    /** Delete an existing Invitation */
    post: operations["PublicApiService_DeleteInvitation"];
  };
  "/public/v1/submit/delete_policy": {
    /** Delete an existing Policy */
    post: operations["PublicApiService_DeletePolicy"];
  };
  "/public/v1/submit/delete_users": {
    /** Deactivate an existing User */
    post: operations["PublicApiService_DeleteUsers"];
  };
  "/public/v1/submit/sign": {
    /** Sign a message with a Private Key */
    post: operations["PublicApiService_SignMessage"];
  };
  "/public/v1/submit/sign_transaction": {
    /** Sign a transaction with a Private Key */
    post: operations["PublicApiService_SignTransaction"];
  };
  "/tkhq/public/v1/query/get_key": {
    /** Get details about a Private Key */
    post: operations["PublicApiService_GetKey"];
  };
};

export type definitions = {
  activityActivity: {
    id: string;
    organizationId: string;
    status: definitions["activityActivityStatus"];
    type: definitions["activityActivityType"];
    intent: definitions["enforcementIntent"];
    result: definitions["enforcementResult"];
    votes: definitions["activityVote"][];
    fingerprint: string;
    canApprove: boolean;
    canReject: boolean;
  };
  /** @enum {string} */
  activityActivityStatus:
    | "ACTIVITY_STATUS_CREATED"
    | "ACTIVITY_STATUS_PENDING"
    | "ACTIVITY_STATUS_COMPLETED"
    | "ACTIVITY_STATUS_FAILED"
    | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    | "ACTIVITY_STATUS_REJECTED";
  /**
   * These are all of the types of user-facing activities on Turnkey
   * We use this to guide the polymorphic parsing of activity requests/approvals/rejections
   * One activity type maps to one internal Intent, but not all internal intents have a user-facing activity (e.g. Hearbeats)
   * @enum {string}
   */
  activityActivityType:
    | "ACTIVITY_TYPE_ADD_API_KEYS"
    | "ACTIVITY_TYPE_ADD_USERS"
    | "ACTIVITY_TYPE_ADD_KEYS"
    | "ACTIVITY_TYPE_SIGN_MESSAGE"
    | "ACTIVITY_TYPE_CREATE_INVITATIONS"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION"
    | "ACTIVITY_TYPE_ADD_POLICY"
    | "ACTIVITY_TYPE_REMOVE_KEY"
    | "ACTIVITY_TYPE_REMOVE_USERS"
    | "ACTIVITY_TYPE_REMOVE_API_KEYS"
    | "ACTIVITY_TYPE_REMOVE_INVITATION"
    | "ACTIVITY_TYPE_REMOVE_ORGANIZATION"
    | "ACTIVITY_TYPE_REMOVE_POLICY"
    | "ACTIVITY_TYPE_ADD_TAG"
    | "ACTIVITY_TYPE_REMOVE_TAGS"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION"
    | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    | "ACTIVITY_TYPE_REJECT_ACTIVITY"
    | "ACTIVITY_TYPE_REMOVE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_ADD_AUTHENTICATORS";
  activityCreateApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_ADD_API_KEYS";
    requestId?: string;
    organizationId: string;
    intent: definitions["enforcementAddApiKeysIntent"];
  };
  activityCreateInvitationsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_INVITATIONS";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementCreateInvitationsIntent"];
  };
  activityCreateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_ADD_KEYS";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementAddKeysIntent"];
  };
  /** TODO(tim) - add timestamp to all these requests to prevent replay attack in the event the DB has been tampered with */
  activityCreatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_ADD_POLICY";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementAddPolicyIntent"];
  };
  activityCreateUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_ADD_USERS";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementAddUsersIntent"];
  };
  activityDeleteApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_API_KEYS";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementRemoveApiKeysIntent"];
  };
  activityDeleteInvitationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_INVITATION";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementRemoveInvitationIntent"];
  };
  activityDeletePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_POLICY";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementRemovePolicyIntent"];
  };
  activityDeleteUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_USERS";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementRemoveUsersIntent"];
  };
  activitySignMessageRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_MESSAGE";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementSignMessageIntent"];
  };
  activitySignTransactionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_TRANSACTION";
    requestId: string;
    organizationId: string;
    intent: definitions["enforcementSignTransactionIntent"];
  };
  activityVote: {
    id: string;
    userId: string;
    user: definitions["resourcesUser"];
    activityId: string;
    /** @enum {string} */
    selection: "VOTE_SELECTION_APPROVED" | "VOTE_SELECTION_REJECTED";
    message: string;
    publicKey: string;
    signature: string;
    scheme: string;
    createdAt: definitions["resourcesTimestamp"];
  };
  /**
   * - CURVE_SECP256K1: The only curve we're planning to support short-term
   *  - CURVE_ED25519: Demonstrates an error case, we aren't going to support this curve at first
   * @enum {string}
   */
  curveCurve: "CURVE_SECP256K1" | "CURVE_ED25519";
  enforcementAcceptInvitationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    invitationId: string;
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    authenticator: definitions["enforcementAuthenticatorParams"];
  };
  enforcementAcceptInvitationResult: {
    invitationId: string;
    newUserId: string;
  };
  enforcementAddApiKeysIntent: {
    /** @inject_tag: validate:"dive,required" */
    apiKeys: definitions["enforcementApiKeyParams"][];
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
  };
  enforcementAddApiKeysResult: {
    apiKeyIds: string[];
  };
  enforcementAddAuthenticatorsIntent: {
    /** @inject_tag: validate:"dive,required" */
    authenticators: definitions["enforcementAuthenticatorParams"][];
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
  };
  enforcementAddAuthenticatorsResult: {
    authenticatorIds: string[];
  };
  enforcementAddKeysIntent: {
    /** @inject_tag: validate:"dive,required" */
    keys: definitions["enforcementKeyParams"][];
  };
  enforcementAddKeysResult: {
    keys: definitions["resourcesExternalKey"][];
  };
  enforcementAddPolicyIntent: {
    /** @inject_tag: validate:"required,max=40" */
    label: string;
    /** @inject_tag: validate:"required,dive,required" */
    selectors: definitions["resourcesSelector"][];
    effect: definitions["policyEffect"];
    /** @inject_tag: validate:"required,max=256" */
    notes: string;
  };
  enforcementAddPolicyResult: {
    newPolicyId: string;
  };
  enforcementAddTagIntent: {
    /** @inject_tag: validate:"required,max=20" */
    label: string;
    tagType: definitions["resourcesTagType"];
    /** @inject_tag: validate:"dive,uuid" */
    resourceIds: string[];
  };
  enforcementAddTagResult: {
    tagId: string;
    tagType: definitions["resourcesTagType"];
    resourceIds: string[];
  };
  enforcementAddUsersIntent: {
    /** @inject_tag: validate:"required,dive,required" */
    users: definitions["enforcementUserParams"][];
  };
  enforcementAddUsersResult: {
    userIds: string[];
  };
  enforcementApiKeyParams: {
    /** @inject_tag: validate:"required,max=40" */
    label: string;
    /** @inject_tag: validate:"hexadecimal,len=66" */
    publicKey: string;
    /** @inject_tag: "required,dive,uuid" */
    tags: string[];
  };
  enforcementApproveActivityIntent: {
    /** @inject_tag: validate:"required" */
    fingerprint: string;
  };
  enforcementAuthenticatorParams: {
    /** @inject_tag: validate:"required,max=40" */
    label: string;
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    attestation: definitions["webauthnPublicKeyCredentialWithAttestation"];
    /** @inject_tag: validate:"required,max=256" */
    challenge: string;
    /** @inject_tag: "required,dive,uuid" */
    tags: string[];
  };
  enforcementCreateInvitationsIntent: {
    /** @inject_tag: validate:"required,dive,required" */
    invitations: definitions["enforcementInvitationParams"][];
  };
  enforcementCreateInvitationsResult: {
    invitationIds: string[];
  };
  enforcementCreateOrganizationIntent: {
    /** @inject_tag: validate:"required,max=40" */
    name: string;
    /** @inject_tag: validate:"required,email" */
    rootEmail: string;
    rootAuthenticator: definitions["enforcementAuthenticatorParams"];
    /** @inject_tag: validate:"uuid" */
    rootUserUuid?: string;
  };
  enforcementCreateOrganizationResult: {
    newOrgId: string;
  };
  /** TODO(tim) - is this still needed? */
  enforcementHeartbeatIntent: { [key: string]: unknown };
  enforcementHeartbeatResult: { [key: string]: unknown };
  enforcementIntent: {
    createOrganizationIntent: definitions["enforcementCreateOrganizationIntent"];
    heartbeatIntent?: definitions["enforcementHeartbeatIntent"];
    addAuthenticatorsIntent?: definitions["enforcementAddAuthenticatorsIntent"];
    addUsersIntent?: definitions["enforcementAddUsersIntent"];
    addKeysIntent?: definitions["enforcementAddKeysIntent"];
    signMessageIntent?: definitions["enforcementSignMessageIntent"];
    createInvitationsIntent?: definitions["enforcementCreateInvitationsIntent"];
    acceptInvitationIntent?: definitions["enforcementAcceptInvitationIntent"];
    addPolicyIntent?: definitions["enforcementAddPolicyIntent"];
    removeKeyIntent?: definitions["enforcementRemoveKeyIntent"];
    removeUsersIntent?: definitions["enforcementRemoveUsersIntent"];
    removeAuthenticatorsIntent?: definitions["enforcementRemoveAuthenticatorsIntent"];
    removeInvitationIntent?: definitions["enforcementRemoveInvitationIntent"];
    removeOrganizationIntent?: definitions["enforcementRemoveOrganizationIntent"];
    removePolicyIntent?: definitions["enforcementRemovePolicyIntent"];
    addTagIntent?: definitions["enforcementAddTagIntent"];
    removeTagsIntent?: definitions["enforcementRemoveTagsIntent"];
    signTransactionIntent?: definitions["enforcementSignTransactionIntent"];
    addApiKeysIntent?: definitions["enforcementAddApiKeysIntent"];
    removeApiKeysIntent?: definitions["enforcementRemoveApiKeysIntent"];
    approveActivityIntent?: definitions["enforcementApproveActivityIntent"];
    rejectActivityIntent?: definitions["enforcementRejectActivityIntent"];
  };
  enforcementInvitationParams: {
    /** @inject_tag: validate:"required,max=40" */
    receiverAlias: string;
    /** @inject_tag: validate:"required,email" */
    receiverEmail: string;
    /** @inject_tag: validate:"dive,uuid" */
    receiverTags: string[];
    accessType: definitions["resourcesAccessType"];
    /** @inject_tag: validate:"required,uuid" */
    senderUserId: string;
  };
  enforcementKeyParams: {
    /** @inject_tag: validate:"required,max=40" */
    label: string;
    curve: definitions["curveCurve"];
    /** @inject_tag: validate:"dive,uuid" */
    tags: string[];
    /** @inject_tag: validate:"required" */
    addressFormats: definitions["resourcesAddressFormat"][];
  };
  enforcementRejectActivityIntent: {
    /** @inject_tag: validate:"required" */
    fingerprint: string;
  };
  enforcementRemoveApiKeysIntent: {
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    /** @inject_tag: validate:"required,dive,required,uuid" */
    apiKeyIds: string[];
  };
  enforcementRemoveApiKeysResult: {
    apiKeyIds: string[];
  };
  enforcementRemoveAuthenticatorsIntent: {
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    /** @inject_tag: validate:"required,div,required,uuid" */
    authenticatorIds: string[];
  };
  enforcementRemoveAuthenticatorsResult: {
    authenticatorIds: string[];
  };
  enforcementRemoveInvitationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    invitationId: string;
  };
  enforcementRemoveInvitationResult: {
    invitationId: string;
  };
  enforcementRemoveKeyIntent: {
    /** @inject_tag: validate:"required,uuid" */
    keyId: string;
  };
  enforcementRemoveKeyResult: {
    keyId: string;
  };
  enforcementRemoveOrganizationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    organizationId: string;
  };
  enforcementRemoveOrganizationResult: {
    organizationId: string;
  };
  enforcementRemovePolicyIntent: {
    /** @inject_tag: validate:"required,uuid" */
    policyId: string;
  };
  enforcementRemovePolicyResult: {
    policyId: string;
  };
  enforcementRemoveTagsIntent: {
    /** @inject_tag: validate:"required,dive,required,uuid" */
    tagIds: string[];
    tagType: definitions["resourcesTagType"];
  };
  enforcementRemoveTagsResult: {
    tagIds: string[];
    tagType: definitions["resourcesTagType"];
    resourceIds: string[];
  };
  enforcementRemoveUsersIntent: {
    /** @inject_tag: validate:"required,dive,required,uuid" */
    userIds: string[];
  };
  enforcementRemoveUsersResult: {
    userIds: string[];
  };
  enforcementResult: {
    createOrganizationResult?: definitions["enforcementCreateOrganizationResult"];
    heartbeatResult?: definitions["enforcementHeartbeatResult"];
    addAuthenticatorsResult?: definitions["enforcementAddAuthenticatorsResult"];
    addUsersResult?: definitions["enforcementAddUsersResult"];
    addKeysResult?: definitions["enforcementAddKeysResult"];
    createInvitationsResult?: definitions["enforcementCreateInvitationsResult"];
    acceptInvitationResult?: definitions["enforcementAcceptInvitationResult"];
    signMessageResult?: definitions["enforcementSignMessageResult"];
    addPolicyResult?: definitions["enforcementAddPolicyResult"];
    removeKeyResult?: definitions["enforcementRemoveKeyResult"];
    removeUsersResult?: definitions["enforcementRemoveUsersResult"];
    removeAuthenticatorsResult?: definitions["enforcementRemoveAuthenticatorsResult"];
    removeInvitationResult?: definitions["enforcementRemoveInvitationResult"];
    removeOrganizationResult?: definitions["enforcementRemoveOrganizationResult"];
    removePolicyResult?: definitions["enforcementRemovePolicyResult"];
    addTagResult?: definitions["enforcementAddTagResult"];
    removeTagsResult?: definitions["enforcementRemoveTagsResult"];
    signTransactionResult?: definitions["enforcementSignTransactionResult"];
    removeApiKeysResult?: definitions["enforcementRemoveApiKeysResult"];
    addApiKeysResult?: definitions["enforcementAddApiKeysResult"];
  };
  enforcementSignMessageIntent: {
    /** @inject_tag: validate:"required,uuid" */
    organizationId: string;
    /** @inject_tag: validate:"required,uuid" */
    keyId: string;
    /** @inject_tag: validate:"required" */
    payload: string;
    encoding: definitions["signaturePayloadEncoding"];
    hashFunction: definitions["signatureHashFunction"];
  };
  enforcementSignMessageResult: {
    r: string;
    s: string;
    v: string;
  };
  enforcementSignTransactionIntent: {
    /** @inject_tag: validate:"required,uuid" */
    organizationId: string;
    /** @inject_tag: validate:"required,uuid" */
    keyId: string;
    /** @inject_tag: validate:"required" */
    unsignedTransaction: string;
    type: definitions["resourcesTransactionType"];
  };
  enforcementSignTransactionResult: {
    signedTransaction: string;
  };
  enforcementUserParams: {
    /** @inject_tag: validate:"required,max=40" */
    alias: string;
    /** @inject_tag: validate:"email" */
    email?: string;
    accessType: definitions["resourcesAccessType"];
    /** @inject_tag: validate:"dive,uuid" */
    apiKeys: definitions["enforcementApiKeyParams"][];
    /** @inject_tag: validate:"dive" */
    authenticators: definitions["enforcementAuthenticatorParams"][];
    /** @inject_tag: validate:"dive,uuid" */
    tags: string[];
  };
  /**
   * @description This proto definition dictates the encoding of organization data blobs in our database
   * It does so indirectly: we use this message to derive Rust types. These Rust types are
   * then used to serialize to, and deserialize from, JSON.
   */
  organization_dataOrganizationData: {
    version?: string;
    uuid?: string;
    name?: string;
    users?: definitions["resourcesUser"][];
    policies?: definitions["resourcesPolicy"][];
    keys?: definitions["resourcesKey"][];
    invitations?: definitions["resourcesInvitation"][];
    tags?: definitions["resourcesTag"][];
    deletedUsers?: definitions["resourcesUser"][];
    deletedPolicies?: definitions["resourcesPolicy"][];
    deletedKeys?: definitions["resourcesKey"][];
    deletedInvitations?: definitions["resourcesInvitation"][];
    deletedApiKeys?: definitions["resourcesApiKey"][];
    deletedAuthenticators?: definitions["resourcesAuthenticator"][];
    deletedTags?: definitions["resourcesTag"][];
  };
  /** @enum {string} */
  policyEffect: "EFFECT_ALLOW" | "EFFECT_DENY";
  protobufAny: {
    "@type"?: string;
  } & { [key: string]: unknown };
  publicv1CreateApiKeysRequest: {
    request: definitions["activityCreateApiKeysRequest"];
  };
  publicv1CreateInvitationsRequest: {
    request: definitions["activityCreateInvitationsRequest"];
  };
  publicv1CreateKeysRequest: {
    request: definitions["activityCreateKeysRequest"];
  };
  publicv1CreatePolicyRequest: {
    request: definitions["activityCreatePolicyRequest"];
  };
  publicv1CreateUsersRequest: {
    request: definitions["activityCreateUsersRequest"];
  };
  publicv1DeleteApiKeysRequest: {
    request: definitions["activityDeleteApiKeysRequest"];
  };
  publicv1DeleteInvitationRequest: {
    request: definitions["activityDeleteInvitationRequest"];
  };
  publicv1DeletePolicyRequest: {
    request: definitions["activityDeletePolicyRequest"];
  };
  publicv1DeleteUsersRequest: {
    request: definitions["activityDeleteUsersRequest"];
  };
  publicv1SignMessageRequest: {
    request: definitions["activitySignMessageRequest"];
  };
  publicv1SignTransactionRequest: {
    request: definitions["activitySignTransactionRequest"];
  };
  /** @enum {string} */
  resourcesAccessType:
    | "ACCESS_TYPE_WEB"
    | "ACCESS_TYPE_API"
    | "ACCESS_TYPE_ALL";
  resourcesAddress: {
    format?: definitions["resourcesAddressFormat"];
    address?: string;
  };
  /**
   * - ADDRESS_FORMAT_UNCOMPRESSED: 04<X_COORDINATE><Y_COORDINATE>
   *  - ADDRESS_FORMAT_COMPRESSED: 02 or 03, followed by the X coordinate
   *  - ADDRESS_FORMAT_ETHEREUM: Your standard Ethereum address (0x...). We apply EIP55 casing.
   *  - ADDRESS_FORMAT_BITCOIN_P2PKH: Bitoin formats. See https://en.bitcoin.it/wiki/List_of_address_prefixes
   * @enum {string}
   */
  resourcesAddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH_TESTNET";
  resourcesApiKey: {
    credential: definitions["resourcesCredential"];
    tags: string[];
    uuid: string;
    label: string;
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
  };
  resourcesAuthenticator: {
    transports: definitions["webauthnAuthenticatorTransport"][];
    attestationType: string;
    aaguid: string;
    userId: string;
    credentialId: string;
    model: string;
    credential: definitions["resourcesCredential"];
    uuid: string;
    label: string;
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
    tags: string[];
  };
  resourcesCredential: {
    publicKey: string;
    scheme: definitions["signatureSignatureScheme"];
  };
  /** Key with data that is safe to share publicly */
  resourcesExternalKey: {
    uuid: string;
    publicKey: string;
    label: string;
    curve: definitions["curveCurve"];
    addresses: definitions["resourcesAddress"][];
    tags: string[];
  };
  resourcesInvitation: {
    uuid: string;
    receiverAlias: string;
    receiverEmail: string;
    receiverTags: string[];
    accessType: definitions["resourcesAccessType"];
    status: definitions["resourcesInvitationStatus"];
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
    senderUserId: string;
  };
  /** @enum {string} */
  resourcesInvitationStatus:
    | "INVITATION_STATUS_CREATED"
    | "INVITATION_STATUS_ACCEPTED"
    | "INVITATION_STATUS_REVOKED";
  resourcesKey: {
    uuid: string;
    /** public key (!= address) */
    publicKey: string;
    /** encrypted private key */
    encryptedPrivateKey: string;
    label: string;
    curve: definitions["curveCurve"];
    addresses: definitions["resourcesAddress"][];
    tags: string[];
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
  };
  /** @enum {string} */
  resourcesOperator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL";
  resourcesPolicy: {
    uuid: string;
    label: string;
    effect: definitions["policyEffect"];
    selectors: definitions["resourcesSelector"][];
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
    notes: string;
  };
  resourcesSelector: {
    subject: string;
    operator: definitions["resourcesOperator"];
    target: string;
  };
  resourcesTag: {
    uuid: string;
    label: string;
    tagType: definitions["resourcesTagType"];
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
  };
  /** @enum {string} */
  resourcesTagType:
    | "TAG_TYPE_USER"
    | "TAG_TYPE_API_KEY"
    | "TAG_TYPE_KEY"
    | "TAG_TYPE_AUTHENTICATOR";
  /** Need borsch serialization, so can't use the internal timestamp */
  resourcesTimestamp: {
    seconds: string;
    nanos: string;
  };
  /**
   * - TRANSACTION_TYPE_ETHEREUM: Unsigned Ethereum transaction, RLP-encoded and hex-encoded
   * @enum {string}
   */
  resourcesTransactionType: "TRANSACTION_TYPE_ETHEREUM";
  resourcesUser: {
    uuid: string;
    alias: string;
    /** some users do not have emails (programmatic users) */
    email?: string;
    accessType: definitions["resourcesAccessType"];
    authenticators: definitions["resourcesAuthenticator"][];
    apiKeys: definitions["resourcesApiKey"][];
    tags: string[];
    createdAt: definitions["resourcesTimestamp"];
    updatedAt: definitions["resourcesTimestamp"];
  };
  rpcStatus: {
    /** Format: int32 */
    code?: number;
    message?: string;
    details?: definitions["protobufAny"][];
  };
  /**
   * @description  - HASH_FUNCTION_UNSPECIFIED: Default value if hash function is not set explicitly
   *  - HASH_FUNCTION_NO_OP: No-op function. Useful if you want to pass raw bytes to sign
   *  - HASH_FUNCTION_SHA256: Standard SHA-256
   *  - HASH_FUNCTION_KECCAK256: Keccak-256 (not the same as NIST SHA-3!).
   * This is the hash function used in the Ethereum ecosystem.
   * @enum {string}
   */
  signatureHashFunction:
    | "HASH_FUNCTION_NO_OP"
    | "HASH_FUNCTION_SHA256"
    | "HASH_FUNCTION_KECCAK256";
  /**
   * - PAYLOAD_ENCODING_UNSPECIFIED: Default value if payload encoding is not set explicitly
   *  - PAYLOAD_ENCODING_HEXADECIMAL: Payload is encoded in hexadecimal
   * We accept 0x-prefixed or non-0x prefixed payloads.
   * We accept any casing (uppercase, lowercase, or mixed)
   *  - PAYLOAD_ENCODING_TEXT_UTF8: Payload is encoded as utf-8 text
   * Will be converted to bytes for signature with Rust's standard String.as_bytes()
   * @enum {string}
   */
  signaturePayloadEncoding:
    | "PAYLOAD_ENCODING_HEXADECIMAL"
    | "PAYLOAD_ENCODING_TEXT_UTF8";
  /**
   * - SIGNATURE_SCHEME_TK_API_P256: Scheme used for Turnkey's public API
   *  - SIGNATURE_SCHEME_TK_WEBAUTHN: Scheme used on our UI when users sign with Webauthn
   * Public keys are encoded using COSE (https://www.w3.org/TR/webauthn-2/#sctn-encoded-credPubKey-examples)
   *  - SIGNATURE_SCHEME_TK_QUORUM_P256: Scheme used by our enclave applications
   * @enum {string}
   */
  signatureSignatureScheme:
    | "SIGNATURE_SCHEME_TK_API_P256"
    | "SIGNATURE_SCHEME_TK_WEBAUTHN"
    | "SIGNATURE_SCHEME_TK_QUORUM_P256";
  v1ActivityResponse: {
    activity: definitions["activityActivity"];
  };
  v1GetActivityRequest: {
    organizationId: string;
    activityId: string;
  };
  v1GetKeyRequest: {
    organizationId: string;
    keyId: string;
  };
  v1GetKeyResponse: {
    key: definitions["resourcesExternalKey"];
  };
  v1GetKeysRequest: {
    organizationId: string;
  };
  v1GetKeysResponse: {
    keys: definitions["resourcesExternalKey"][];
  };
  v1GetOrganizationRequest: {
    organizationId: string;
  };
  v1GetOrganizationResponse: {
    organizationData: definitions["organization_dataOrganizationData"];
  };
  v1GetUserRequest: {
    organizationId: string;
    userId: string;
  };
  v1GetUserResponse: {
    user: definitions["resourcesUser"];
  };
  v1GetUsersRequest: {
    organizationId: string;
  };
  v1GetUsersResponse: {
    users: definitions["resourcesUser"][];
  };
  v1GetWhoamiRequest: {
    organizationId: string;
  };
  v1GetWhoamiResponse: {
    organizationId: string;
    organizationName: string;
    userId: string;
    username: string;
  };
  webauthnAuthenticatorAttestationResponse: {
    /** ENCODING: base64url */
    clientDataJson: string;
    /** ENCODING: base64url */
    attestationObject: string;
    transports?: definitions["webauthnAuthenticatorTransport"][];
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
  };
  /** @enum {string} */
  webauthnAuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  webauthnCredPropsAuthenticationExtensionsClientOutputs: {
    rk: boolean;
  };
  webauthnPublicKeyCredentialWithAttestation: {
    id: string;
    /**
     * Must be literal string "public-key"
     * @enum {string}
     */
    type: "public-key";
    /** ENCODING: base64url */
    rawId: string;
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
    response: definitions["webauthnAuthenticatorAttestationResponse"];
    clientExtensionResults: definitions["webauthnSimpleClientExtensionResults"];
  };
  webauthnSimpleClientExtensionResults: {
    appid?: boolean;
    appidExclude?: boolean;
    credProps?: definitions["webauthnCredPropsAuthenticationExtensionsClientOutputs"];
  };
};

export type operations = {
  /** Get details about an Activity */
  PublicApiService_GetActivity: {
    parameters: {
      body: {
        body: definitions["v1GetActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an Organization */
  PublicApiService_GetOrganization: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a User */
  PublicApiService_GetUser: {
    parameters: {
      body: {
        body: definitions["v1GetUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUserResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Private Keys within an Organization */
  PublicApiService_GetKeys: {
    parameters: {
      body: {
        body: definitions["v1GetKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetKeysResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Users within an Organization */
  PublicApiService_GetUsers: {
    parameters: {
      body: {
        body: definitions["v1GetUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUsersResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get basic information about your current API user and your organization */
  PublicApiService_GetWhoami: {
    parameters: {
      body: {
        body: definitions["v1GetWhoamiRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWhoamiResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Add api keys to an existing User */
  PublicApiService_CreateApiKeys: {
    parameters: {
      body: {
        body: definitions["publicv1CreateApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Invitations to join an existing Organization */
  PublicApiService_CreateInvitations: {
    parameters: {
      body: {
        body: definitions["publicv1CreateInvitationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new Private Keys */
  PublicApiService_CreateKeys: {
    parameters: {
      body: {
        body: definitions["publicv1CreateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new Policy */
  PublicApiService_CreatePolicy: {
    parameters: {
      body: {
        body: definitions["publicv1CreatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new API Users */
  PublicApiService_CreateUsers: {
    parameters: {
      body: {
        body: definitions["publicv1CreateUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove api keys from a User */
  PublicApiService_DeleteApiKeys: {
    parameters: {
      body: {
        body: definitions["publicv1DeleteApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Invitation */
  PublicApiService_DeleteInvitation: {
    parameters: {
      body: {
        body: definitions["publicv1DeleteInvitationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Policy */
  PublicApiService_DeletePolicy: {
    parameters: {
      body: {
        body: definitions["publicv1DeletePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Deactivate an existing User */
  PublicApiService_DeleteUsers: {
    parameters: {
      body: {
        body: definitions["publicv1DeleteUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a message with a Private Key */
  PublicApiService_SignMessage: {
    parameters: {
      body: {
        body: definitions["publicv1SignMessageRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a transaction with a Private Key */
  PublicApiService_SignTransaction: {
    parameters: {
      body: {
        body: definitions["publicv1SignTransactionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Private Key */
  PublicApiService_GetKey: {
    parameters: {
      body: {
        body: definitions["v1GetKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetKeyResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
};

export type external = {};
