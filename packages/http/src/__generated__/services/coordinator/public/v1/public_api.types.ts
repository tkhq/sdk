/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/public/v1/query/get_activity": {
    /** Get details about an Activity */
    post: operations["PublicApiService_GetActivity"];
  };
  "/public/v1/query/get_organization": {
    /** Get details about an Organization */
    post: operations["PublicApiService_GetOrganization"];
  };
  "/public/v1/query/get_policy": {
    /** Get details about a Policy */
    post: operations["PublicApiService_GetPolicy"];
  };
  "/public/v1/query/get_user": {
    /** Get details about a User */
    post: operations["PublicApiService_GetUser"];
  };
  "/public/v1/query/list_activities": {
    /** List all Activities within an Organization */
    post: operations["PublicApiService_GetActivities"];
  };
  "/public/v1/query/list_policies": {
    /** List all Policies within an Organization */
    post: operations["PublicApiService_GetPolicies"];
  };
  "/public/v1/query/list_private_keys": {
    /** List all Private Keys within an Organization */
    post: operations["PublicApiService_GetPrivateKeys"];
  };
  "/public/v1/query/list_users": {
    /** List all Users within an Organization */
    post: operations["PublicApiService_GetUsers"];
  };
  "/public/v1/query/whoami": {
    /** Get basic information about your current API user and your organization */
    post: operations["PublicApiService_GetWhoami"];
  };
  "/public/v1/submit/create_api_keys": {
    /** Add api keys to an existing User */
    post: operations["PublicApiService_CreateApiKeys"];
  };
  "/public/v1/submit/create_invitations": {
    /** Create Invitations to join an existing Organization */
    post: operations["PublicApiService_CreateInvitations"];
  };
  "/public/v1/submit/create_policy": {
    /** Create a new Policy */
    post: operations["PublicApiService_CreatePolicy"];
  };
  "/public/v1/submit/create_private_keys": {
    /** Create new Private Keys */
    post: operations["PublicApiService_CreatePrivateKeys"];
  };
  "/public/v1/submit/delete_api_keys": {
    /** Remove api keys from a User */
    post: operations["PublicApiService_DeleteApiKeys"];
  };
  "/public/v1/submit/delete_invitations": {
    /** Delete an existing Invitation */
    post: operations["PublicApiService_DeleteInvitation"];
  };
  "/public/v1/submit/delete_policy": {
    /** Delete an existing Policy */
    post: operations["PublicApiService_DeletePolicy"];
  };
  "/public/v1/submit/sign_raw_payload": {
    /** Sign a raw payload with a Private Key */
    post: operations["PublicApiService_SignRawPayload"];
  };
  "/public/v1/submit/sign_transaction": {
    /** Sign a transaction with a Private Key */
    post: operations["PublicApiService_SignTransaction"];
  };
  "/tkhq/public/v1/query/get_private_key": {
    /** Get details about a Private Key */
    post: operations["PublicApiService_GetPrivateKey"];
  };
};

export type definitions = {
  datav1Tag: {
    tagId: string;
    label: string;
    tagType: definitions["v1TagType"];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  /** @enum {string} */
  externaldatav1AccessType:
    | "ACCESS_TYPE_WEB"
    | "ACCESS_TYPE_API"
    | "ACCESS_TYPE_ALL";
  externaldatav1Address: {
    format?: definitions["externaldatav1AddressFormat"];
    address?: string;
  };
  /**
   * - ADDRESS_FORMAT_UNCOMPRESSED: 04<X_COORDINATE><Y_COORDINATE>
   *  - ADDRESS_FORMAT_COMPRESSED: 02 or 03, followed by the X coordinate
   *  - ADDRESS_FORMAT_ETHEREUM: Your standard Ethereum address (0x...). We apply EIP55 casing.
   *  - ADDRESS_FORMAT_BITCOIN_P2PKH: Bitoin formats. See https://en.bitcoin.it/wiki/List_of_address_prefixes
   * @enum {string}
   */
  externaldatav1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH_TESTNET";
  /** @enum {string} */
  externaldatav1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  /**
   * - CURVE_SECP256K1: The only curve we're planning to support short-term
   * @enum {string}
   */
  externaldatav1Curve: "CURVE_SECP256K1";
  /** @enum {string} */
  externaldatav1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  /** @enum {string} */
  externaldatav1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL";
  externaldatav1Selector: {
    subject: string;
    operator: definitions["externaldatav1Operator"];
    target: string;
  };
  /** @enum {string} */
  immutableactivityv1AccessType:
    | "ACCESS_TYPE_WEB"
    | "ACCESS_TYPE_API"
    | "ACCESS_TYPE_ALL";
  /**
   * - ADDRESS_FORMAT_UNCOMPRESSED: 04<X_COORDINATE><Y_COORDINATE>
   *  - ADDRESS_FORMAT_COMPRESSED: 02 or 03, followed by the X coordinate
   *  - ADDRESS_FORMAT_ETHEREUM: Your standard Ethereum address (0x...). We apply EIP55 casing.
   *  - ADDRESS_FORMAT_BITCOIN_P2PKH: Bitoin formats. See https://en.bitcoin.it/wiki/List_of_address_prefixes
   * @enum {string}
   */
  immutableactivityv1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH_TESTNET";
  /**
   * - CURVE_SECP256K1: The only curve we're planning to support short-term
   * @enum {string}
   */
  immutableactivityv1Curve: "CURVE_SECP256K1";
  /** @enum {string} */
  immutableactivityv1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  /** @enum {string} */
  immutableactivityv1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL";
  immutableactivityv1Selector: {
    subject?: string;
    operator?: definitions["immutableactivityv1Operator"];
    target?: string;
  };
  /**
   * - TRANSACTION_TYPE_ETHEREUM: Unsigned Ethereum transaction, RLP-encoded and hex-encoded
   * @enum {string}
   */
  immutableactivityv1TransactionType: "TRANSACTION_TYPE_ETHEREUM";
  /** @enum {string} */
  immutablewebauthnv1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  protobufAny: {
    "@type"?: string;
  } & { [key: string]: unknown };
  rpcStatus: {
    /** Format: int32 */
    code?: number;
    message?: string;
    details?: definitions["protobufAny"][];
  };
  v1AcceptInvitationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    invitationId: string;
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    authenticator: definitions["v1AuthenticatorParams"];
  };
  v1AcceptInvitationResult: {
    invitationId: string;
    userId: string;
  };
  v1Activity: {
    id: string;
    organizationId: string;
    status: definitions["v1ActivityStatus"];
    type: definitions["v1ActivityType"];
    intent: definitions["v1Intent"];
    result: definitions["v1Result"];
    votes: definitions["v1Vote"][];
    fingerprint: string;
    canApprove: boolean;
    canReject: boolean;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1ActivityResponse: {
    activity: definitions["v1Activity"];
  };
  /** @enum {string} */
  v1ActivityStatus:
    | "ACTIVITY_STATUS_CREATED"
    | "ACTIVITY_STATUS_PENDING"
    | "ACTIVITY_STATUS_COMPLETED"
    | "ACTIVITY_STATUS_FAILED"
    | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    | "ACTIVITY_STATUS_REJECTED";
  /**
   * These are all of the types of user-facing activities on Turnkey
   * We use this to guide the polymorphic parsing of activity requests/approvals/rejections
   * One activity type maps to one internal Intent, but not all internal intents have a user-facing activity (e.g. Hearbeats)
   * @enum {string}
   */
  v1ActivityType:
    | "ACTIVITY_TYPE_CREATE_API_KEYS"
    | "ACTIVITY_TYPE_CREATE_USERS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
    | "ACTIVITY_TYPE_CREATE_INVITATIONS"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION"
    | "ACTIVITY_TYPE_CREATE_POLICY"
    | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
    | "ACTIVITY_TYPE_DELETE_USERS"
    | "ACTIVITY_TYPE_DELETE_API_KEYS"
    | "ACTIVITY_TYPE_DELETE_INVITATION"
    | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
    | "ACTIVITY_TYPE_DELETE_POLICY"
    | "ACTIVITY_TYPE_CREATE_USER_TAG"
    | "ACTIVITY_TYPE_DELETE_USER_TAGS"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION"
    | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    | "ACTIVITY_TYPE_REJECT_ACTIVITY"
    | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS";
  v1ApiKey: {
    credential: definitions["v1Credential"];
    apiKeyId: string;
    apiKeyName: string;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1ApiKeyParams: {
    /** @inject_tag: validate:"required,max=40" */
    apiKeyName: string;
    /** @inject_tag: validate:"hexadecimal,len=66" */
    publicKey: string;
  };
  v1ApproveActivityIntent: {
    /** @inject_tag: validate:"required" */
    fingerprint: string;
  };
  v1Authenticator: {
    transports: definitions["externaldatav1AuthenticatorTransport"][];
    attestationType: string;
    aaguid: string;
    userId: string;
    credentialId: string;
    model: string;
    credential: definitions["v1Credential"];
    authenticatorId: string;
    label: string;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1AuthenticatorAttestationResponse: {
    /** ENCODING: base64url */
    clientDataJson: string;
    /** ENCODING: base64url */
    attestationObject: string;
    transports?: definitions["immutablewebauthnv1AuthenticatorTransport"][];
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
  };
  v1AuthenticatorParams: {
    /** @inject_tag: validate:"required,max=40" */
    authenticatorName: string;
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    attestation: definitions["v1PublicKeyCredentialWithAttestation"];
    /** @inject_tag: validate:"required,max=256" */
    challenge: string;
  };
  v1CreateApiKeysIntent: {
    /** @inject_tag: validate:"dive,required" */
    apiKeys: definitions["v1ApiKeyParams"][];
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
  };
  v1CreateApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_KEYS";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1CreateApiKeysIntent"];
  };
  v1CreateApiKeysResult: {
    apiKeyIds: string[];
  };
  v1CreateAuthenticatorsIntent: {
    /** @inject_tag: validate:"dive,required" */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
  };
  v1CreateAuthenticatorsResult: {
    authenticatorIds: string[];
  };
  v1CreateInvitationsIntent: {
    /** @inject_tag: validate:"required,dive,required" */
    invitations: definitions["v1InvitationParams"][];
  };
  v1CreateInvitationsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_INVITATIONS";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1CreateInvitationsIntent"];
  };
  v1CreateInvitationsResult: {
    invitationIds: string[];
  };
  v1CreateOrganizationIntent: {
    /** @inject_tag: validate:"required,max=40" */
    organizationName: string;
    /** @inject_tag: validate:"required,email" */
    rootEmail: string;
    rootAuthenticator: definitions["v1AuthenticatorParams"];
    /** @inject_tag: validate:"uuid" */
    rootUserId?: string;
  };
  v1CreateOrganizationResult: {
    organizationId: string;
  };
  v1CreatePolicyIntent: {
    /** @inject_tag: validate:"required,max=40" */
    policyName: string;
    /** @inject_tag: validate:"required,dive,required" */
    selectors: definitions["immutableactivityv1Selector"][];
    effect: definitions["immutableactivityv1Effect"];
    notes?: string;
  };
  v1CreatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICY";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1CreatePolicyIntent"];
  };
  v1CreatePolicyResult: {
    policyId: string;
  };
  v1CreatePrivateKeyTagIntent: {
    /** @inject_tag: validate:"required,max=20" */
    privateKeyTagName: string;
    /** @inject_tag: validate:"dive,uuid" */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeyTagResult: {
    privateKeyTagId: string;
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysIntent: {
    /** @inject_tag: validate:"dive,required" */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeysIntent"];
  };
  v1CreatePrivateKeysResult: {
    privateKeyIds: string[];
  };
  v1CreateUserTagIntent: {
    /** @inject_tag: validate:"required,max=20" */
    userTagName: string;
    /** @inject_tag: validate:"dive,uuid" */
    userIds: string[];
  };
  v1CreateUserTagResult: {
    userTagId: string;
    userIds: string[];
  };
  v1CreateUsersIntent: {
    /** @inject_tag: validate:"required,dive,required" */
    users: definitions["v1UserParams"][];
  };
  v1CreateUsersResult: {
    userIds: string[];
  };
  v1CredPropsAuthenticationExtensionsClientOutputs: {
    rk: boolean;
  };
  v1Credential: {
    publicKey: string;
    type: definitions["v1CredentialType"];
  };
  /** @enum {string} */
  v1CredentialType:
    | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
    | "CREDENTIAL_TYPE_API_KEY_P256";
  v1DeleteApiKeysIntent: {
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    /** @inject_tag: validate:"required,dive,required,uuid" */
    apiKeyIds: string[];
  };
  v1DeleteApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_API_KEYS";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1DeleteApiKeysIntent"];
  };
  v1DeleteApiKeysResult: {
    apiKeyIds: string[];
  };
  v1DeleteAuthenticatorsIntent: {
    /** @inject_tag: validate:"required,uuid" */
    userId: string;
    /** @inject_tag: validate:"required,div,required,uuid" */
    authenticatorIds: string[];
  };
  v1DeleteAuthenticatorsResult: {
    authenticatorIds: string[];
  };
  v1DeleteInvitationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    invitationId: string;
  };
  v1DeleteInvitationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_INVITATION";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1DeleteInvitationIntent"];
  };
  v1DeleteInvitationResult: {
    invitationId: string;
  };
  v1DeleteOrganizationIntent: {
    /** @inject_tag: validate:"required,uuid" */
    organizationId: string;
  };
  v1DeleteOrganizationResult: {
    organizationId: string;
  };
  v1DeletePolicyIntent: {
    /** @inject_tag: validate:"required,uuid" */
    policyId: string;
  };
  v1DeletePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_POLICY";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1DeletePolicyIntent"];
  };
  v1DeletePolicyResult: {
    policyId: string;
  };
  v1DeletePrivateKeyTagsIntent: {
    /** @inject_tag: validate:"required,dive,required,uuid" */
    privateKeyTagIds: string[];
  };
  v1DeletePrivateKeyTagsResult: {
    privateKeyTagIds: string[];
    privateKeyIds: string[];
  };
  v1DeleteUserTagsIntent: {
    /** @inject_tag: validate:"required,dive,required,uuid" */
    userTagIds: string[];
  };
  v1DeleteUserTagsResult: {
    userTagIds: string[];
    userIds: string[];
  };
  v1DeleteUsersIntent: {
    /** @inject_tag: validate:"required,dive,required,uuid" */
    userIds: string[];
  };
  v1DeleteUsersResult: {
    userIds: string[];
  };
  v1DisablePrivateKeyIntent: {
    /** @inject_tag: validate:"required,uuid" */
    privateKeyId: string;
  };
  v1DisablePrivateKeyResult: {
    privateKeyId: string;
  };
  v1GetActivitiesRequest: {
    organizationId: string;
    filterByStatus?: definitions["v1ActivityStatus"][];
  };
  v1GetActivitiesResponse: {
    activities: definitions["v1Activity"][];
  };
  v1GetActivityRequest: {
    organizationId: string;
    activityId: string;
  };
  v1GetOrganizationRequest: {
    organizationId: string;
  };
  v1GetOrganizationResponse: {
    organizationData: definitions["v1OrganizationData"];
  };
  v1GetPoliciesRequest: {
    organizationId: string;
  };
  v1GetPoliciesResponse: {
    policies: definitions["v1Policy"][];
  };
  v1GetPolicyRequest: {
    organizationId: string;
    policyId: string;
  };
  v1GetPolicyResponse: {
    policy: definitions["v1Policy"];
  };
  v1GetPrivateKeyRequest: {
    organizationId: string;
    privateKeyId: string;
  };
  v1GetPrivateKeyResponse: {
    privateKey: definitions["v1PrivateKey"];
  };
  v1GetPrivateKeysRequest: {
    organizationId: string;
  };
  v1GetPrivateKeysResponse: {
    privateKeys: definitions["v1PrivateKey"][];
  };
  v1GetUserRequest: {
    organizationId: string;
    userId: string;
  };
  v1GetUserResponse: {
    user: definitions["v1User"];
  };
  v1GetUsersRequest: {
    organizationId: string;
  };
  v1GetUsersResponse: {
    users: definitions["v1User"][];
  };
  v1GetWhoamiRequest: {
    organizationId: string;
  };
  v1GetWhoamiResponse: {
    organizationId: string;
    organizationName: string;
    userId: string;
    username: string;
  };
  /**
   * @description  - HASH_FUNCTION_UNSPECIFIED: Default value if hash function is not set explicitly
   *  - HASH_FUNCTION_NO_OP: No-op function. Useful if you want to pass raw bytes to sign
   *  - HASH_FUNCTION_SHA256: Standard SHA-256
   *  - HASH_FUNCTION_KECCAK256: Keccak-256 (not the same as NIST SHA-3!).
   * This is the hash function used in the Ethereum ecosystem.
   * @enum {string}
   */
  v1HashFunction:
    | "HASH_FUNCTION_NO_OP"
    | "HASH_FUNCTION_SHA256"
    | "HASH_FUNCTION_KECCAK256";
  v1Intent: {
    createOrganizationIntent: definitions["v1CreateOrganizationIntent"];
    createAuthenticatorsIntent?: definitions["v1CreateAuthenticatorsIntent"];
    createUsersIntent?: definitions["v1CreateUsersIntent"];
    createPrivateKeysIntent?: definitions["v1CreatePrivateKeysIntent"];
    signRawPayloadIntent?: definitions["v1SignRawPayloadIntent"];
    createInvitationsIntent?: definitions["v1CreateInvitationsIntent"];
    acceptInvitationIntent?: definitions["v1AcceptInvitationIntent"];
    createPolicyIntent?: definitions["v1CreatePolicyIntent"];
    disablePrivateKeyIntent?: definitions["v1DisablePrivateKeyIntent"];
    deleteUsersIntent?: definitions["v1DeleteUsersIntent"];
    deleteAuthenticatorsIntent?: definitions["v1DeleteAuthenticatorsIntent"];
    deleteInvitationIntent?: definitions["v1DeleteInvitationIntent"];
    deleteOrganizationIntent?: definitions["v1DeleteOrganizationIntent"];
    deletePolicyIntent?: definitions["v1DeletePolicyIntent"];
    createUserTagIntent?: definitions["v1CreateUserTagIntent"];
    deleteUserTagsIntent?: definitions["v1DeleteUserTagsIntent"];
    signTransactionIntent?: definitions["v1SignTransactionIntent"];
    createApiKeysIntent?: definitions["v1CreateApiKeysIntent"];
    deleteApiKeysIntent?: definitions["v1DeleteApiKeysIntent"];
    approveActivityIntent?: definitions["v1ApproveActivityIntent"];
    rejectActivityIntent?: definitions["v1RejectActivityIntent"];
    createPrivateKeyTagIntent?: definitions["v1CreatePrivateKeyTagIntent"];
    deletePrivateKeyTagsIntent?: definitions["v1DeletePrivateKeyTagsIntent"];
  };
  v1Invitation: {
    invitationId: string;
    receiverAlias: string;
    receiverEmail: string;
    receiverTags: string[];
    accessType: definitions["externaldatav1AccessType"];
    status: definitions["v1InvitationStatus"];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
    senderUserId: string;
  };
  v1InvitationParams: {
    /** @inject_tag: validate:"required,max=40" */
    receiverUserName: string;
    /** @inject_tag: validate:"required,email" */
    receiverUserEmail: string;
    /** @inject_tag: validate:"dive,uuid" */
    receiverUserTags: string[];
    accessType: definitions["immutableactivityv1AccessType"];
    /** @inject_tag: validate:"required,uuid" */
    senderUserId: string;
  };
  /** @enum {string} */
  v1InvitationStatus:
    | "INVITATION_STATUS_CREATED"
    | "INVITATION_STATUS_ACCEPTED"
    | "INVITATION_STATUS_REVOKED";
  /**
   * @description This proto definition is used in our external-facing APIs.
   * It's important to leverage annotations because they're used in our external interfaces.
   */
  v1OrganizationData: {
    organizationId?: string;
    name?: string;
    users?: definitions["v1User"][];
    policies?: definitions["v1Policy"][];
    privateKeys?: definitions["v1PrivateKey"][];
    invitations?: definitions["v1Invitation"][];
    tags?: definitions["datav1Tag"][];
    deletedUsers?: definitions["v1User"][];
    deletedPolicies?: definitions["v1Policy"][];
    disabledPrivateKeys?: definitions["v1PrivateKey"][];
    deletedInvitations?: definitions["v1Invitation"][];
    deletedApiKeys?: definitions["v1ApiKey"][];
    deletedAuthenticators?: definitions["v1Authenticator"][];
    deletedTags?: definitions["datav1Tag"][];
  };
  /**
   * - PAYLOAD_ENCODING_UNSPECIFIED: Default value if payload encoding is not set explicitly
   *  - PAYLOAD_ENCODING_HEXADECIMAL: Payload is encoded in hexadecimal
   * We accept 0x-prefixed or non-0x prefixed payloads.
   * We accept any casing (uppercase, lowercase, or mixed)
   *  - PAYLOAD_ENCODING_TEXT_UTF8: Payload is encoded as utf-8 text
   * Will be converted to bytes for signature with Rust's standard String.as_bytes()
   * @enum {string}
   */
  v1PayloadEncoding:
    | "PAYLOAD_ENCODING_HEXADECIMAL"
    | "PAYLOAD_ENCODING_TEXT_UTF8";
  v1Policy: {
    policyId: string;
    policyName: string;
    effect: definitions["externaldatav1Effect"];
    selectors: definitions["externaldatav1Selector"][];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
    notes: string;
  };
  v1PrivateKey: {
    privateKeyId: string;
    publicKey: string;
    privateKeyName: string;
    curve: definitions["externaldatav1Curve"];
    addresses: definitions["externaldatav1Address"][];
    tags: string[];
  };
  v1PrivateKeyParams: {
    /** @inject_tag: validate:"required,max=40" */
    privateKeyName: string;
    curve: definitions["immutableactivityv1Curve"];
    /** @inject_tag: validate:"dive,uuid" */
    privateKeyTags: string[];
    /** @inject_tag: validate:"required" */
    addressFormats: definitions["immutableactivityv1AddressFormat"][];
  };
  v1PublicKeyCredentialWithAttestation: {
    id: string;
    /**
     * Must be literal string "public-key"
     * @enum {string}
     */
    type: "public-key";
    /** ENCODING: base64url */
    rawId: string;
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
    response: definitions["v1AuthenticatorAttestationResponse"];
    clientExtensionResults: definitions["v1SimpleClientExtensionResults"];
  };
  v1RejectActivityIntent: {
    /** @inject_tag: validate:"required" */
    fingerprint: string;
  };
  v1Result: {
    createOrganizationResult?: definitions["v1CreateOrganizationResult"];
    createAuthenticatorsResult?: definitions["v1CreateAuthenticatorsResult"];
    createUsersResult?: definitions["v1CreateUsersResult"];
    createPrivateKeysResult?: definitions["v1CreatePrivateKeysResult"];
    createInvitationsResult?: definitions["v1CreateInvitationsResult"];
    acceptInvitationResult?: definitions["v1AcceptInvitationResult"];
    signRawPayloadResult?: definitions["v1SignRawPayloadResult"];
    createPolicyResult?: definitions["v1CreatePolicyResult"];
    disablePrivateKeyResult?: definitions["v1DisablePrivateKeyResult"];
    deleteUsersResult?: definitions["v1DeleteUsersResult"];
    deleteAuthenticatorsResult?: definitions["v1DeleteAuthenticatorsResult"];
    deleteInvitationResult?: definitions["v1DeleteInvitationResult"];
    deleteOrganizationResult?: definitions["v1DeleteOrganizationResult"];
    deletePolicyResult?: definitions["v1DeletePolicyResult"];
    createUserTagResult?: definitions["v1CreateUserTagResult"];
    deleteUserTagsResult?: definitions["v1DeleteUserTagsResult"];
    signTransactionResult?: definitions["v1SignTransactionResult"];
    deleteApiKeysResult?: definitions["v1DeleteApiKeysResult"];
    createApiKeysResult?: definitions["v1CreateApiKeysResult"];
    createPrivateKeyTagResult?: definitions["v1CreatePrivateKeyTagResult"];
    deletePrivateKeyTagsResult?: definitions["v1DeletePrivateKeyTagsResult"];
  };
  v1SignRawPayloadIntent: {
    /** @inject_tag: validate:"required,uuid" */
    privateKeyId: string;
    /** @inject_tag: validate:"required" */
    payload: string;
    encoding: definitions["v1PayloadEncoding"];
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1SignRawPayloadIntent"];
  };
  v1SignRawPayloadResult: {
    r: string;
    s: string;
    v: string;
  };
  v1SignTransactionIntent: {
    /** @inject_tag: validate:"required,uuid" */
    privateKeyId: string;
    /** @inject_tag: validate:"required" */
    unsignedTransaction: string;
    type: definitions["immutableactivityv1TransactionType"];
  };
  v1SignTransactionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_TRANSACTION";
    timestampMs: string;
    organizationId: string;
    parameters: definitions["v1SignTransactionIntent"];
  };
  v1SignTransactionResult: {
    signedTransaction: string;
  };
  v1SimpleClientExtensionResults: {
    appid?: boolean;
    appidExclude?: boolean;
    credProps?: definitions["v1CredPropsAuthenticationExtensionsClientOutputs"];
  };
  /** @enum {string} */
  v1TagType: "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";
  v1Timestamp: {
    seconds: string;
    nanos: string;
  };
  v1User: {
    userId: string;
    alias: string;
    /** some users do not have emails (programmatic users) */
    email?: string;
    accessType: definitions["externaldatav1AccessType"];
    authenticators: definitions["v1Authenticator"][];
    apiKeys: definitions["v1ApiKey"][];
    tags: string[];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1UserParams: {
    /** @inject_tag: validate:"required,max=40" */
    userName: string;
    /** @inject_tag: validate:"email" */
    userEmail?: string;
    accessType: definitions["immutableactivityv1AccessType"];
    /** @inject_tag: validate:"dive,uuid" */
    apiKeys: definitions["v1ApiKeyParams"][];
    /** @inject_tag: validate:"dive" */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @inject_tag: validate:"dive,uuid" */
    userTags: string[];
  };
  v1Vote: {
    id: string;
    userId: string;
    user: definitions["v1User"];
    activityId: string;
    /** @enum {string} */
    selection: "VOTE_SELECTION_APPROVED" | "VOTE_SELECTION_REJECTED";
    message: string;
    publicKey: string;
    signature: string;
    scheme: string;
    createdAt: definitions["v1Timestamp"];
  };
};

export type operations = {
  /** Get details about an Activity */
  PublicApiService_GetActivity: {
    parameters: {
      body: {
        body: definitions["v1GetActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an Organization */
  PublicApiService_GetOrganization: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Policy */
  PublicApiService_GetPolicy: {
    parameters: {
      body: {
        body: definitions["v1GetPolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPolicyResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a User */
  PublicApiService_GetUser: {
    parameters: {
      body: {
        body: definitions["v1GetUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUserResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Activities within an Organization */
  PublicApiService_GetActivities: {
    parameters: {
      body: {
        body: definitions["v1GetActivitiesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetActivitiesResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Policies within an Organization */
  PublicApiService_GetPolicies: {
    parameters: {
      body: {
        body: definitions["v1GetPoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPoliciesResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Private Keys within an Organization */
  PublicApiService_GetPrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeysResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Users within an Organization */
  PublicApiService_GetUsers: {
    parameters: {
      body: {
        body: definitions["v1GetUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUsersResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get basic information about your current API user and your organization */
  PublicApiService_GetWhoami: {
    parameters: {
      body: {
        body: definitions["v1GetWhoamiRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWhoamiResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Add api keys to an existing User */
  PublicApiService_CreateApiKeys: {
    parameters: {
      body: {
        body: definitions["v1CreateApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Invitations to join an existing Organization */
  PublicApiService_CreateInvitations: {
    parameters: {
      body: {
        body: definitions["v1CreateInvitationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new Policy */
  PublicApiService_CreatePolicy: {
    parameters: {
      body: {
        body: definitions["v1CreatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new Private Keys */
  PublicApiService_CreatePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove api keys from a User */
  PublicApiService_DeleteApiKeys: {
    parameters: {
      body: {
        body: definitions["v1DeleteApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Invitation */
  PublicApiService_DeleteInvitation: {
    parameters: {
      body: {
        body: definitions["v1DeleteInvitationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Policy */
  PublicApiService_DeletePolicy: {
    parameters: {
      body: {
        body: definitions["v1DeletePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a raw payload with a Private Key */
  PublicApiService_SignRawPayload: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a transaction with a Private Key */
  PublicApiService_SignTransaction: {
    parameters: {
      body: {
        body: definitions["v1SignTransactionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Private Key */
  PublicApiService_GetPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeyResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
};

export type external = {};
