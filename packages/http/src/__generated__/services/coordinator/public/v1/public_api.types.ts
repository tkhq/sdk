/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/public/v1/query/get_activity": {
    /** Get details about an activity. */
    post: operations["PublicApiService_GetActivity"];
  };
  "/public/v1/query/get_api_key": {
    /** Get details about an API key. */
    post: operations["PublicApiService_GetApiKey"];
  };
  "/public/v1/query/get_api_keys": {
    /** Get details about API keys for a user. */
    post: operations["PublicApiService_GetApiKeys"];
  };
  "/public/v1/query/get_attestation": {
    /** Get the attestation document corresponding to an enclave. */
    post: operations["PublicApiService_GetAttestationDocument"];
  };
  "/public/v1/query/get_authenticator": {
    /** Get details about an authenticator. */
    post: operations["PublicApiService_GetAuthenticator"];
  };
  "/public/v1/query/get_authenticators": {
    /** Get details about authenticators for a user. */
    post: operations["PublicApiService_GetAuthenticators"];
  };
  "/public/v1/query/get_oauth_providers": {
    /** Get details about Oauth providers for a user. */
    post: operations["PublicApiService_GetOauthProviders"];
  };
  "/public/v1/query/get_organization": {
    /** Get details about an organization. */
    post: operations["PublicApiService_GetOrganization"];
  };
  "/public/v1/query/get_organization_configs": {
    /** Get quorum settings and features for an organization. */
    post: operations["PublicApiService_GetOrganizationConfigs"];
  };
  "/public/v1/query/get_policy": {
    /** Get details about a policy. */
    post: operations["PublicApiService_GetPolicy"];
  };
  "/public/v1/query/get_policy_evaluations": {
    /** Get the policy evaluations for an activity. */
    post: operations["PublicApiService_GetPolicyEvaluations"];
  };
  "/public/v1/query/get_private_key": {
    /** Get details about a private key. */
    post: operations["PublicApiService_GetPrivateKey"];
  };
<<<<<<< HEAD
  "/public/v1/query/get_smart_contract_interface": {
    /** Get details about a smart contract interface. */
    post: operations["PublicApiService_GetSmartContractInterface"];
=======
  "/public/v1/query/get_proxy_auth_config": {
    /** Get the proxy-auth configuration (allowed origins, etc.) for an Organization */
    post: operations["PublicApiService_GetProxyAuthConfig"];
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  };
  "/public/v1/query/get_smart_contract_interface": {
    /** Get details about a Smart Contract Interface */
    post: operations["PublicApiService_GetSmartContractInterface"];
  };
  "/public/v1/query/get_user": {
    /** Get details about a user. */
    post: operations["PublicApiService_GetUser"];
  };
  "/public/v1/query/get_wallet": {
    /** Get details about a wallet. */
    post: operations["PublicApiService_GetWallet"];
  };
  "/public/v1/query/get_wallet_account": {
    /** Get a single wallet account. */
    post: operations["PublicApiService_GetWalletAccount"];
  };
  "/public/v1/query/list_activities": {
    /** List all activities within an organization. */
    post: operations["PublicApiService_GetActivities"];
  };
  "/public/v1/query/list_policies": {
    /** List all policies within an organization. */
    post: operations["PublicApiService_GetPolicies"];
  };
  "/public/v1/query/list_private_key_tags": {
    /** List all private key tags within an organization. */
    post: operations["PublicApiService_ListPrivateKeyTags"];
  };
  "/public/v1/query/list_private_keys": {
    /** List all private keys within an organization. */
    post: operations["PublicApiService_GetPrivateKeys"];
  };
  "/public/v1/query/list_smart_contract_interfaces": {
<<<<<<< HEAD
    /** List all smart contract interfaces within an organization. */
=======
    /** List all Smart Contract Interfaces within an Organization */
>>>>>>> 57ef158e (updated auth proxy type generation)
    post: operations["PublicApiService_GetSmartContractInterfaces"];
  };
  "/public/v1/query/list_suborgs": {
    /** Get all suborg IDs associated given a parent org ID and an optional filter. */
    post: operations["PublicApiService_GetSubOrgIds"];
  };
  "/public/v1/query/list_user_tags": {
    /** List all user tags within an organization. */
    post: operations["PublicApiService_ListUserTags"];
  };
  "/public/v1/query/list_users": {
    /** List all users within an organization. */
    post: operations["PublicApiService_GetUsers"];
  };
  "/public/v1/query/list_verified_suborgs": {
    /** Get all email or phone verified suborg IDs associated given a parent org ID. */
    post: operations["PublicApiService_GetVerifiedSubOrgIds"];
  };
  "/public/v1/query/list_wallet_accounts": {
    /** List all accounts within a wallet. */
    post: operations["PublicApiService_GetWalletAccounts"];
  };
  "/public/v1/query/list_wallets": {
    /** List all wallets within an organization. */
    post: operations["PublicApiService_GetWallets"];
  };
  "/public/v1/query/whoami": {
    /** Get basic information about your current API or WebAuthN user and their organization. Affords sub-organization look ups via parent organization for WebAuthN or API key users. */
    post: operations["PublicApiService_GetWhoami"];
  };
  "/public/v1/submit/approve_activity": {
    /** Approve an activity. */
    post: operations["PublicApiService_ApproveActivity"];
  };
  "/public/v1/submit/create_api_keys": {
    /** Add API keys to an existing user. */
    post: operations["PublicApiService_CreateApiKeys"];
  };
  "/public/v1/submit/create_api_only_users": {
    /** Create API-only users in an existing organization. */
    post: operations["PublicApiService_CreateApiOnlyUsers"];
  };
  "/public/v1/submit/create_authenticators": {
    /** Create authenticators to authenticate requests to Turnkey. */
    post: operations["PublicApiService_CreateAuthenticators"];
  };
  "/public/v1/submit/create_invitations": {
    /** Create invitations to join an existing organization. */
    post: operations["PublicApiService_CreateInvitations"];
  };
  "/public/v1/submit/create_oauth_providers": {
    /** Create Oauth providers for a specified user. */
    post: operations["PublicApiService_CreateOauthProviders"];
  };
  "/public/v1/submit/create_policies": {
    /** Create new policies. */
    post: operations["PublicApiService_CreatePolicies"];
  };
  "/public/v1/submit/create_policy": {
    /** Create a new policy. */
    post: operations["PublicApiService_CreatePolicy"];
  };
  "/public/v1/submit/create_private_key_tag": {
    /** Create a private key tag and add it to private keys. */
    post: operations["PublicApiService_CreatePrivateKeyTag"];
  };
  "/public/v1/submit/create_private_keys": {
    /** Create new private keys. */
    post: operations["PublicApiService_CreatePrivateKeys"];
  };
  "/public/v1/submit/create_read_only_session": {
    /** Create a read only session for a user (valid for 1 hour). */
    post: operations["PublicApiService_CreateReadOnlySession"];
  };
  "/public/v1/submit/create_read_write_session": {
    /** Create a read write session for a user. */
    post: operations["PublicApiService_CreateReadWriteSession"];
  };
  "/public/v1/submit/create_smart_contract_interface": {
<<<<<<< HEAD
    /** Create an ABI/IDL in JSON. */
=======
    /** Create an ABI/IDL in JSON */
>>>>>>> 57ef158e (updated auth proxy type generation)
    post: operations["PublicApiService_CreateSmartContractInterface"];
  };
  "/public/v1/submit/create_sub_organization": {
    /** Create a new sub-organization. */
    post: operations["PublicApiService_CreateSubOrganization"];
  };
  "/public/v1/submit/create_user_tag": {
    /** Create a user tag and add it to users. */
    post: operations["PublicApiService_CreateUserTag"];
  };
  "/public/v1/submit/create_users": {
    /** Create users in an existing organization. */
    post: operations["PublicApiService_CreateUsers"];
  };
  "/public/v1/submit/create_wallet": {
    /** Create a wallet and derive addresses. */
    post: operations["PublicApiService_CreateWallet"];
  };
  "/public/v1/submit/create_wallet_accounts": {
    /** Derive additional addresses using an existing wallet. */
    post: operations["PublicApiService_CreateWalletAccounts"];
  };
  "/public/v1/submit/delete_api_keys": {
    /** Remove api keys from a user. */
    post: operations["PublicApiService_DeleteApiKeys"];
  };
  "/public/v1/submit/delete_authenticators": {
    /** Remove authenticators from a user. */
    post: operations["PublicApiService_DeleteAuthenticators"];
  };
  "/public/v1/submit/delete_invitation": {
    /** Delete an existing invitation. */
    post: operations["PublicApiService_DeleteInvitation"];
  };
  "/public/v1/submit/delete_oauth_providers": {
    /** Remove Oauth providers for a specified user. */
    post: operations["PublicApiService_DeleteOauthProviders"];
  };
  "/public/v1/submit/delete_policy": {
    /** Delete an existing policy. */
    post: operations["PublicApiService_DeletePolicy"];
  };
  "/public/v1/submit/delete_private_key_tags": {
    /** Delete private key tags within an organization. */
    post: operations["PublicApiService_DeletePrivateKeyTags"];
  };
  "/public/v1/submit/delete_private_keys": {
    /** Delete private keys for an organization. */
    post: operations["PublicApiService_DeletePrivateKeys"];
  };
  "/public/v1/submit/delete_smart_contract_interface": {
<<<<<<< HEAD
    /** Delete a smart contract interface. */
=======
    /** Delete a Smart Contract Interface */
>>>>>>> 57ef158e (updated auth proxy type generation)
    post: operations["PublicApiService_DeleteSmartContractInterface"];
  };
  "/public/v1/submit/delete_sub_organization": {
    /** Delete a sub-organization. */
    post: operations["PublicApiService_DeleteSubOrganization"];
  };
  "/public/v1/submit/delete_user_tags": {
    /** Delete user tags within an organization. */
    post: operations["PublicApiService_DeleteUserTags"];
  };
  "/public/v1/submit/delete_users": {
    /** Delete users within an organization. */
    post: operations["PublicApiService_DeleteUsers"];
  };
  "/public/v1/submit/delete_wallets": {
    /** Delete wallets for an organization. */
    post: operations["PublicApiService_DeleteWallets"];
  };
  "/public/v1/submit/disable_user_initiated_auth": {
    /** Disable User Initiated Auth */
    post: operations["PublicApiService_DisableUserInitiatedAuth"];
  };
  "/public/v1/submit/email_auth": {
    /** Authenticate a user via email. */
    post: operations["PublicApiService_EmailAuth"];
  };
  "/public/v1/submit/enable_user_initiated_auth": {
    /** Enable User Initiated Auth */
    post: operations["PublicApiService_EnableUserInitiatedAuth"];
  };
  "/public/v1/submit/export_private_key": {
    /** Export a private key. */
    post: operations["PublicApiService_ExportPrivateKey"];
  };
  "/public/v1/submit/export_wallet": {
    /** Export a wallet. */
    post: operations["PublicApiService_ExportWallet"];
  };
  "/public/v1/submit/export_wallet_account": {
    /** Export a wallet account. */
    post: operations["PublicApiService_ExportWalletAccount"];
  };
  "/public/v1/submit/import_private_key": {
    /** Import a private key. */
    post: operations["PublicApiService_ImportPrivateKey"];
  };
  "/public/v1/submit/import_wallet": {
    /** Import a wallet. */
    post: operations["PublicApiService_ImportWallet"];
  };
  "/public/v1/submit/init_fiat_on_ramp": {
    /** Initiate a fiat on ramp flow. */
    post: operations["PublicApiService_InitFiatOnRamp"];
  };
  "/public/v1/submit/init_import_private_key": {
    /** Initialize a new private key import. */
    post: operations["PublicApiService_InitImportPrivateKey"];
  };
  "/public/v1/submit/init_import_wallet": {
    /** Initialize a new wallet import. */
    post: operations["PublicApiService_InitImportWallet"];
  };
  "/public/v1/submit/init_otp": {
    /** Initiate a generic OTP activity. */
    post: operations["PublicApiService_InitOtp"];
  };
  "/public/v1/submit/init_otp_auth": {
    /** Initiate an OTP auth activity. */
    post: operations["PublicApiService_InitOtpAuth"];
  };
  "/public/v1/submit/init_user_email_recovery": {
    /** Initialize a new email recovery. */
    post: operations["PublicApiService_InitUserEmailRecovery"];
  };
  "/public/v1/submit/oauth": {
    /** Authenticate a user with an OIDC token (Oauth). */
    post: operations["PublicApiService_Oauth"];
  };
  "/public/v1/submit/oauth_login": {
    /** Create an Oauth session for a user. */
    post: operations["PublicApiService_OauthLogin"];
  };
  "/public/v1/submit/otp_auth": {
    /** Authenticate a user with an OTP code sent via email or SMS. */
    post: operations["PublicApiService_OtpAuth"];
  };
  "/public/v1/submit/otp_login": {
    /** Create an OTP session for a user. */
    post: operations["PublicApiService_OtpLogin"];
  };
  "/public/v1/submit/recover_user": {
    /** Complete the process of recovering a user by adding an authenticator. */
    post: operations["PublicApiService_RecoverUser"];
  };
  "/public/v1/submit/reject_activity": {
    /** Reject an activity. */
    post: operations["PublicApiService_RejectActivity"];
  };
  "/public/v1/submit/remove_organization_feature": {
    /** Remove an organization feature. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_RemoveOrganizationFeature"];
  };
  "/public/v1/submit/set_organization_feature": {
    /** Set an organization feature. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_SetOrganizationFeature"];
  };
  "/public/v1/submit/sign_raw_payload": {
    /** Sign a raw payload. */
    post: operations["PublicApiService_SignRawPayload"];
  };
  "/public/v1/submit/sign_raw_payloads": {
    /** Sign multiple raw payloads with the same signing parameters. */
    post: operations["PublicApiService_SignRawPayloads"];
  };
  "/public/v1/submit/sign_transaction": {
    /** Sign a transaction. */
    post: operations["PublicApiService_SignTransaction"];
  };
  "/public/v1/submit/stamp_login": {
    /** Create a session for a user through stamping client side (API key, wallet client, or passkey client). */
    post: operations["PublicApiService_StampLogin"];
  };
  "/public/v1/submit/update_policy": {
    /** Update an existing policy. */
    post: operations["PublicApiService_UpdatePolicy"];
  };
  "/public/v1/submit/update_private_key_tag": {
    /** Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
    post: operations["PublicApiService_UpdatePrivateKeyTag"];
  };
  "/public/v1/submit/update_proxy_auth_config": {
    /** Update the proxy-auth configuration (allowed origins, etc.) for an Organization */
    post: operations["PublicApiService_UpdateProxyAuthConfig"];
  };
  "/public/v1/submit/update_root_quorum": {
    /** Set the threshold and members of the root quorum. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_UpdateRootQuorum"];
  };
  "/public/v1/submit/update_user": {
    /** Update a user in an existing organization. */
    post: operations["PublicApiService_UpdateUser"];
  };
  "/public/v1/submit/update_user_email": {
    /** Update a user's email in an existing organization. */
    post: operations["PublicApiService_UpdateUserEmail"];
  };
  "/public/v1/submit/update_user_name": {
    /** Update a user's name in an existing organization. */
    post: operations["PublicApiService_UpdateUserName"];
  };
  "/public/v1/submit/update_user_phone_number": {
    /** Update a user's phone number in an existing organization. */
    post: operations["PublicApiService_UpdateUserPhoneNumber"];
  };
  "/public/v1/submit/update_user_tag": {
    /** Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
    post: operations["PublicApiService_UpdateUserTag"];
  };
  "/public/v1/submit/update_wallet": {
    /** Update a wallet for an organization. */
    post: operations["PublicApiService_UpdateWallet"];
  };
  "/public/v1/submit/verify_otp": {
    /** Verify a generic OTP. */
    post: operations["PublicApiService_VerifyOtp"];
  };
  "/tkhq/api/v1/noop-codegen-anchor": {
    post: operations["PublicApiService_NOOPCodegenAnchor"];
  };
  "/tkhq/api/v1/test_rate_limits": {
    /** Set a rate local rate limit just on the current endpoint, for purposes of testing with Vivosuite. */
    post: operations["PublicApiService_TestRateLimits"];
  };
};

export type definitions = {
  apiApiKeyParams: {
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description Optional window (in seconds) indicating how long the API Key should last. */
    expirationSeconds?: string;
  };
  billingActivateBillingTierIntent: {
    /** @description The product that the customer wants to subscribe to. */
    productId: string;
  };
  billingActivateBillingTierResult: {
    /** @description The id of the product being subscribed to. */
    productId: string;
  };
  billingDeletePaymentMethodIntent: {
    /** @description The payment method that the customer wants to remove. */
    paymentMethodId: string;
  };
  billingDeletePaymentMethodResult: {
    /** @description The payment method that was removed. */
    paymentMethodId: string;
  };
  billingSetPaymentMethodIntent: {
    /** @description The account number of the customer's credit card. */
    number: string;
    /** @description The verification digits of the customer's credit card. */
    cvv: string;
    /** @description The month that the credit card expires. */
    expiryMonth: string;
    /** @description The year that the credit card expires. */
    expiryYear: string;
    /** @description The email that will receive invoices for the credit card. */
    cardHolderEmail: string;
    /** @description The name associated with the credit card. */
    cardHolderName: string;
  };
  billingSetPaymentMethodIntentV2: {
    /** @description The id of the payment method that was created clientside. */
    paymentMethodId: string;
    /** @description The email that will receive invoices for the credit card. */
    cardHolderEmail: string;
    /** @description The name associated with the credit card. */
    cardHolderName: string;
  };
  billingSetPaymentMethodResult: {
    /** @description The last four digits of the credit card added. */
    lastFour: string;
    /** @description The name associated with the payment method. */
    cardHolderName: string;
    /** @description The email address associated with the payment method. */
    cardHolderEmail: string;
  };
  datav1Tag: {
    /** @description Unique identifier for a given Tag. */
    tagId: string;
    /** @description Human-readable name for a Tag. */
    tagName: string;
    tagType: definitions["v1TagType"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  externalactivityv1PolicyEvaluation: {
    /** @description Unique identifier for a given policy evaluation. */
    id: string;
    /** @description Unique identifier for a given Activity. */
    activityId: string;
    /** @description Unique identifier for the Organization the Activity belongs to. */
    organizationId: string;
    /** @description Unique identifier for the Vote associated with this policy evaluation. */
    voteId: string;
    /** @description Detailed evaluation result for each Policy that was run. */
    policyEvaluations: definitions["privateumpv1PolicyEvaluation"][];
    createdAt: definitions["externaldatav1Timestamp"];
  };
  externaldatav1Address: {
    format?: definitions["v1AddressFormat"];
    address?: string;
  };
  externaldatav1Credential: {
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    type: definitions["v1CredentialType"];
  };
  externaldatav1Quorum: {
    /**
     * Format: int32
     * @description Count of unique approvals required to meet quorum.
     */
    threshold: number;
    /** @description Unique identifiers of quorum set members. */
    userIds: string[];
  };
  externaldatav1SmartContractInterface: {
    /** @description The Organization the Smart Contract Interface belongs to. */
    organizationId: string;
    /** @description Unique identifier for a given Smart Contract Interface (ABI or IDL). */
    smartContractInterfaceId: string;
    /** @description The address corresponding to the Smart Contract or Program. */
    smartContractAddress: string;
    /** @description The JSON corresponding to the Smart Contract Interface (ABI or IDL). */
    smartContractInterface: string;
    /** @description The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    type: string;
    /** @description The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    label: string;
    /** @description The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    notes: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  externaldatav1Timestamp: {
    seconds: string;
    nanos: string;
  };
  immutableactivityv1Address: {
    format?: definitions["v1AddressFormat"];
    address?: string;
  };
  privateumpv1PolicyEvaluation: {
    policyId?: string;
    outcome?: definitions["v1Outcome"];
  };
  protobufAny: {
    "@type"?: string;
  } & { [key: string]: unknown };
  rpcStatus: {
    /** Format: int32 */
    code?: number;
    message?: string;
    details?: definitions["protobufAny"][];
  };
  v1AcceptInvitationIntent: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
    authenticator: definitions["v1AuthenticatorParams"];
  };
  v1AcceptInvitationIntentV2: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
    authenticator: definitions["v1AuthenticatorParamsV2"];
  };
  v1AcceptInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  /** @enum {string} */
  v1AccessType: "ACCESS_TYPE_WEB" | "ACCESS_TYPE_API" | "ACCESS_TYPE_ALL";
  v1Activity: {
    /** @description Unique identifier for a given Activity object. */
    id: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description The current processing status of a specified Activity. */
    status: definitions["v1ActivityStatus"];
    /** @description Type of Activity, such as Add User, or Sign Transaction. */
    type: definitions["v1ActivityType"];
    /** @description Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
    intent: definitions["v1Intent"];
    /** @description Result of the intended action. */
    result: definitions["v1Result"];
    /** @description A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
    votes: definitions["v1Vote"][];
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
    canApprove: boolean;
    canReject: boolean;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Failure reason of the intended action. */
    failure?: definitions["rpcStatus"];
  };
  v1ActivityResponse: {
    /** @description An action that can be taken within the Turnkey infrastructure. */
    activity: definitions["v1Activity"];
  };
  /** @enum {string} */
  v1ActivityStatus:
    | "ACTIVITY_STATUS_CREATED"
    | "ACTIVITY_STATUS_PENDING"
    | "ACTIVITY_STATUS_COMPLETED"
    | "ACTIVITY_STATUS_FAILED"
    | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    | "ACTIVITY_STATUS_REJECTED";
  /** @enum {string} */
  v1ActivityType:
    | "ACTIVITY_TYPE_CREATE_API_KEYS"
    | "ACTIVITY_TYPE_CREATE_USERS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
    | "ACTIVITY_TYPE_CREATE_INVITATIONS"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION"
    | "ACTIVITY_TYPE_CREATE_POLICY"
    | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
    | "ACTIVITY_TYPE_DELETE_USERS"
    | "ACTIVITY_TYPE_DELETE_API_KEYS"
    | "ACTIVITY_TYPE_DELETE_INVITATION"
    | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
    | "ACTIVITY_TYPE_DELETE_POLICY"
    | "ACTIVITY_TYPE_CREATE_USER_TAG"
    | "ACTIVITY_TYPE_DELETE_USER_TAGS"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION"
    | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    | "ACTIVITY_TYPE_REJECT_ACTIVITY"
    | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    | "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
    | "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
    | "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
    | "ACTIVITY_TYPE_CREATE_POLICY_V2"
    | "ACTIVITY_TYPE_CREATE_POLICY_V3"
    | "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
    | "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
    | "ACTIVITY_TYPE_UPDATE_USER_TAG"
    | "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
    | "ACTIVITY_TYPE_CREATE_USERS_V2"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
    | "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
    | "ACTIVITY_TYPE_UPDATE_USER"
    | "ACTIVITY_TYPE_UPDATE_POLICY"
    | "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
    | "ACTIVITY_TYPE_CREATE_WALLET"
    | "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
    | "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
    | "ACTIVITY_TYPE_RECOVER_USER"
    | "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
    | "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    | "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_EXPORT_WALLET"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
    | "ACTIVITY_TYPE_EMAIL_AUTH"
    | "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
    | "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
    | "ACTIVITY_TYPE_IMPORT_WALLET"
    | "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_CREATE_POLICIES"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
    | "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
    | "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
    | "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
    | "ACTIVITY_TYPE_OAUTH"
    | "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
    | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
    | "ACTIVITY_TYPE_EMAIL_AUTH_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_DELETE_WALLETS"
    | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
    | "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
    | "ACTIVITY_TYPE_INIT_OTP_AUTH"
    | "ACTIVITY_TYPE_OTP_AUTH"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
    | "ACTIVITY_TYPE_UPDATE_WALLET"
    | "ACTIVITY_TYPE_UPDATE_POLICY_V2"
    | "ACTIVITY_TYPE_CREATE_USERS_V3"
    | "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
    | "ACTIVITY_TYPE_INIT_OTP"
    | "ACTIVITY_TYPE_VERIFY_OTP"
    | "ACTIVITY_TYPE_OTP_LOGIN"
    | "ACTIVITY_TYPE_STAMP_LOGIN"
    | "ACTIVITY_TYPE_OAUTH_LOGIN"
    | "ACTIVITY_TYPE_UPDATE_USER_NAME"
    | "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
    | "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
    | "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
<<<<<<< HEAD
<<<<<<< HEAD
    | "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
    | "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE";
=======
=======
    | "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
    | "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
>>>>>>> 57ef158e (updated auth proxy type generation)
    | "ACTIVITY_TYPE_ENABLE_USER_INITIATED_AUTH"
    | "ACTIVITY_TYPE_DISABLE_USER_INITIATED_AUTH"
    | "ACTIVITY_TYPE_UPDATE_PROXY_AUTH_CONFIG";
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  /** @enum {string} */
  v1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_SOLANA"
    | "ADDRESS_FORMAT_COSMOS"
    | "ADDRESS_FORMAT_TRON"
    | "ADDRESS_FORMAT_SUI"
    | "ADDRESS_FORMAT_APTOS"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
    | "ADDRESS_FORMAT_SEI"
    | "ADDRESS_FORMAT_XLM"
    | "ADDRESS_FORMAT_DOGE_MAINNET"
    | "ADDRESS_FORMAT_DOGE_TESTNET"
    | "ADDRESS_FORMAT_TON_V3R2"
    | "ADDRESS_FORMAT_TON_V4R2"
    | "ADDRESS_FORMAT_TON_V5R1"
    | "ADDRESS_FORMAT_XRP";
  v1ApiKey: {
    /** @description A User credential that can be used to authenticate to Turnkey. */
    credential: definitions["externaldatav1Credential"];
    /** @description Unique identifier for a given API Key. */
    apiKeyId: string;
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /**
     * Format: uint64
     * @description Optional window (in seconds) indicating how long the API Key should last.
     */
    expirationSeconds?: string;
  };
  /** @enum {string} */
  v1ApiKeyCurve:
    | "API_KEY_CURVE_P256"
    | "API_KEY_CURVE_SECP256K1"
    | "API_KEY_CURVE_ED25519";
  v1ApiKeyParamsV2: {
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description The curve type to be used for processing API key signatures. */
    curveType: definitions["v1ApiKeyCurve"];
    /** @description Optional window (in seconds) indicating how long the API Key should last. */
    expirationSeconds?: string;
  };
  v1ApiOnlyUserParams: {
    /** @description The name of the new API-only User. */
    userName: string;
    /** @description The email address for this API-only User (optional). */
    userEmail?: string;
    /** @description A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
  };
  v1ApproveActivityIntent: {
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
  };
  v1ApproveActivityRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_APPROVE_ACTIVITY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ApproveActivityIntent"];
  };
  v1Attestation: {
    /** @description The cbor encoded then base64 url encoded id of the credential. */
    credentialId: string;
    /** @description A base64 url encoded payload containing metadata about the signing context and the challenge. */
    clientDataJson: string;
    /** @description A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
    attestationObject: string;
    /** @description The type of authenticator transports. */
    transports: definitions["v1AuthenticatorTransport"][];
  };
  v1Authenticator: {
    /** @description Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
    transports: definitions["v1AuthenticatorTransport"][];
    attestationType: string;
    /** @description Identifier indicating the type of the Security Key. */
    aaguid: string;
    /** @description Unique identifier for a WebAuthn credential. */
    credentialId: string;
    /** @description The type of Authenticator device. */
    model: string;
    /** @description A User credential that can be used to authenticate to Turnkey. */
    credential: definitions["externaldatav1Credential"];
    /** @description Unique identifier for a given Authenticator. */
    authenticatorId: string;
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1AuthenticatorAttestationResponse: {
    clientDataJson: string;
    attestationObject: string;
    transports?: definitions["v1AuthenticatorTransport"][];
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
  };
  v1AuthenticatorParams: {
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    attestation: definitions["v1PublicKeyCredentialWithAttestation"];
    /** @description Challenge presented for authentication purposes. */
    challenge: string;
  };
  v1AuthenticatorParamsV2: {
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    /** @description Challenge presented for authentication purposes. */
    challenge: string;
    /** @description The attestation that proves custody of the authenticator and provides metadata about it. */
    attestation: definitions["v1Attestation"];
  };
  /** @enum {string} */
  v1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  v1Config: {
    features?: definitions["v1Feature"][];
    quorum?: definitions["externaldatav1Quorum"];
  };
  v1CreateApiKeysIntent: {
    /** @description A list of API Keys. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateApiKeysIntentV2: {
    /** @description A list of API Keys. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateApiKeysIntentV2"];
  };
  v1CreateApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1CreateApiOnlyUsersIntent: {
    /** @description A list of API-only Users to create. */
    apiOnlyUsers: definitions["v1ApiOnlyUserParams"][];
  };
  v1CreateApiOnlyUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateApiOnlyUsersIntent"];
  };
  v1CreateApiOnlyUsersResult: {
    /** @description A list of API-only User IDs. */
    userIds: string[];
  };
  v1CreateAuthenticatorsIntent: {
    /** @description A list of Authenticators. */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateAuthenticatorsIntentV2: {
    /** @description A list of Authenticators. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateAuthenticatorsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateAuthenticatorsIntentV2"];
  };
  v1CreateAuthenticatorsResult: {
    /** @description A list of Authenticator IDs. */
    authenticatorIds: string[];
  };
  v1CreateInvitationsIntent: {
    /** @description A list of Invitations. */
    invitations: definitions["v1InvitationParams"][];
  };
  v1CreateInvitationsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_INVITATIONS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateInvitationsIntent"];
  };
  v1CreateInvitationsResult: {
    /** @description A list of Invitation IDs */
    invitationIds: string[];
  };
  v1CreateOauthProvidersIntent: {
    /** @description The ID of the User to add an Oauth provider to */
    userId: string;
    /** @description A list of Oauth providers. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1CreateOauthProvidersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateOauthProvidersIntent"];
  };
  v1CreateOauthProvidersResult: {
    /** @description A list of unique identifiers for Oauth Providers */
    providerIds: string[];
  };
  v1CreateOrganizationIntent: {
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description The root user's email address. */
    rootEmail: string;
    /** @description The root user's Authenticator. */
    rootAuthenticator: definitions["v1AuthenticatorParams"];
    /** @description Unique identifier for the root user object. */
    rootUserId?: string;
  };
  v1CreateOrganizationIntentV2: {
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description The root user's email address. */
    rootEmail: string;
    /** @description The root user's Authenticator. */
    rootAuthenticator: definitions["v1AuthenticatorParamsV2"];
    /** @description Unique identifier for the root user object. */
    rootUserId?: string;
  };
  v1CreateOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1CreatePoliciesIntent: {
    /** @description An array of policy intents to be created. */
    policies: definitions["v1CreatePolicyIntentV3"][];
  };
  v1CreatePoliciesRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICIES";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePoliciesIntent"];
  };
  v1CreatePoliciesResult: {
    /** @description A list of unique identifiers for the created policies. */
    policyIds: string[];
  };
  v1CreatePolicyIntent: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
    selectors: definitions["v1Selector"][];
    /** @description The instruction to DENY or ALLOW a particular activity following policy selector(s). */
    effect: definitions["v1Effect"];
    notes?: string;
  };
  v1CreatePolicyIntentV2: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
    selectors: definitions["v1SelectorV2"][];
    /** @description Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
    effect: definitions["v1Effect"];
    notes?: string;
  };
  v1CreatePolicyIntentV3: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description The instruction to DENY or ALLOW an activity. */
    effect: definitions["v1Effect"];
    /** @description The condition expression that triggers the Effect */
    condition?: string;
    /** @description The consensus expression that triggers the Effect */
    consensus?: string;
    notes?: string;
  };
  v1CreatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICY_V3";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePolicyIntentV3"];
  };
  v1CreatePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1CreatePrivateKeyTagIntent: {
    /** @description Human-readable name for a Private Key Tag. */
    privateKeyTagName: string;
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeyTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeyTagIntent"];
  };
  v1CreatePrivateKeyTagResult: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysIntent: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysIntentV2: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeysIntentV2"];
  };
  v1CreatePrivateKeysResult: {
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysResultV2: {
    /** @description A list of Private Key IDs and addresses. */
    privateKeys: definitions["v1PrivateKeyResult"][];
  };
  v1CreateReadOnlySessionIntent: { [key: string]: unknown };
  v1CreateReadOnlySessionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateReadOnlySessionIntent"];
  };
  v1CreateReadOnlySessionResult: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description String representing a read only session */
    session: string;
    /**
     * Format: uint64
     * @description UTC timestamp in seconds representing the expiry time for the read only session.
     */
    sessionExpiry: string;
  };
  v1CreateReadWriteSessionIntent: {
    /** @description Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Email of the user to create a read write session for */
    email: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
  };
  v1CreateReadWriteSessionIntentV2: {
    /** @description Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Unique identifier for a given User. */
    userId?: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated ReadWriteSession API keys */
    invalidateExisting?: boolean;
  };
  v1CreateReadWriteSessionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateReadWriteSessionIntentV2"];
  };
  v1CreateReadWriteSessionResult: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  v1CreateReadWriteSessionResultV2: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  v1CreateSmartContractInterfaceIntent: {
    /** @description Corresponding contract address or program ID */
    smartContractAddress: string;
    /** @description ABI/IDL as a JSON string */
    smartContractInterface: string;
    type: definitions["v1SmartContractInterfaceType"];
    /** @description Human-readable name for a Smart Contract Interface. */
<<<<<<< HEAD
    label: string;
=======
    label?: string;
>>>>>>> 57ef158e (updated auth proxy type generation)
    /** @description Notes for a Smart Contract Interface. */
    notes?: string;
  };
  v1CreateSmartContractInterfaceRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateSmartContractInterfaceIntent"];
  };
  v1CreateSmartContractInterfaceResult: {
    /** @description The ID of the created Smart Contract Interface. */
    smartContractInterfaceId: string;
  };
  v1CreateSubOrganizationIntent: {
    /** @description Name for this sub-organization */
    name: string;
    /** @description Root User authenticator for this new sub-organization */
    rootAuthenticator: definitions["v1AuthenticatorParamsV2"];
  };
  v1CreateSubOrganizationIntentV2: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
  };
  v1CreateSubOrganizationIntentV3: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreateSubOrganizationIntentV4: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV5: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV2"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV6: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV3"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV7: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV4"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
    /** @description Disable OTP SMS auth for the sub-organization */
    disableSmsAuth?: boolean;
    /** @description Disable OTP email auth for the sub-organization */
    disableOtpEmailAuth?: boolean;
    /** @description Signed JWT containing a unique id, expiry, verification type, contact */
    verificationToken?: string;
  };
  v1CreateSubOrganizationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateSubOrganizationIntentV7"];
  };
  v1CreateSubOrganizationResult: {
    subOrganizationId: string;
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV3: {
    subOrganizationId: string;
    /** @description A list of Private Key IDs and addresses. */
    privateKeys: definitions["v1PrivateKeyResult"][];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV4: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV5: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV6: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV7: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateUserTagIntent: {
    /** @description Human-readable name for a User Tag. */
    userTagName: string;
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateUserTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_USER_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateUserTagIntent"];
  };
  v1CreateUserTagResult: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateUsersIntent: {
    /** @description A list of Users. */
    users: definitions["v1UserParams"][];
  };
  v1CreateUsersIntentV2: {
    /** @description A list of Users. */
    users: definitions["v1UserParamsV2"][];
  };
  v1CreateUsersIntentV3: {
    /** @description A list of Users. */
    users: definitions["v1UserParamsV3"][];
  };
  v1CreateUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_USERS_V3";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateUsersIntentV3"];
  };
  v1CreateUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateWalletAccountsIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description A list of wallet Accounts. */
    accounts: definitions["v1WalletAccountParams"][];
  };
  v1CreateWalletAccountsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateWalletAccountsIntent"];
  };
  v1CreateWalletAccountsResult: {
    /** @description A list of derived addresses. */
    addresses: string[];
  };
  v1CreateWalletIntent: {
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
    accounts: definitions["v1WalletAccountParams"][];
    /**
     * Format: int32
     * @description Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
     */
    mnemonicLength?: number;
  };
  v1CreateWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateWalletIntent"];
  };
  v1CreateWalletResult: {
    /** @description Unique identifier for a Wallet. */
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1CredPropsAuthenticationExtensionsClientOutputs: {
    rk: boolean;
  };
  /** @enum {string} */
  v1CredentialType:
    | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
    | "CREDENTIAL_TYPE_API_KEY_P256"
    | "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
    | "CREDENTIAL_TYPE_API_KEY_SECP256K1"
    | "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
    | "CREDENTIAL_TYPE_API_KEY_ED25519"
    | "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
    | "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
    | "CREDENTIAL_TYPE_OAUTH_KEY_P256"
    | "CREDENTIAL_TYPE_LOGIN";
  /** @enum {string} */
  v1Curve: "CURVE_SECP256K1" | "CURVE_ED25519";
  v1DeleteApiKeysIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1DeleteApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_API_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteApiKeysIntent"];
  };
  v1DeleteApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1DeleteAuthenticatorsIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description A list of Authenticator IDs. */
    authenticatorIds: string[];
  };
  v1DeleteAuthenticatorsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteAuthenticatorsIntent"];
  };
  v1DeleteAuthenticatorsResult: {
    /** @description Unique identifier for a given Authenticator. */
    authenticatorIds: string[];
  };
  v1DeleteInvitationIntent: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
  };
  v1DeleteInvitationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_INVITATION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteInvitationIntent"];
  };
  v1DeleteInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
  };
  v1DeleteOauthProvidersIntent: {
    /** @description The ID of the User to remove an Oauth provider from */
    userId: string;
    /** @description Unique identifier for a given Provider. */
    providerIds: string[];
  };
  v1DeleteOauthProvidersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteOauthProvidersIntent"];
  };
  v1DeleteOauthProvidersResult: {
    /** @description A list of unique identifiers for Oauth Providers */
    providerIds: string[];
  };
  v1DeleteOrganizationIntent: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1DeleteOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1DeletePolicyIntent: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1DeletePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_POLICY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePolicyIntent"];
  };
  v1DeletePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1DeletePrivateKeyTagsIntent: {
    /** @description A list of Private Key Tag IDs. */
    privateKeyTagIds: string[];
  };
  v1DeletePrivateKeyTagsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePrivateKeyTagsIntent"];
  };
  v1DeletePrivateKeyTagsResult: {
    /** @description A list of Private Key Tag IDs. */
    privateKeyTagIds: string[];
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1DeletePrivateKeysIntent: {
    /** @description List of unique identifiers for private keys within an organization */
    privateKeyIds: string[];
    /** @description Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
    deleteWithoutExport?: boolean;
  };
  v1DeletePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePrivateKeysIntent"];
  };
  v1DeletePrivateKeysResult: {
    /** @description A list of private key unique identifiers that were removed */
    privateKeyIds: string[];
  };
  v1DeleteSmartContractInterfaceIntent: {
    /** @description The ID of a Smart Contract Interface intended for deletion. */
    smartContractInterfaceId: string;
  };
  v1DeleteSmartContractInterfaceRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteSmartContractInterfaceIntent"];
  };
  v1DeleteSmartContractInterfaceResult: {
    /** @description The ID of the deleted Smart Contract Interface. */
    smartContractInterfaceId: string;
  };
  v1DeleteSubOrganizationIntent: {
    /** @description Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
    deleteWithoutExport?: boolean;
  };
  v1DeleteSubOrganizationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteSubOrganizationIntent"];
  };
  v1DeleteSubOrganizationResult: {
    /** @description Unique identifier of the sub organization that was removed */
    subOrganizationUuid: string;
  };
  v1DeleteUserTagsIntent: {
    /** @description A list of User Tag IDs. */
    userTagIds: string[];
  };
  v1DeleteUserTagsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_USER_TAGS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteUserTagsIntent"];
  };
  v1DeleteUserTagsResult: {
    /** @description A list of User Tag IDs. */
    userTagIds: string[];
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteUsersIntent: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_USERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteUsersIntent"];
  };
  v1DeleteUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteWalletsIntent: {
    /** @description List of unique identifiers for wallets within an organization */
    walletIds: string[];
    /** @description Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
    deleteWithoutExport?: boolean;
  };
  v1DeleteWalletsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_WALLETS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteWalletsIntent"];
  };
  v1DeleteWalletsResult: {
    /** @description A list of wallet unique identifiers that were removed */
    walletIds: string[];
  };
  v1DisablePrivateKeyIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1DisablePrivateKeyResult: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1DisableUserInitiatedAuthIntent: {
    /** @description Unique identifier for a given User. (representing the turnkey signer user id) */
    userId?: string;
    /** @description Unique identifier for a given Policy. (representing the turnkey signer associated policy) */
    policyId?: string;
  };
  v1DisableUserInitiatedAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DISABLE_USER_INITIATED_AUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DisableUserInitiatedAuthIntent"];
  };
  v1DisableUserInitiatedAuthResult: { [key: string]: unknown };
  /** @enum {string} */
  v1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  v1EmailAuthIntent: {
    /** @description Email of the authenticating user. */
    email: string;
    /** @description Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Invalidate all other previously generated Email Auth API keys */
    invalidateExisting?: boolean;
    /** @description Optional custom email address from which to send the email */
    sendFromEmailAddress?: string;
    /** @description Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
    sendFromEmailSenderName?: string;
    /** @description Optional custom email address to use as reply-to */
    replyToEmailAddress?: string;
  };
  v1EmailAuthIntentV2: {
    /** @description Email of the authenticating user. */
    email: string;
    /** @description Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Invalidate all other previously generated Email Auth API keys */
    invalidateExisting?: boolean;
    /** @description Optional custom email address from which to send the email */
    sendFromEmailAddress?: string;
    /** @description Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
    sendFromEmailSenderName?: string;
    /** @description Optional custom email address to use as reply-to */
    replyToEmailAddress?: string;
  };
  v1EmailAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EMAIL_AUTH_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1EmailAuthIntentV2"];
  };
  v1EmailAuthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
  };
  v1EmailCustomizationParams: {
    /** @description The name of the application. */
    appName?: string;
    /** @description A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
    logoUrl?: string;
    /** @description A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
    magicLinkTemplate?: string;
    /** @description JSON object containing key/value pairs to be used with custom templates. */
    templateVariables?: string;
    /** @description Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
    templateId?: string;
  };
  v1EnableUserInitiatedAuthIntent: { [key: string]: unknown };
  v1EnableUserInitiatedAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_ENABLE_USER_INITIATED_AUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1EnableUserInitiatedAuthIntent"];
  };
  v1EnableUserInitiatedAuthResult: {
    /** @description A User ID. */
    userId: string;
    /** @description A Policy ID. */
    policyId: string;
  };
  v1EwkSettingsParams: {
    /** @description Enable Sign in with Apple */
    appleEnabled?: boolean;
    /** @description Enable Sign in with Google */
    googleEnabled?: boolean;
    /** @description Enable Sign in with Facebook */
    facebookEnabled?: boolean;
    /** @description Whether to open OAuth providers in-page instead of a popup */
    openOauthInPage?: boolean;
  };
  v1ExportPrivateKeyIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
  };
  v1ExportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportPrivateKeyIntent"];
  };
  v1ExportPrivateKeyResult: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Export bundle containing a private key encrypted to the client's target public key. */
    exportBundle: string;
  };
  v1ExportWalletAccountIntent: {
    /** @description Address to identify Wallet Account. */
    address: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
  };
  v1ExportWalletAccountRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportWalletAccountIntent"];
  };
  v1ExportWalletAccountResult: {
    /** @description Address to identify Wallet Account. */
    address: string;
    /** @description Export bundle containing a private key encrypted by the client's target public key. */
    exportBundle: string;
  };
  v1ExportWalletIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
    /** @description The language of the mnemonic to export. Defaults to English. */
    language?: definitions["v1MnemonicLanguage"];
  };
  v1ExportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportWalletIntent"];
  };
  v1ExportWalletResult: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
    exportBundle: string;
  };
  v1Feature: {
    name?: definitions["v1FeatureName"];
    value?: string;
  };
  /** @enum {string} */
  v1FeatureName:
    | "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
    | "FEATURE_NAME_WEBAUTHN_ORIGINS"
    | "FEATURE_NAME_EMAIL_AUTH"
    | "FEATURE_NAME_EMAIL_RECOVERY"
    | "FEATURE_NAME_WEBHOOK"
    | "FEATURE_NAME_SMS_AUTH"
    | "FEATURE_NAME_OTP_EMAIL_AUTH";
  /** @enum {string} */
  v1FiatOnRampBlockchainNetwork:
    | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN"
    | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM"
    | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA"
    | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE";
  /** @enum {string} */
  v1FiatOnRampCryptoCurrency:
    | "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC"
    | "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH"
    | "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL"
    | "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";
  /** @enum {string} */
  v1FiatOnRampCurrency:
    | "FIAT_ON_RAMP_CURRENCY_AUD"
    | "FIAT_ON_RAMP_CURRENCY_BGN"
    | "FIAT_ON_RAMP_CURRENCY_BRL"
    | "FIAT_ON_RAMP_CURRENCY_CAD"
    | "FIAT_ON_RAMP_CURRENCY_CHF"
    | "FIAT_ON_RAMP_CURRENCY_COP"
    | "FIAT_ON_RAMP_CURRENCY_CZK"
    | "FIAT_ON_RAMP_CURRENCY_DKK"
    | "FIAT_ON_RAMP_CURRENCY_DOP"
    | "FIAT_ON_RAMP_CURRENCY_EGP"
    | "FIAT_ON_RAMP_CURRENCY_EUR"
    | "FIAT_ON_RAMP_CURRENCY_GBP"
    | "FIAT_ON_RAMP_CURRENCY_HKD"
    | "FIAT_ON_RAMP_CURRENCY_IDR"
    | "FIAT_ON_RAMP_CURRENCY_ILS"
    | "FIAT_ON_RAMP_CURRENCY_JOD"
    | "FIAT_ON_RAMP_CURRENCY_KES"
    | "FIAT_ON_RAMP_CURRENCY_KWD"
    | "FIAT_ON_RAMP_CURRENCY_LKR"
    | "FIAT_ON_RAMP_CURRENCY_MXN"
    | "FIAT_ON_RAMP_CURRENCY_NGN"
    | "FIAT_ON_RAMP_CURRENCY_NOK"
    | "FIAT_ON_RAMP_CURRENCY_NZD"
    | "FIAT_ON_RAMP_CURRENCY_OMR"
    | "FIAT_ON_RAMP_CURRENCY_PEN"
    | "FIAT_ON_RAMP_CURRENCY_PLN"
    | "FIAT_ON_RAMP_CURRENCY_RON"
    | "FIAT_ON_RAMP_CURRENCY_SEK"
    | "FIAT_ON_RAMP_CURRENCY_THB"
    | "FIAT_ON_RAMP_CURRENCY_TRY"
    | "FIAT_ON_RAMP_CURRENCY_TWD"
    | "FIAT_ON_RAMP_CURRENCY_USD"
    | "FIAT_ON_RAMP_CURRENCY_VND"
    | "FIAT_ON_RAMP_CURRENCY_ZAR";
  /** @enum {string} */
  v1FiatOnRampPaymentMethod:
    | "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET"
    | "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT";
  /** @enum {string} */
  v1FiatOnRampProvider:
    | "FIAT_ON_RAMP_PROVIDER_COINBASE"
    | "FIAT_ON_RAMP_PROVIDER_MOONPAY";
  v1GetActivitiesRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Array of activity statuses filtering which activities will be listed in the response. */
    filterByStatus?: definitions["v1ActivityStatus"][];
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
    /** @description Array of activity types filtering which activities will be listed in the response. */
    filterByType?: definitions["v1ActivityType"][];
  };
  v1GetActivitiesResponse: {
    /** @description A list of activities. */
    activities: definitions["v1Activity"][];
  };
  v1GetActivityRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given activity object. */
    activityId: string;
  };
  v1GetApiKeyRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given API key. */
    apiKeyId: string;
  };
  v1GetApiKeyResponse: {
    /** @description An API key. */
    apiKey: definitions["v1ApiKey"];
  };
  v1GetApiKeysRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given user. */
    userId?: string;
  };
  v1GetApiKeysResponse: {
    /** @description A list of API keys. */
    apiKeys: definitions["v1ApiKey"][];
  };
  v1GetAttestationDocumentRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description The enclave type, one of: ump, notarizer, signer, evm-parser. */
    enclaveType: string;
  };
  v1GetAttestationDocumentResponse: {
    /**
     * Format: byte
     * @description Raw (CBOR-encoded) attestation document.
     */
    attestationDocument: string;
  };
  v1GetAuthenticatorRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given authenticator. */
    authenticatorId: string;
  };
  v1GetAuthenticatorResponse: {
    /** @description An authenticator. */
    authenticator: definitions["v1Authenticator"];
  };
  v1GetAuthenticatorsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given user. */
    userId: string;
  };
  v1GetAuthenticatorsResponse: {
    /** @description A list of authenticators. */
    authenticators: definitions["v1Authenticator"][];
  };
  v1GetOauthProvidersRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given user. */
    userId?: string;
  };
  v1GetOauthProvidersResponse: {
    /** @description A list of Oauth providers. */
    oauthProviders: definitions["v1OauthProvider"][];
  };
  v1GetOrganizationConfigsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetOrganizationConfigsResponse: {
    /** @description Organization configs including quorum settings and organization features. */
    configs: definitions["v1Config"];
  };
  v1GetOrganizationRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetOrganizationResponse: {
    /** @description Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization. */
    organizationData: definitions["v1OrganizationData"];
  };
  v1GetPoliciesRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetPoliciesResponse: {
    /** @description A list of policies. */
    policies: definitions["v1Policy"][];
  };
  v1GetPolicyEvaluationsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given activity. */
    activityId: string;
  };
  v1GetPolicyEvaluationsResponse: {
    policyEvaluations: definitions["externalactivityv1PolicyEvaluation"][];
  };
  v1GetPolicyRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given policy. */
    policyId: string;
  };
  v1GetPolicyResponse: {
    /** @description Object that codifies rules defining the actions that are permissible within an organization. */
    policy: definitions["v1Policy"];
  };
  v1GetPrivateKeyRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given private key. */
    privateKeyId: string;
  };
  v1GetPrivateKeyResponse: {
    /** @description Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
    privateKey: definitions["v1PrivateKey"];
  };
  v1GetPrivateKeysRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetPrivateKeysResponse: {
    /** @description A list of private keys. */
    privateKeys: definitions["v1PrivateKey"][];
  };
<<<<<<< HEAD
  v1GetSmartContractInterfaceRequest: {
    /** @description Unique identifier for a given organization. */
=======
  v1GetProxyAuthConfigRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetProxyAuthConfigResponse: {
    /** @description Proxy authentication configuration (e.g., allowed origins). */
    proxyAuthConfig: definitions["v1ProxyAuthConfig"];
  };
  v1GetSmartContractInterfaceRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Smart Contract Interface. */
    smartContractInterfaceId: string;
  };
  v1GetSmartContractInterfaceResponse: {
    /** @description Object to be used in conjunction with Policies to guard transaction signing. */
    smartContractInterface: definitions["v1SmartContractInterface"];
  };
  v1GetSmartContractInterfacesRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetSmartContractInterfacesResponse: {
    /** @description A list of Smart Contract Interfaces. */
    smartContractInterfaces: definitions["v1SmartContractInterface"][];
  };
  v1GetSubOrgIdsRequest: {
    /** @description Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
    organizationId: string;
    /** @description Unique identifier for a given smart contract interface. */
    smartContractInterfaceId: string;
  };
  v1GetSmartContractInterfaceResponse: {
    /** @description Object to be used in conjunction with policies to guard transaction signing. */
    smartContractInterface: definitions["externaldatav1SmartContractInterface"];
  };
  v1GetSmartContractInterfacesRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetSmartContractInterfacesResponse: {
    /** @description A list of smart contract interfaces. */
    smartContractInterfaces: definitions["externaldatav1SmartContractInterface"][];
  };
  v1GetSubOrgIdsRequest: {
    /** @description Unique identifier for the parent organization. This is used to find sub-organizations within it. */
    organizationId: string;
    /** @description Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY' */
    filterType?: string;
    /** @description The value of the filter to apply for the specified type. For example, a specific email or name string. */
    filterValue?: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetSubOrgIdsResponse: {
    /** @description List of unique identifiers for the matching sub-organizations. */
    organizationIds: string[];
  };
  v1GetUserRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given user. */
    userId: string;
  };
  v1GetUserResponse: {
    /** @description Web and/or API user within your organization. */
    user: definitions["v1User"];
  };
  v1GetUsersRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetUsersResponse: {
    /** @description A list of users. */
    users: definitions["v1User"][];
  };
  v1GetVerifiedSubOrgIdsRequest: {
    /** @description Unique identifier for the parent organization. This is used to find sub-organizations within it. */
    organizationId: string;
    /** @description Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'. */
    filterType?: string;
    /** @description The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
    filterValue?: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetVerifiedSubOrgIdsResponse: {
    /** @description List of unique identifiers for the matching sub-organizations. */
    organizationIds: string[];
  };
  v1GetWalletAccountRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given wallet. */
    walletId: string;
    /** @description Address corresponding to a wallet account. */
    address?: string;
    /** @description Path corresponding to a wallet account. */
    path?: string;
  };
  v1GetWalletAccountResponse: {
    /** @description The resulting wallet account. */
    account: definitions["v1WalletAccount"];
  };
  v1GetWalletAccountsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned. */
    walletId?: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetWalletAccountsResponse: {
    /** @description A list of accounts generated from a wallet that share a common seed. */
    accounts: definitions["v1WalletAccount"][];
  };
  v1GetWalletRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Unique identifier for a given wallet. */
    walletId: string;
  };
  v1GetWalletResponse: {
    /** @description A collection of deterministically generated cryptographic public / private key pairs that share a common seed. */
    wallet: definitions["v1Wallet"];
  };
  v1GetWalletsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1GetWalletsResponse: {
    /** @description A list of wallets. */
    wallets: definitions["v1Wallet"][];
  };
  v1GetWhoamiRequest: {
    /** @description Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons. */
    organizationId: string;
  };
  v1GetWhoamiResponse: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
    /** @description Human-readable name for an organization. */
    organizationName: string;
    /** @description Unique identifier for a given user. */
    userId: string;
    /** @description Human-readable name for a user. */
    username: string;
  };
  /** @enum {string} */
  v1HashFunction:
    | "HASH_FUNCTION_NO_OP"
    | "HASH_FUNCTION_SHA256"
    | "HASH_FUNCTION_KECCAK256"
    | "HASH_FUNCTION_NOT_APPLICABLE";
  v1ImportPrivateKeyIntent: {
    /** @description The ID of the User importing a Private Key. */
    userId: string;
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Bundle containing a raw private key encrypted to the enclave's target public key. */
    encryptedBundle: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
    addressFormats: definitions["v1AddressFormat"][];
  };
  v1ImportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ImportPrivateKeyIntent"];
  };
  v1ImportPrivateKeyResult: {
    /** @description Unique identifier for a Private Key. */
    privateKeyId: string;
    /** @description A list of addresses. */
    addresses: definitions["immutableactivityv1Address"][];
  };
  v1ImportWalletIntent: {
    /** @description The ID of the User importing a Wallet. */
    userId: string;
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
    encryptedBundle: string;
    /** @description A list of wallet Accounts. */
    accounts: definitions["v1WalletAccountParams"][];
  };
  v1ImportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_IMPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ImportWalletIntent"];
  };
  v1ImportWalletResult: {
    /** @description Unique identifier for a Wallet. */
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1InitFiatOnRampIntent: {
    /** @description Enum to specifiy which on-ramp provider to use */
    onrampProvider: definitions["v1FiatOnRampProvider"];
    /** @description Destination wallet address for the buy transaction. */
    walletAddress: string;
    /** @description Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork. */
    network: definitions["v1FiatOnRampBlockchainNetwork"];
    /** @description Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset. */
    cryptoCurrencyCode: definitions["v1FiatOnRampCryptoCurrency"];
    /** @description Code for the fiat currency to be used in the transaction, e.g., USD, EUR. */
    fiatCurrencyCode?: definitions["v1FiatOnRampCurrency"];
    /** @description Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount. */
    fiatCurrencyAmount?: string;
    /** @description Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider. */
    paymentMethod?: definitions["v1FiatOnRampPaymentMethod"];
    /** @description ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB. */
    countryCode?: string;
    /** @description ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US. */
    countrySubdivisionCode?: string;
    /** @description Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false. */
    sandboxMode?: boolean;
  };
  v1InitFiatOnRampRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitFiatOnRampIntent"];
  };
  v1InitFiatOnRampResult: {
    /** @description Unique URL for a given fiat on-ramp flow. */
    onRampUrl: string;
    /** @description Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow. */
    onRampTransactionId: string;
  };
  v1InitImportPrivateKeyIntent: {
    /** @description The ID of the User importing a Private Key. */
    userId: string;
  };
  v1InitImportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitImportPrivateKeyIntent"];
  };
  v1InitImportPrivateKeyResult: {
    /** @description Import bundle containing a public key and signature to use for importing client data. */
    importBundle: string;
  };
  v1InitImportWalletIntent: {
    /** @description The ID of the User importing a Wallet. */
    userId: string;
  };
  v1InitImportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitImportWalletIntent"];
  };
  v1InitImportWalletResult: {
    /** @description Import bundle containing a public key and signature to use for importing client data. */
    importBundle: string;
  };
  v1InitOtpAuthIntent: {
    /** @description Enum to specifiy whether to send OTP via SMS or email */
    otpType: string;
    /** @description Email or phone number to send the OTP code to */
    contact: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
    smsCustomization?: definitions["v1SmsCustomizationParams"];
    /** @description Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
    userIdentifier?: string;
    /** @description Optional custom email address from which to send the OTP email */
    sendFromEmailAddress?: string;
    /** @description Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
    sendFromEmailSenderName?: string;
    /** @description Optional custom email address to use as reply-to */
    replyToEmailAddress?: string;
  };
  v1InitOtpAuthIntentV2: {
    /** @description Enum to specifiy whether to send OTP via SMS or email */
    otpType: string;
    /** @description Email or phone number to send the OTP code to */
    contact: string;
    /**
     * Format: int32
     * @description Optional length of the OTP code. Default = 9
     */
    otpLength?: number;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
    smsCustomization?: definitions["v1SmsCustomizationParams"];
    /** @description Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
    userIdentifier?: string;
    /** @description Optional custom email address from which to send the OTP email */
    sendFromEmailAddress?: string;
    /** @description Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
    alphanumeric?: boolean;
    /** @description Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
    sendFromEmailSenderName?: string;
    /** @description Optional custom email address to use as reply-to */
    replyToEmailAddress?: string;
  };
  v1InitOtpAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitOtpAuthIntentV2"];
  };
  v1InitOtpAuthResult: {
    /** @description Unique identifier for an OTP authentication */
    otpId: string;
  };
  v1InitOtpAuthResultV2: {
    /** @description Unique identifier for an OTP authentication */
    otpId: string;
  };
  v1InitOtpIntent: {
    /** @description Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
    otpType: string;
    /** @description Email or phone number to send the OTP code to */
    contact: string;
    /**
     * Format: int32
     * @description Optional length of the OTP code. Default = 9
     */
    otpLength?: number;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
    smsCustomization?: definitions["v1SmsCustomizationParams"];
    /** @description Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
    userIdentifier?: string;
    /** @description Optional custom email address from which to send the OTP email */
    sendFromEmailAddress?: string;
    /** @description Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
    alphanumeric?: boolean;
    /** @description Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
    sendFromEmailSenderName?: string;
    /** @description Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
    expirationSeconds?: string;
    /** @description Optional custom email address to use as reply-to */
    replyToEmailAddress?: string;
  };
  v1InitOtpRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_OTP";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitOtpIntent"];
  };
  v1InitOtpResult: {
    /** @description Unique identifier for an OTP authentication */
    otpId: string;
  };
  v1InitUserEmailRecoveryIntent: {
    /** @description Email of the user starting recovery */
    email: string;
    /** @description Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
    targetPublicKey: string;
    /** @description Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
  };
  v1InitUserEmailRecoveryRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitUserEmailRecoveryIntent"];
  };
  v1InitUserEmailRecoveryResult: {
    /** @description Unique identifier for the user being recovered. */
    userId: string;
  };
  v1Intent: {
    createOrganizationIntent?: definitions["v1CreateOrganizationIntent"];
    createAuthenticatorsIntent?: definitions["v1CreateAuthenticatorsIntent"];
    createUsersIntent?: definitions["v1CreateUsersIntent"];
    createPrivateKeysIntent?: definitions["v1CreatePrivateKeysIntent"];
    signRawPayloadIntent?: definitions["v1SignRawPayloadIntent"];
    createInvitationsIntent?: definitions["v1CreateInvitationsIntent"];
    acceptInvitationIntent?: definitions["v1AcceptInvitationIntent"];
    createPolicyIntent?: definitions["v1CreatePolicyIntent"];
    disablePrivateKeyIntent?: definitions["v1DisablePrivateKeyIntent"];
    deleteUsersIntent?: definitions["v1DeleteUsersIntent"];
    deleteAuthenticatorsIntent?: definitions["v1DeleteAuthenticatorsIntent"];
    deleteInvitationIntent?: definitions["v1DeleteInvitationIntent"];
    deleteOrganizationIntent?: definitions["v1DeleteOrganizationIntent"];
    deletePolicyIntent?: definitions["v1DeletePolicyIntent"];
    createUserTagIntent?: definitions["v1CreateUserTagIntent"];
    deleteUserTagsIntent?: definitions["v1DeleteUserTagsIntent"];
    signTransactionIntent?: definitions["v1SignTransactionIntent"];
    createApiKeysIntent?: definitions["v1CreateApiKeysIntent"];
    deleteApiKeysIntent?: definitions["v1DeleteApiKeysIntent"];
    approveActivityIntent?: definitions["v1ApproveActivityIntent"];
    rejectActivityIntent?: definitions["v1RejectActivityIntent"];
    createPrivateKeyTagIntent?: definitions["v1CreatePrivateKeyTagIntent"];
    deletePrivateKeyTagsIntent?: definitions["v1DeletePrivateKeyTagsIntent"];
    createPolicyIntentV2?: definitions["v1CreatePolicyIntentV2"];
    setPaymentMethodIntent?: definitions["billingSetPaymentMethodIntent"];
    activateBillingTierIntent?: definitions["billingActivateBillingTierIntent"];
    deletePaymentMethodIntent?: definitions["billingDeletePaymentMethodIntent"];
    createPolicyIntentV3?: definitions["v1CreatePolicyIntentV3"];
    createApiOnlyUsersIntent?: definitions["v1CreateApiOnlyUsersIntent"];
    updateRootQuorumIntent?: definitions["v1UpdateRootQuorumIntent"];
    updateUserTagIntent?: definitions["v1UpdateUserTagIntent"];
    updatePrivateKeyTagIntent?: definitions["v1UpdatePrivateKeyTagIntent"];
    createAuthenticatorsIntentV2?: definitions["v1CreateAuthenticatorsIntentV2"];
    acceptInvitationIntentV2?: definitions["v1AcceptInvitationIntentV2"];
    createOrganizationIntentV2?: definitions["v1CreateOrganizationIntentV2"];
    createUsersIntentV2?: definitions["v1CreateUsersIntentV2"];
    createSubOrganizationIntent?: definitions["v1CreateSubOrganizationIntent"];
    createSubOrganizationIntentV2?: definitions["v1CreateSubOrganizationIntentV2"];
    updateAllowedOriginsIntent?: definitions["v1UpdateAllowedOriginsIntent"];
    createPrivateKeysIntentV2?: definitions["v1CreatePrivateKeysIntentV2"];
    updateUserIntent?: definitions["v1UpdateUserIntent"];
    updatePolicyIntent?: definitions["v1UpdatePolicyIntent"];
    setPaymentMethodIntentV2?: definitions["billingSetPaymentMethodIntentV2"];
    createSubOrganizationIntentV3?: definitions["v1CreateSubOrganizationIntentV3"];
    createWalletIntent?: definitions["v1CreateWalletIntent"];
    createWalletAccountsIntent?: definitions["v1CreateWalletAccountsIntent"];
    initUserEmailRecoveryIntent?: definitions["v1InitUserEmailRecoveryIntent"];
    recoverUserIntent?: definitions["v1RecoverUserIntent"];
    setOrganizationFeatureIntent?: definitions["v1SetOrganizationFeatureIntent"];
    removeOrganizationFeatureIntent?: definitions["v1RemoveOrganizationFeatureIntent"];
    signRawPayloadIntentV2?: definitions["v1SignRawPayloadIntentV2"];
    signTransactionIntentV2?: definitions["v1SignTransactionIntentV2"];
    exportPrivateKeyIntent?: definitions["v1ExportPrivateKeyIntent"];
    exportWalletIntent?: definitions["v1ExportWalletIntent"];
    createSubOrganizationIntentV4?: definitions["v1CreateSubOrganizationIntentV4"];
    emailAuthIntent?: definitions["v1EmailAuthIntent"];
    exportWalletAccountIntent?: definitions["v1ExportWalletAccountIntent"];
    initImportWalletIntent?: definitions["v1InitImportWalletIntent"];
    importWalletIntent?: definitions["v1ImportWalletIntent"];
    initImportPrivateKeyIntent?: definitions["v1InitImportPrivateKeyIntent"];
    importPrivateKeyIntent?: definitions["v1ImportPrivateKeyIntent"];
    createPoliciesIntent?: definitions["v1CreatePoliciesIntent"];
    signRawPayloadsIntent?: definitions["v1SignRawPayloadsIntent"];
    createReadOnlySessionIntent?: definitions["v1CreateReadOnlySessionIntent"];
    createOauthProvidersIntent?: definitions["v1CreateOauthProvidersIntent"];
    deleteOauthProvidersIntent?: definitions["v1DeleteOauthProvidersIntent"];
    createSubOrganizationIntentV5?: definitions["v1CreateSubOrganizationIntentV5"];
    oauthIntent?: definitions["v1OauthIntent"];
    createApiKeysIntentV2?: definitions["v1CreateApiKeysIntentV2"];
    createReadWriteSessionIntent?: definitions["v1CreateReadWriteSessionIntent"];
    emailAuthIntentV2?: definitions["v1EmailAuthIntentV2"];
    createSubOrganizationIntentV6?: definitions["v1CreateSubOrganizationIntentV6"];
    deletePrivateKeysIntent?: definitions["v1DeletePrivateKeysIntent"];
    deleteWalletsIntent?: definitions["v1DeleteWalletsIntent"];
    createReadWriteSessionIntentV2?: definitions["v1CreateReadWriteSessionIntentV2"];
    deleteSubOrganizationIntent?: definitions["v1DeleteSubOrganizationIntent"];
    initOtpAuthIntent?: definitions["v1InitOtpAuthIntent"];
    otpAuthIntent?: definitions["v1OtpAuthIntent"];
    createSubOrganizationIntentV7?: definitions["v1CreateSubOrganizationIntentV7"];
    updateWalletIntent?: definitions["v1UpdateWalletIntent"];
    updatePolicyIntentV2?: definitions["v1UpdatePolicyIntentV2"];
    createUsersIntentV3?: definitions["v1CreateUsersIntentV3"];
    initOtpAuthIntentV2?: definitions["v1InitOtpAuthIntentV2"];
    initOtpIntent?: definitions["v1InitOtpIntent"];
    verifyOtpIntent?: definitions["v1VerifyOtpIntent"];
    otpLoginIntent?: definitions["v1OtpLoginIntent"];
    stampLoginIntent?: definitions["v1StampLoginIntent"];
    oauthLoginIntent?: definitions["v1OauthLoginIntent"];
    updateUserNameIntent?: definitions["v1UpdateUserNameIntent"];
    updateUserEmailIntent?: definitions["v1UpdateUserEmailIntent"];
    updateUserPhoneNumberIntent?: definitions["v1UpdateUserPhoneNumberIntent"];
    initFiatOnRampIntent?: definitions["v1InitFiatOnRampIntent"];
<<<<<<< HEAD
<<<<<<< HEAD
    createSmartContractInterfaceIntent?: definitions["v1CreateSmartContractInterfaceIntent"];
    deleteSmartContractInterfaceIntent?: definitions["v1DeleteSmartContractInterfaceIntent"];
=======
=======
    createSmartContractInterfaceIntent?: definitions["v1CreateSmartContractInterfaceIntent"];
    deleteSmartContractInterfaceIntent?: definitions["v1DeleteSmartContractInterfaceIntent"];
>>>>>>> 57ef158e (updated auth proxy type generation)
    enableUserInitiatedAuthIntent?: definitions["v1EnableUserInitiatedAuthIntent"];
    disableUserInitiatedAuthIntent?: definitions["v1DisableUserInitiatedAuthIntent"];
    updateProxyAuthConfigIntent?: definitions["v1UpdateProxyAuthConfigIntent"];
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  };
  v1Invitation: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description The name of the intended Invitation recipient. */
    receiverUserName: string;
    /** @description The email address of the intended Invitation recipient. */
    receiverEmail: string;
    /** @description A list of tags assigned to the Invitation recipient. */
    receiverUserTags: string[];
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description The current processing status of a specified Invitation. */
    status: definitions["v1InvitationStatus"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Unique identifier for the Sender of an Invitation. */
    senderUserId: string;
  };
  v1InvitationParams: {
    /** @description The name of the intended Invitation recipient. */
    receiverUserName: string;
    /** @description The email address of the intended Invitation recipient. */
    receiverUserEmail: string;
    /** @description A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
    receiverUserTags: string[];
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description Unique identifier for the Sender of an Invitation. */
    senderUserId: string;
  };
  /** @enum {string} */
  v1InvitationStatus:
    | "INVITATION_STATUS_CREATED"
    | "INVITATION_STATUS_ACCEPTED"
    | "INVITATION_STATUS_REVOKED";
  v1ListPrivateKeyTagsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1ListPrivateKeyTagsResponse: {
    /** @description A list of private key tags. */
    privateKeyTags: definitions["datav1Tag"][];
  };
  v1ListUserTagsRequest: {
    /** @description Unique identifier for a given organization. */
    organizationId: string;
  };
  v1ListUserTagsResponse: {
    /** @description A list of user tags. */
    userTags: definitions["datav1Tag"][];
  };
  /** @enum {string} */
  v1MnemonicLanguage:
    | "MNEMONIC_LANGUAGE_ENGLISH"
    | "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
    | "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
    | "MNEMONIC_LANGUAGE_CZECH"
    | "MNEMONIC_LANGUAGE_FRENCH"
    | "MNEMONIC_LANGUAGE_ITALIAN"
    | "MNEMONIC_LANGUAGE_JAPANESE"
    | "MNEMONIC_LANGUAGE_KOREAN"
    | "MNEMONIC_LANGUAGE_SPANISH";
  v1NOOPCodegenAnchorResponse: {
    stamp: definitions["v1WebAuthnStamp"];
  };
  v1OauthIntent: {
    /** @description Base64 encoded OIDC token */
    oidcToken: string;
    /** @description Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated Oauth API keys */
    invalidateExisting?: boolean;
  };
  v1OauthLoginIntent: {
    /** @description Base64 encoded OIDC token */
    oidcToken: string;
    /** @description Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
    publicKey: string;
    /** @description Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated Login API keys */
    invalidateExisting?: boolean;
  };
  v1OauthLoginRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OAUTH_LOGIN";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OauthLoginIntent"];
  };
  v1OauthLoginResult: {
    /** @description Signed JWT containing an expiry, public key, session type, user id, and organization id */
    session: string;
  };
  v1OauthProvider: {
    /** @description Unique identifier for an OAuth Provider */
    providerId: string;
    /** @description Human-readable name to identify a Provider. */
    providerName: string;
    /** @description The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
    issuer: string;
    /** @description Expected audience ('aud' attribute of the signed token) which represents the app ID */
    audience: string;
    /** @description Expected subject ('sub' attribute of the signed token) which represents the user ID */
    subject: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1OauthProviderParams: {
    /** @description Human-readable name to identify a Provider. */
    providerName: string;
    /** @description Base64 encoded OIDC token */
    oidcToken: string;
  };
  v1OauthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OAUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OauthIntent"];
  };
  v1OauthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  /** @enum {string} */
  v1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL"
    | "OPERATOR_IN"
    | "OPERATOR_NOT_IN"
    | "OPERATOR_CONTAINS_ONE"
    | "OPERATOR_CONTAINS_ALL";
  v1OrganizationData: {
    organizationId?: string;
    name?: string;
    users?: definitions["v1User"][];
    policies?: definitions["v1Policy"][];
    privateKeys?: definitions["v1PrivateKey"][];
    invitations?: definitions["v1Invitation"][];
    tags?: definitions["datav1Tag"][];
    rootQuorum?: definitions["externaldatav1Quorum"];
    features?: definitions["v1Feature"][];
    wallets?: definitions["v1Wallet"][];
    smartContractInterfaceReferences?: definitions["v1SmartContractInterfaceReference"][];
  };
  v1OtpAuthIntent: {
    /** @description ID representing the result of an init OTP activity. */
    otpId: string;
    /** @description OTP sent out to a user's contact (email or SMS) */
    otpCode: string;
    /** @description Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated OTP Auth API keys */
    invalidateExisting?: boolean;
  };
  v1OtpAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OTP_AUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OtpAuthIntent"];
  };
  v1OtpAuthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId?: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle?: string;
  };
  v1OtpLoginIntent: {
    /** @description Signed JWT containing a unique id, expiry, verification type, contact */
    verificationToken: string;
    /** @description Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
    publicKey: string;
    /** @description Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated Login API keys */
    invalidateExisting?: boolean;
  };
  v1OtpLoginRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OTP_LOGIN";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OtpLoginIntent"];
  };
  v1OtpLoginResult: {
    /** @description Signed JWT containing an expiry, public key, session type, user id, and organization id */
    session: string;
  };
  /** @enum {string} */
  v1Outcome:
    | "OUTCOME_ALLOW"
    | "OUTCOME_DENY_EXPLICIT"
    | "OUTCOME_DENY_IMPLICIT"
    | "OUTCOME_REQUIRES_CONSENSUS"
    | "OUTCOME_REJECTED"
    | "OUTCOME_ERROR";
  v1Pagination: {
    /** @description A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
    limit?: string;
    /** @description A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
    before?: string;
    /** @description A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
    after?: string;
  };
  /** @enum {string} */
  v1PathFormat: "PATH_FORMAT_BIP32";
  /** @enum {string} */
  v1PayloadEncoding:
    | "PAYLOAD_ENCODING_HEXADECIMAL"
    | "PAYLOAD_ENCODING_TEXT_UTF8"
    | "PAYLOAD_ENCODING_EIP712";
  v1Policy: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description The instruction to DENY or ALLOW a particular activity following policy selector(s). */
    effect: definitions["v1Effect"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Human-readable notes added by a User to describe a particular policy. */
    notes: string;
    /** @description A consensus expression that evalutes to true or false. */
    consensus: string;
    /** @description A condition expression that evalutes to true or false. */
    condition: string;
  };
  v1PrivateKey: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description Derived cryptocurrency addresses for a given Private Key. */
    addresses: definitions["externaldatav1Address"][];
    /** @description A list of Private Key Tag IDs. */
    privateKeyTags: string[];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description True when a given Private Key is exported, false otherwise. */
    exported: boolean;
    /** @description True when a given Private Key is imported, false otherwise. */
    imported: boolean;
  };
  v1PrivateKeyParams: {
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
    privateKeyTags: string[];
    /** @description Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
    addressFormats: definitions["v1AddressFormat"][];
  };
  v1PrivateKeyResult: {
    privateKeyId?: string;
    addresses?: definitions["immutableactivityv1Address"][];
  };
  v1ProxyAuthConfig: {
    organizationId?: string;
    allowedOrigins?: string[];
    allowedAuthMethods?: string[];
    encryptedApiKey?: string;
    turnkeySignerUserId?: string;
    sendFromEmailAddress?: string;
    replyToEmailAddress?: string;
    emailAuthTemplateId?: string;
    otpTemplateId?: string;
    emailCustomizationParams?: string;
    smsCustomizationParams?: string;
    /** Format: int32 */
    otpExpirationSeconds?: number;
    /** Format: int32 */
    verificationTokenExpirationSeconds?: number;
    /** Format: int32 */
    otpSessionExpirationSeconds?: number;
    /** Format: int32 */
    oauthSessionExpirationSeconds?: number;
    /** Format: int32 */
    passkeySessionExpirationSeconds?: number;
    /** Format: int32 */
    walletSessionExpirationSeconds?: number;
    /** Format: date-time */
    createdAt?: string;
    /** Format: date-time */
    updatedAt?: string;
    otpAlphanumeric?: boolean;
    /** Format: int32 */
    otpLength?: number;
    socialLinking?: boolean;
    policyId?: string;
    proxyId?: string;
    ewkSettings?: string;
  };
  v1PublicKeyCredentialWithAttestation: {
    id: string;
    /** @enum {string} */
    type: "public-key";
    rawId: string;
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
    response: definitions["v1AuthenticatorAttestationResponse"];
    clientExtensionResults: definitions["v1SimpleClientExtensionResults"];
  };
  v1RecoverUserIntent: {
    /** @description The new authenticator to register. */
    authenticator: definitions["v1AuthenticatorParamsV2"];
    /** @description Unique identifier for the user performing recovery. */
    userId: string;
  };
  v1RecoverUserRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_RECOVER_USER";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RecoverUserIntent"];
  };
  v1RecoverUserResult: {
    /** @description ID of the authenticator created. */
    authenticatorId: string[];
  };
  v1RejectActivityIntent: {
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
  };
  v1RejectActivityRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REJECT_ACTIVITY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RejectActivityIntent"];
  };
  v1RemoveOrganizationFeatureIntent: {
    /** @description Name of the feature to remove */
    name: definitions["v1FeatureName"];
  };
  v1RemoveOrganizationFeatureRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RemoveOrganizationFeatureIntent"];
  };
  v1RemoveOrganizationFeatureResult: {
    /** @description Resulting list of organization features. */
    features: definitions["v1Feature"][];
  };
  v1Result: {
    createOrganizationResult?: definitions["v1CreateOrganizationResult"];
    createAuthenticatorsResult?: definitions["v1CreateAuthenticatorsResult"];
    createUsersResult?: definitions["v1CreateUsersResult"];
    createPrivateKeysResult?: definitions["v1CreatePrivateKeysResult"];
    createInvitationsResult?: definitions["v1CreateInvitationsResult"];
    acceptInvitationResult?: definitions["v1AcceptInvitationResult"];
    signRawPayloadResult?: definitions["v1SignRawPayloadResult"];
    createPolicyResult?: definitions["v1CreatePolicyResult"];
    disablePrivateKeyResult?: definitions["v1DisablePrivateKeyResult"];
    deleteUsersResult?: definitions["v1DeleteUsersResult"];
    deleteAuthenticatorsResult?: definitions["v1DeleteAuthenticatorsResult"];
    deleteInvitationResult?: definitions["v1DeleteInvitationResult"];
    deleteOrganizationResult?: definitions["v1DeleteOrganizationResult"];
    deletePolicyResult?: definitions["v1DeletePolicyResult"];
    createUserTagResult?: definitions["v1CreateUserTagResult"];
    deleteUserTagsResult?: definitions["v1DeleteUserTagsResult"];
    signTransactionResult?: definitions["v1SignTransactionResult"];
    deleteApiKeysResult?: definitions["v1DeleteApiKeysResult"];
    createApiKeysResult?: definitions["v1CreateApiKeysResult"];
    createPrivateKeyTagResult?: definitions["v1CreatePrivateKeyTagResult"];
    deletePrivateKeyTagsResult?: definitions["v1DeletePrivateKeyTagsResult"];
    setPaymentMethodResult?: definitions["billingSetPaymentMethodResult"];
    activateBillingTierResult?: definitions["billingActivateBillingTierResult"];
    deletePaymentMethodResult?: definitions["billingDeletePaymentMethodResult"];
    createApiOnlyUsersResult?: definitions["v1CreateApiOnlyUsersResult"];
    updateRootQuorumResult?: definitions["v1UpdateRootQuorumResult"];
    updateUserTagResult?: definitions["v1UpdateUserTagResult"];
    updatePrivateKeyTagResult?: definitions["v1UpdatePrivateKeyTagResult"];
    createSubOrganizationResult?: definitions["v1CreateSubOrganizationResult"];
    updateAllowedOriginsResult?: definitions["v1UpdateAllowedOriginsResult"];
    createPrivateKeysResultV2?: definitions["v1CreatePrivateKeysResultV2"];
    updateUserResult?: definitions["v1UpdateUserResult"];
    updatePolicyResult?: definitions["v1UpdatePolicyResult"];
    createSubOrganizationResultV3?: definitions["v1CreateSubOrganizationResultV3"];
    createWalletResult?: definitions["v1CreateWalletResult"];
    createWalletAccountsResult?: definitions["v1CreateWalletAccountsResult"];
    initUserEmailRecoveryResult?: definitions["v1InitUserEmailRecoveryResult"];
    recoverUserResult?: definitions["v1RecoverUserResult"];
    setOrganizationFeatureResult?: definitions["v1SetOrganizationFeatureResult"];
    removeOrganizationFeatureResult?: definitions["v1RemoveOrganizationFeatureResult"];
    exportPrivateKeyResult?: definitions["v1ExportPrivateKeyResult"];
    exportWalletResult?: definitions["v1ExportWalletResult"];
    createSubOrganizationResultV4?: definitions["v1CreateSubOrganizationResultV4"];
    emailAuthResult?: definitions["v1EmailAuthResult"];
    exportWalletAccountResult?: definitions["v1ExportWalletAccountResult"];
    initImportWalletResult?: definitions["v1InitImportWalletResult"];
    importWalletResult?: definitions["v1ImportWalletResult"];
    initImportPrivateKeyResult?: definitions["v1InitImportPrivateKeyResult"];
    importPrivateKeyResult?: definitions["v1ImportPrivateKeyResult"];
    createPoliciesResult?: definitions["v1CreatePoliciesResult"];
    signRawPayloadsResult?: definitions["v1SignRawPayloadsResult"];
    createReadOnlySessionResult?: definitions["v1CreateReadOnlySessionResult"];
    createOauthProvidersResult?: definitions["v1CreateOauthProvidersResult"];
    deleteOauthProvidersResult?: definitions["v1DeleteOauthProvidersResult"];
    createSubOrganizationResultV5?: definitions["v1CreateSubOrganizationResultV5"];
    oauthResult?: definitions["v1OauthResult"];
    createReadWriteSessionResult?: definitions["v1CreateReadWriteSessionResult"];
    createSubOrganizationResultV6?: definitions["v1CreateSubOrganizationResultV6"];
    deletePrivateKeysResult?: definitions["v1DeletePrivateKeysResult"];
    deleteWalletsResult?: definitions["v1DeleteWalletsResult"];
    createReadWriteSessionResultV2?: definitions["v1CreateReadWriteSessionResultV2"];
    deleteSubOrganizationResult?: definitions["v1DeleteSubOrganizationResult"];
    initOtpAuthResult?: definitions["v1InitOtpAuthResult"];
    otpAuthResult?: definitions["v1OtpAuthResult"];
    createSubOrganizationResultV7?: definitions["v1CreateSubOrganizationResultV7"];
    updateWalletResult?: definitions["v1UpdateWalletResult"];
    updatePolicyResultV2?: definitions["v1UpdatePolicyResultV2"];
    initOtpAuthResultV2?: definitions["v1InitOtpAuthResultV2"];
    initOtpResult?: definitions["v1InitOtpResult"];
    verifyOtpResult?: definitions["v1VerifyOtpResult"];
    otpLoginResult?: definitions["v1OtpLoginResult"];
    stampLoginResult?: definitions["v1StampLoginResult"];
    oauthLoginResult?: definitions["v1OauthLoginResult"];
    updateUserNameResult?: definitions["v1UpdateUserNameResult"];
    updateUserEmailResult?: definitions["v1UpdateUserEmailResult"];
    updateUserPhoneNumberResult?: definitions["v1UpdateUserPhoneNumberResult"];
    initFiatOnRampResult?: definitions["v1InitFiatOnRampResult"];
<<<<<<< HEAD
<<<<<<< HEAD
    createSmartContractInterfaceResult?: definitions["v1CreateSmartContractInterfaceResult"];
    deleteSmartContractInterfaceResult?: definitions["v1DeleteSmartContractInterfaceResult"];
=======
=======
    createSmartContractInterfaceResult?: definitions["v1CreateSmartContractInterfaceResult"];
    deleteSmartContractInterfaceResult?: definitions["v1DeleteSmartContractInterfaceResult"];
>>>>>>> 57ef158e (updated auth proxy type generation)
    enableUserInitiatedAuthResult?: definitions["v1EnableUserInitiatedAuthResult"];
    disableUserInitiatedAuthResult?: definitions["v1DisableUserInitiatedAuthResult"];
    updateProxyAuthConfigResult?: definitions["v1UpdateProxyAuthConfigResult"];
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  };
  v1RootUserParams: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
  };
  v1RootUserParamsV2: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1RootUserParamsV3: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1RootUserParamsV4: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1Selector: {
    subject?: string;
    operator?: definitions["v1Operator"];
    target?: string;
  };
  v1SelectorV2: {
    subject?: string;
    operator?: definitions["v1Operator"];
    targets?: string[];
  };
  v1SetOrganizationFeatureIntent: {
    /** @description Name of the feature to set */
    name: definitions["v1FeatureName"];
    /** @description Optional value for the feature. Will override existing values if feature is already set. */
    value: string;
  };
  v1SetOrganizationFeatureRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SetOrganizationFeatureIntent"];
  };
  v1SetOrganizationFeatureResult: {
    /** @description Resulting list of organization features. */
    features: definitions["v1Feature"][];
  };
  v1SignRawPayloadIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Raw unsigned payload to be signed. */
    payload: string;
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadIntentV2: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description Raw unsigned payload to be signed. */
    payload: string;
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignRawPayloadIntentV2"];
  };
  v1SignRawPayloadResult: {
    /** @description Component of an ECSDA signature. */
    r: string;
    /** @description Component of an ECSDA signature. */
    s: string;
    /** @description Component of an ECSDA signature. */
    v: string;
  };
  v1SignRawPayloadsIntent: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description An array of raw unsigned payloads to be signed. */
    payloads: string[];
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignRawPayloadsIntent"];
  };
  v1SignRawPayloadsResult: {
    signatures?: definitions["v1SignRawPayloadResult"][];
  };
  v1SignTransactionIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Raw unsigned transaction to be signed by a particular Private Key. */
    unsignedTransaction: string;
    type: definitions["v1TransactionType"];
  };
  v1SignTransactionIntentV2: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description Raw unsigned transaction to be signed */
    unsignedTransaction: string;
    type: definitions["v1TransactionType"];
  };
  v1SignTransactionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignTransactionIntentV2"];
  };
  v1SignTransactionResult: {
    signedTransaction: string;
  };
  v1SimpleClientExtensionResults: {
    appid?: boolean;
    appidExclude?: boolean;
    credProps?: definitions["v1CredPropsAuthenticationExtensionsClientOutputs"];
  };
<<<<<<< HEAD
  v1SmartContractInterfaceReference: {
    smartContractInterfaceId?: string;
    smartContractAddress?: string;
    digest?: string;
=======
  v1SmartContractInterface: {
    /** @description The Organization the Smart Contract Interface belongs to. */
    organizationId: string;
    /** @description Unique identifier for a given Smart Contract Interface (ABI or IDL). */
    smartContractInterfaceId: string;
    /** @description The address corresponding to the Smart Contract or Program. */
    smartContractAddress: string;
    /** @description The JSON corresponding to the Smart Contract Interface (ABI or IDL). */
    smartContractInterface: string;
    /** @description The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    type: string;
    /** @description The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    label: string;
    /** @description The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
    notes: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
>>>>>>> 57ef158e (updated auth proxy type generation)
  };
  v1SmartContractInterfaceReference: {
    smartContractInterfaceId?: string;
    smartContractAddress?: string;
    digest?: string;
  };
  /** @enum {string} */
  v1SmartContractInterfaceType:
    | "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM"
    | "SMART_CONTRACT_INTERFACE_TYPE_SOLANA";
  v1SmsCustomizationParams: {
    /** @description Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
    template?: string;
  };
  v1StampLoginIntent: {
    /** @description Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
    publicKey: string;
    /** @description Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated Login API keys */
    invalidateExisting?: boolean;
  };
  v1StampLoginRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_STAMP_LOGIN";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1StampLoginIntent"];
  };
  v1StampLoginResult: {
    /** @description Signed JWT containing an expiry, public key, session type, user id, and organization id */
    session: string;
  };
  /** @enum {string} */
  v1TagType: "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";
  v1TestRateLimitsRequest: {
    /** @description Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons. */
    organizationId: string;
    /** @description Whether or not to set a limit on this request. */
    isSetLimit: boolean;
    /**
     * Format: int64
     * @description Rate limit to set for org, if is_set_limit is set to true.
     */
    limit: number;
  };
  v1TestRateLimitsResponse: { [key: string]: unknown };
  /** @enum {string} */
  v1TransactionType:
    | "TRANSACTION_TYPE_ETHEREUM"
    | "TRANSACTION_TYPE_SOLANA"
    | "TRANSACTION_TYPE_TRON";
  v1UpdateAllowedOriginsIntent: {
    /** @description Additional origins requests are allowed from besides Turnkey origins */
    allowedOrigins: string[];
  };
  v1UpdateAllowedOriginsResult: { [key: string]: unknown };
  v1UpdatePolicyIntent: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName?: string;
    /** @description The instruction to DENY or ALLOW an activity (optional). */
    policyEffect?: definitions["v1Effect"];
    /** @description The condition expression that triggers the Effect (optional). */
    policyCondition?: string;
    /** @description The consensus expression that triggers the Effect (optional). */
    policyConsensus?: string;
    /** @description Accompanying notes for a Policy (optional). */
    policyNotes?: string;
  };
  v1UpdatePolicyIntentV2: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName?: string;
    /** @description The instruction to DENY or ALLOW an activity (optional). */
    policyEffect?: definitions["v1Effect"];
    /** @description The condition expression that triggers the Effect (optional). */
    policyCondition?: string;
    /** @description The consensus expression that triggers the Effect (optional). */
    policyConsensus?: string;
    /** @description Accompanying notes for a Policy (optional). */
    policyNotes?: string;
  };
  v1UpdatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_POLICY_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdatePolicyIntentV2"];
  };
  v1UpdatePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1UpdatePolicyResultV2: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1UpdatePrivateKeyTagIntent: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
    /** @description The new, human-readable name for the tag with the given ID. */
    newPrivateKeyTagName?: string;
    /** @description A list of Private Keys IDs to add this tag to. */
    addPrivateKeyIds: string[];
    /** @description A list of Private Key IDs to remove this tag from. */
    removePrivateKeyIds: string[];
  };
  v1UpdatePrivateKeyTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdatePrivateKeyTagIntent"];
  };
  v1UpdatePrivateKeyTagResult: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
  };
  v1UpdateProxyAuthConfigIntent: {
    /** @description Updated list of allowed origins for CORS. */
    allowedOrigins?: string[];
    /** @description Updated list of allowed origins for CORS. */
    allowedAuthMethods?: string[];
    /** @description Custom 'from' address for auth-related emails. */
    sendFromEmailAddress?: string;
    /** @description Custom reply-to address for auth-related emails. */
    replyToEmailAddress?: string;
    /** @description Template ID for email-auth messages. */
    emailAuthTemplateId?: string;
    /** @description Template ID for OTP SMS messages. */
    otpTemplateId?: string;
    /** @description Overrides for auth-related email content. */
    emailCustomizationParams?: definitions["v1EmailCustomizationParams"];
    /** @description Overrides for auth-related SMS content. */
    smsCustomizationParams?: definitions["v1SmsCustomizationParams"];
    /** @description Overrides for EWK related settings. */
    ewkSettings?: definitions["v1EwkSettingsParams"];
    /**
     * Format: int32
     * @description OTP code lifetime in seconds.
     */
    otpExpirationSeconds?: number;
    /**
     * Format: int32
     * @description Verification-token lifetime in seconds.
     */
    verificationTokenExpirationSeconds?: number;
    /**
     * Format: int32
     * @description OTP session lifetime in seconds.
     */
    otpSessionExpirationSeconds?: number;
    /**
     * Format: int32
     * @description Passkey session lifetime in seconds.
     */
    passkeySessionExpirationSeconds?: number;
    /**
     * Format: int32
     * @description Wallet session lifetime in seconds.
     */
    walletSessionExpirationSeconds?: number;
    /**
     * Format: int32
     * @description OAuth session lifetime in seconds.
     */
    oauthSessionExpirationSeconds?: number;
    /** @description Enable alphanumeric OTP codes. */
    otpAlphanumeric?: boolean;
    /**
     * Format: int32
     * @description Desired OTP code length (69).
     */
    otpLength?: number;
    /** @description Enable social linking (userEmail <-> gmail) */
    socialLinking?: boolean;
  };
  v1UpdateProxyAuthConfigRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_PROXY_AUTH_CONFIG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateProxyAuthConfigIntent"];
  };
  v1UpdateProxyAuthConfigResult: { [key: string]: unknown };
  v1UpdateRootQuorumIntent: {
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach quorum.
     */
    threshold: number;
    /** @description The unique identifiers of users who comprise the quorum set. */
    userIds: string[];
  };
  v1UpdateRootQuorumRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateRootQuorumIntent"];
  };
  v1UpdateRootQuorumResult: { [key: string]: unknown };
  v1UpdateUserEmailIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description The user's email address. Setting this to an empty string will remove the user's email. */
    userEmail: string;
    /** @description Signed JWT containing a unique id, expiry, verification type, contact */
    verificationToken?: string;
  };
  v1UpdateUserEmailRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER_EMAIL";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserEmailIntent"];
  };
  v1UpdateUserEmailResult: {
    /** @description Unique identifier of the User whose email was updated. */
    userId: string;
  };
  v1UpdateUserIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName?: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
    userTagIds?: string[];
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
  };
  v1UpdateUserNameIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName: string;
  };
  v1UpdateUserNameRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER_NAME";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserNameIntent"];
  };
  v1UpdateUserNameResult: {
    /** @description Unique identifier of the User whose name was updated. */
    userId: string;
  };
  v1UpdateUserPhoneNumberIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number. */
    userPhoneNumber: string;
    /** @description Signed JWT containing a unique id, expiry, verification type, contact */
    verificationToken?: string;
  };
  v1UpdateUserPhoneNumberRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserPhoneNumberIntent"];
  };
  v1UpdateUserPhoneNumberResult: {
    /** @description Unique identifier of the User whose phone number was updated. */
    userId: string;
  };
  v1UpdateUserRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserIntent"];
  };
  v1UpdateUserResult: {
    /** @description A User ID. */
    userId: string;
  };
  v1UpdateUserTagIntent: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
    /** @description The new, human-readable name for the tag with the given ID. */
    newUserTagName?: string;
    /** @description A list of User IDs to add this tag to. */
    addUserIds: string[];
    /** @description A list of User IDs to remove this tag from. */
    removeUserIds: string[];
  };
  v1UpdateUserTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserTagIntent"];
  };
  v1UpdateUserTagResult: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
  };
  v1UpdateWalletIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Human-readable name for a Wallet. */
    walletName?: string;
  };
  v1UpdateWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateWalletIntent"];
  };
  v1UpdateWalletResult: {
    /** @description A Wallet ID. */
    walletId: string;
  };
  v1User: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
    /** @description A list of Authenticator parameters. */
    authenticators: definitions["v1Authenticator"][];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKey"][];
    /** @description A list of User Tag IDs. */
    userTags: string[];
    /** @description A list of Oauth Providers. */
    oauthProviders: definitions["v1OauthProvider"][];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1UserParams: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @description A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
  };
  v1UserParamsV2: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
  };
  v1UserParamsV3: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
    /** @description A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
  };
  v1VerifyOtpIntent: {
    /** @description ID representing the result of an init OTP activity. */
    otpId: string;
    /** @description OTP sent out to a user's contact (email or SMS) */
    otpCode: string;
    /** @description Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
    expirationSeconds?: string;
  };
  v1VerifyOtpRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_VERIFY_OTP";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1VerifyOtpIntent"];
  };
  v1VerifyOtpResult: {
    /** @description Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
    verificationToken: string;
  };
  v1Vote: {
    /** @description Unique identifier for a given Vote object. */
    id: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Web and/or API user within your Organization. */
    user: definitions["v1User"];
    /** @description Unique identifier for a given Activity object. */
    activityId: string;
    /** @enum {string} */
    selection: "VOTE_SELECTION_APPROVED" | "VOTE_SELECTION_REJECTED";
    /** @description The raw message being signed within a Vote. */
    message: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description The signature applied to a particular vote. */
    signature: string;
    /** @description Method used to produce a signature. */
    scheme: string;
    createdAt: definitions["externaldatav1Timestamp"];
  };
  v1Wallet: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description True when a given Wallet is exported, false otherwise. */
    exported: boolean;
    /** @description True when a given Wallet is imported, false otherwise. */
    imported: boolean;
  };
  v1WalletAccount: {
    /** @description Unique identifier for a given Wallet Account. */
    walletAccountId: string;
    /** @description The Organization the Account belongs to. */
    organizationId: string;
    /** @description The Wallet the Account was derived from. */
    walletId: string;
    /** @description Cryptographic curve used to generate the Account. */
    curve: definitions["v1Curve"];
    /** @description Path format used to generate the Account. */
    pathFormat: definitions["v1PathFormat"];
    /** @description Path used to generate the Account. */
    path: string;
    /** @description Address format used to generate the Account. */
    addressFormat: definitions["v1AddressFormat"];
    /** @description Address generated using the Wallet seed and Account parameters. */
    address: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description The public component of this wallet account's underlying cryptographic key pair. */
    publicKey?: string;
  };
  v1WalletAccountParams: {
    /** @description Cryptographic curve used to generate a wallet Account. */
    curve: definitions["v1Curve"];
    /** @description Path format used to generate a wallet Account. */
    pathFormat: definitions["v1PathFormat"];
    /** @description Path used to generate a wallet Account. */
    path: string;
    /** @description Address format used to generate a wallet Acccount. */
    addressFormat: definitions["v1AddressFormat"];
  };
  v1WalletParams: {
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
    accounts: definitions["v1WalletAccountParams"][];
    /**
     * Format: int32
     * @description Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
     */
    mnemonicLength?: number;
  };
  v1WalletResult: {
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1WebAuthnStamp: {
    /** @description A base64 url encoded Unique identifier for a given credential. */
    credentialId: string;
    /** @description A base64 encoded payload containing metadata about the signing context and the challenge. */
    clientDataJson: string;
    /** @description A base64 encoded payload containing metadata about the authenticator. */
    authenticatorData: string;
    /** @description The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
    signature: string;
  };
};

export type operations = {
  /** Get details about an activity. */
  PublicApiService_GetActivity: {
    parameters: {
      body: {
        body: definitions["v1GetActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an API key. */
  PublicApiService_GetApiKey: {
    parameters: {
      body: {
        body: definitions["v1GetApiKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetApiKeyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about API keys for a user. */
  PublicApiService_GetApiKeys: {
    parameters: {
      body: {
        body: definitions["v1GetApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetApiKeysResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get the attestation document corresponding to an enclave. */
  PublicApiService_GetAttestationDocument: {
    parameters: {
      body: {
        body: definitions["v1GetAttestationDocumentRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAttestationDocumentResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an authenticator. */
  PublicApiService_GetAuthenticator: {
    parameters: {
      body: {
        body: definitions["v1GetAuthenticatorRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAuthenticatorResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about authenticators for a user. */
  PublicApiService_GetAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1GetAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAuthenticatorsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about Oauth providers for a user. */
  PublicApiService_GetOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1GetOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOauthProvidersResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an organization. */
  PublicApiService_GetOrganization: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get quorum settings and features for an organization. */
  PublicApiService_GetOrganizationConfigs: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationConfigsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationConfigsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a policy. */
  PublicApiService_GetPolicy: {
    parameters: {
      body: {
        body: definitions["v1GetPolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPolicyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get the policy evaluations for an activity. */
  PublicApiService_GetPolicyEvaluations: {
    parameters: {
      body: {
        body: definitions["v1GetPolicyEvaluationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPolicyEvaluationsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a private key. */
  PublicApiService_GetPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Get details about a smart contract interface. */
  PublicApiService_GetSmartContractInterface: {
    parameters: {
      body: {
        body: definitions["v1GetSmartContractInterfaceRequest"];
=======
  /** Get the proxy-auth configuration (allowed origins, etc.) for an Organization */
  PublicApiService_GetProxyAuthConfig: {
    parameters: {
      body: {
        body: definitions["v1GetProxyAuthConfigRequest"];
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
      };
    };
    responses: {
      /** A successful response. */
      200: {
<<<<<<< HEAD
        schema: definitions["v1GetSmartContractInterfaceResponse"];
=======
        schema: definitions["v1GetProxyAuthConfigResponse"];
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
<<<<<<< HEAD
  /** Get details about a user. */
=======
=======
  /** Get details about a Smart Contract Interface */
  PublicApiService_GetSmartContractInterface: {
    parameters: {
      body: {
        body: definitions["v1GetSmartContractInterfaceRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetSmartContractInterfaceResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
>>>>>>> 57ef158e (updated auth proxy type generation)
  /** Get details about a User */
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  PublicApiService_GetUser: {
    parameters: {
      body: {
        body: definitions["v1GetUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUserResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a wallet. */
  PublicApiService_GetWallet: {
    parameters: {
      body: {
        body: definitions["v1GetWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get a single wallet account. */
  PublicApiService_GetWalletAccount: {
    parameters: {
      body: {
        body: definitions["v1GetWalletAccountRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletAccountResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all activities within an organization. */
  PublicApiService_GetActivities: {
    parameters: {
      body: {
        body: definitions["v1GetActivitiesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetActivitiesResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all policies within an organization. */
  PublicApiService_GetPolicies: {
    parameters: {
      body: {
        body: definitions["v1GetPoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPoliciesResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all private key tags within an organization. */
  PublicApiService_ListPrivateKeyTags: {
    parameters: {
      body: {
        body: definitions["v1ListPrivateKeyTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ListPrivateKeyTagsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all private keys within an organization. */
  PublicApiService_GetPrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeysResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** List all smart contract interfaces within an organization. */
=======
  /** List all Smart Contract Interfaces within an Organization */
>>>>>>> 57ef158e (updated auth proxy type generation)
  PublicApiService_GetSmartContractInterfaces: {
    parameters: {
      body: {
        body: definitions["v1GetSmartContractInterfacesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetSmartContractInterfacesResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get all suborg IDs associated given a parent org ID and an optional filter. */
  PublicApiService_GetSubOrgIds: {
    parameters: {
      body: {
        body: definitions["v1GetSubOrgIdsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetSubOrgIdsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all user tags within an organization. */
  PublicApiService_ListUserTags: {
    parameters: {
      body: {
        body: definitions["v1ListUserTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ListUserTagsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all users within an organization. */
  PublicApiService_GetUsers: {
    parameters: {
      body: {
        body: definitions["v1GetUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUsersResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get all email or phone verified suborg IDs associated given a parent org ID. */
  PublicApiService_GetVerifiedSubOrgIds: {
    parameters: {
      body: {
        body: definitions["v1GetVerifiedSubOrgIdsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetVerifiedSubOrgIdsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all accounts within a wallet. */
  PublicApiService_GetWalletAccounts: {
    parameters: {
      body: {
        body: definitions["v1GetWalletAccountsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletAccountsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all wallets within an organization. */
  PublicApiService_GetWallets: {
    parameters: {
      body: {
        body: definitions["v1GetWalletsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get basic information about your current API or WebAuthN user and their organization. Affords sub-organization look ups via parent organization for WebAuthN or API key users. */
  PublicApiService_GetWhoami: {
    parameters: {
      body: {
        body: definitions["v1GetWhoamiRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWhoamiResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Approve an activity. */
  PublicApiService_ApproveActivity: {
    parameters: {
      body: {
        body: definitions["v1ApproveActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Add API keys to an existing user. */
  PublicApiService_CreateApiKeys: {
    parameters: {
      body: {
        body: definitions["v1CreateApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create API-only users in an existing organization. */
  PublicApiService_CreateApiOnlyUsers: {
    parameters: {
      body: {
        body: definitions["v1CreateApiOnlyUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create authenticators to authenticate requests to Turnkey. */
  PublicApiService_CreateAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1CreateAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create invitations to join an existing organization. */
  PublicApiService_CreateInvitations: {
    parameters: {
      body: {
        body: definitions["v1CreateInvitationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Oauth providers for a specified user. */
  PublicApiService_CreateOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1CreateOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new policies. */
  PublicApiService_CreatePolicies: {
    parameters: {
      body: {
        body: definitions["v1CreatePoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new policy. */
  PublicApiService_CreatePolicy: {
    parameters: {
      body: {
        body: definitions["v1CreatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a private key tag and add it to private keys. */
  PublicApiService_CreatePrivateKeyTag: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeyTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new private keys. */
  PublicApiService_CreatePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a read only session for a user (valid for 1 hour). */
  PublicApiService_CreateReadOnlySession: {
    parameters: {
      body: {
        body: definitions["v1CreateReadOnlySessionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a read write session for a user. */
  PublicApiService_CreateReadWriteSession: {
    parameters: {
      body: {
        body: definitions["v1CreateReadWriteSessionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Create an ABI/IDL in JSON. */
=======
  /** Create an ABI/IDL in JSON */
>>>>>>> 57ef158e (updated auth proxy type generation)
  PublicApiService_CreateSmartContractInterface: {
    parameters: {
      body: {
        body: definitions["v1CreateSmartContractInterfaceRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Create a new sub-organization. */
=======
  /** Create a new Sub-Organization */
>>>>>>> 57ef158e (updated auth proxy type generation)
  PublicApiService_CreateSubOrganization: {
    parameters: {
      body: {
        body: definitions["v1CreateSubOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a user tag and add it to users. */
  PublicApiService_CreateUserTag: {
    parameters: {
      body: {
        body: definitions["v1CreateUserTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create users in an existing organization. */
  PublicApiService_CreateUsers: {
    parameters: {
      body: {
        body: definitions["v1CreateUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a wallet and derive addresses. */
  PublicApiService_CreateWallet: {
    parameters: {
      body: {
        body: definitions["v1CreateWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Derive additional addresses using an existing wallet. */
  PublicApiService_CreateWalletAccounts: {
    parameters: {
      body: {
        body: definitions["v1CreateWalletAccountsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove api keys from a user. */
  PublicApiService_DeleteApiKeys: {
    parameters: {
      body: {
        body: definitions["v1DeleteApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove authenticators from a user. */
  PublicApiService_DeleteAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1DeleteAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing invitation. */
  PublicApiService_DeleteInvitation: {
    parameters: {
      body: {
        body: definitions["v1DeleteInvitationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove Oauth providers for a specified user. */
  PublicApiService_DeleteOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1DeleteOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing policy. */
  PublicApiService_DeletePolicy: {
    parameters: {
      body: {
        body: definitions["v1DeletePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete private key tags within an organization. */
  PublicApiService_DeletePrivateKeyTags: {
    parameters: {
      body: {
        body: definitions["v1DeletePrivateKeyTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete private keys for an organization. */
  PublicApiService_DeletePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1DeletePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Delete a smart contract interface. */
=======
  /** Delete a Smart Contract Interface */
>>>>>>> 57ef158e (updated auth proxy type generation)
  PublicApiService_DeleteSmartContractInterface: {
    parameters: {
      body: {
        body: definitions["v1DeleteSmartContractInterfaceRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Delete a sub-organization. */
=======
  /** Deletes a sub organization */
>>>>>>> 57ef158e (updated auth proxy type generation)
  PublicApiService_DeleteSubOrganization: {
    parameters: {
      body: {
        body: definitions["v1DeleteSubOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete user tags within an organization. */
  PublicApiService_DeleteUserTags: {
    parameters: {
      body: {
        body: definitions["v1DeleteUserTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete users within an organization. */
  PublicApiService_DeleteUsers: {
    parameters: {
      body: {
        body: definitions["v1DeleteUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete wallets for an organization. */
  PublicApiService_DeleteWallets: {
    parameters: {
      body: {
        body: definitions["v1DeleteWalletsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Authenticate a user via email. */
=======
  /** Disable User Initiated Auth */
  PublicApiService_DisableUserInitiatedAuth: {
    parameters: {
      body: {
        body: definitions["v1DisableUserInitiatedAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user via Email */
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  PublicApiService_EmailAuth: {
    parameters: {
      body: {
        body: definitions["v1EmailAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
<<<<<<< HEAD
  /** Export a private key. */
=======
  /** Enable User Initiated Auth */
  PublicApiService_EnableUserInitiatedAuth: {
    parameters: {
      body: {
        body: definitions["v1EnableUserInitiatedAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Exports a Private Key */
>>>>>>> 9473ed72 (re-synced sdk, added user, wallets, and proxyAuthConfig to the context)
  PublicApiService_ExportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1ExportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Export a wallet. */
  PublicApiService_ExportWallet: {
    parameters: {
      body: {
        body: definitions["v1ExportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Export a wallet account. */
  PublicApiService_ExportWalletAccount: {
    parameters: {
      body: {
        body: definitions["v1ExportWalletAccountRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Import a private key. */
  PublicApiService_ImportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1ImportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Import a wallet. */
  PublicApiService_ImportWallet: {
    parameters: {
      body: {
        body: definitions["v1ImportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initiate a fiat on ramp flow. */
  PublicApiService_InitFiatOnRamp: {
    parameters: {
      body: {
        body: definitions["v1InitFiatOnRampRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initialize a new private key import. */
  PublicApiService_InitImportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1InitImportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initialize a new wallet import. */
  PublicApiService_InitImportWallet: {
    parameters: {
      body: {
        body: definitions["v1InitImportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initiate a generic OTP activity. */
  PublicApiService_InitOtp: {
    parameters: {
      body: {
        body: definitions["v1InitOtpRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initiate an OTP auth activity. */
  PublicApiService_InitOtpAuth: {
    parameters: {
      body: {
        body: definitions["v1InitOtpAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initialize a new email recovery. */
  PublicApiService_InitUserEmailRecovery: {
    parameters: {
      body: {
        body: definitions["v1InitUserEmailRecoveryRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user with an OIDC token (Oauth). */
  PublicApiService_Oauth: {
    parameters: {
      body: {
        body: definitions["v1OauthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create an Oauth session for a user. */
  PublicApiService_OauthLogin: {
    parameters: {
      body: {
        body: definitions["v1OauthLoginRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user with an OTP code sent via email or SMS. */
  PublicApiService_OtpAuth: {
    parameters: {
      body: {
        body: definitions["v1OtpAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create an OTP session for a user. */
  PublicApiService_OtpLogin: {
    parameters: {
      body: {
        body: definitions["v1OtpLoginRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Complete the process of recovering a user by adding an authenticator. */
  PublicApiService_RecoverUser: {
    parameters: {
      body: {
        body: definitions["v1RecoverUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Reject an activity. */
  PublicApiService_RejectActivity: {
    parameters: {
      body: {
        body: definitions["v1RejectActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove an organization feature. This activity must be approved by the current root quorum. */
  PublicApiService_RemoveOrganizationFeature: {
    parameters: {
      body: {
        body: definitions["v1RemoveOrganizationFeatureRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Set an organization feature. This activity must be approved by the current root quorum. */
  PublicApiService_SetOrganizationFeature: {
    parameters: {
      body: {
        body: definitions["v1SetOrganizationFeatureRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a raw payload. */
  PublicApiService_SignRawPayload: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign multiple raw payloads with the same signing parameters. */
  PublicApiService_SignRawPayloads: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a transaction. */
  PublicApiService_SignTransaction: {
    parameters: {
      body: {
        body: definitions["v1SignTransactionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a session for a user through stamping client side (API key, wallet client, or passkey client). */
  PublicApiService_StampLogin: {
    parameters: {
      body: {
        body: definitions["v1StampLoginRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update an existing policy. */
  PublicApiService_UpdatePolicy: {
    parameters: {
      body: {
        body: definitions["v1UpdatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
  PublicApiService_UpdatePrivateKeyTag: {
    parameters: {
      body: {
        body: definitions["v1UpdatePrivateKeyTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update the proxy-auth configuration (allowed origins, etc.) for an Organization */
  PublicApiService_UpdateProxyAuthConfig: {
    parameters: {
      body: {
        body: definitions["v1UpdateProxyAuthConfigRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Set the threshold and members of the root quorum. This activity must be approved by the current root quorum. */
  PublicApiService_UpdateRootQuorum: {
    parameters: {
      body: {
        body: definitions["v1UpdateRootQuorumRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a user in an existing organization. */
  PublicApiService_UpdateUser: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a user's email in an existing organization. */
  PublicApiService_UpdateUserEmail: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserEmailRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a user's name in an existing organization. */
  PublicApiService_UpdateUserName: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserNameRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a user's phone number in an existing organization. */
  PublicApiService_UpdateUserPhoneNumber: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserPhoneNumberRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
  PublicApiService_UpdateUserTag: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a wallet for an organization. */
  PublicApiService_UpdateWallet: {
    parameters: {
      body: {
        body: definitions["v1UpdateWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Verify a generic OTP. */
  PublicApiService_VerifyOtp: {
    parameters: {
      body: {
        body: definitions["v1VerifyOtpRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  PublicApiService_NOOPCodegenAnchor: {
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1NOOPCodegenAnchorResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Set a rate local rate limit just on the current endpoint, for purposes of testing with Vivosuite. */
  PublicApiService_TestRateLimits: {
    parameters: {
      body: {
        body: definitions["v1TestRateLimitsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1TestRateLimitsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
};

export type external = {};
