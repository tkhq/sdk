/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/public/v1/query/get_activity": {
    /** Get details about an Activity */
    post: operations["PublicApiService_GetActivity"];
  };
  "/public/v1/query/get_api_key": {
    /** Get details about an API key */
    post: operations["PublicApiService_GetApiKey"];
  };
  "/public/v1/query/get_api_keys": {
    /** Get details about API keys for a user */
    post: operations["PublicApiService_GetApiKeys"];
  };
  "/public/v1/query/get_attestation": {
    /** Get the attestation document corresponding to an enclave. */
    post: operations["PublicApiService_GetAttestationDocument"];
  };
  "/public/v1/query/get_authenticator": {
    /** Get details about an authenticator */
    post: operations["PublicApiService_GetAuthenticator"];
  };
  "/public/v1/query/get_authenticators": {
    /** Get details about authenticators for a user */
    post: operations["PublicApiService_GetAuthenticators"];
  };
  "/public/v1/query/get_oauth_providers": {
    /** Get details about Oauth providers for a user */
    post: operations["PublicApiService_GetOauthProviders"];
  };
  "/public/v1/query/get_organization": {
    /** Get details about an Organization */
    post: operations["PublicApiService_GetOrganization"];
  };
  "/public/v1/query/get_organization_configs": {
    /** Get quorum settings and features for an organization */
    post: operations["PublicApiService_GetOrganizationConfigs"];
  };
  "/public/v1/query/get_policy": {
    /** Get details about a Policy */
    post: operations["PublicApiService_GetPolicy"];
  };
  "/public/v1/query/get_private_key": {
    /** Get details about a Private Key */
    post: operations["PublicApiService_GetPrivateKey"];
  };
  "/public/v1/query/get_user": {
    /** Get details about a User */
    post: operations["PublicApiService_GetUser"];
  };
  "/public/v1/query/get_wallet": {
    /** Get details about a Wallet */
    post: operations["PublicApiService_GetWallet"];
  };
  "/public/v1/query/get_wallet_account": {
    /** Get a single wallet account */
    post: operations["PublicApiService_GetWalletAccount"];
  };
  "/public/v1/query/list_activities": {
    /** List all Activities within an Organization */
    post: operations["PublicApiService_GetActivities"];
  };
  "/public/v1/query/list_policies": {
    /** List all Policies within an Organization */
    post: operations["PublicApiService_GetPolicies"];
  };
  "/public/v1/query/list_private_key_tags": {
    /** List all Private Key Tags within an Organization */
    post: operations["PublicApiService_ListPrivateKeyTags"];
  };
  "/public/v1/query/list_private_keys": {
    /** List all Private Keys within an Organization */
    post: operations["PublicApiService_GetPrivateKeys"];
  };
  "/public/v1/query/list_suborgs": {
    /** Get all suborg IDs associated given a parent org ID and an optional filter. */
    post: operations["PublicApiService_GetSubOrgIds"];
  };
  "/public/v1/query/list_user_tags": {
    /** List all User Tags within an Organization */
    post: operations["PublicApiService_ListUserTags"];
  };
  "/public/v1/query/list_users": {
    /** List all Users within an Organization */
    post: operations["PublicApiService_GetUsers"];
  };
  "/public/v1/query/list_verified_suborgs": {
    /** Get all email or phone verified suborg IDs associated given a parent org ID. */
    post: operations["PublicApiService_GetVerifiedSubOrgIds"];
  };
  "/public/v1/query/list_wallet_accounts": {
    /** List all Accounts within a Wallet */
    post: operations["PublicApiService_GetWalletAccounts"];
  };
  "/public/v1/query/list_wallets": {
    /** List all Wallets within an Organization */
    post: operations["PublicApiService_GetWallets"];
  };
  "/public/v1/query/whoami": {
    /** Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN or API key users. */
    post: operations["PublicApiService_GetWhoami"];
  };
  "/public/v1/submit/approve_activity": {
    /** Approve an Activity */
    post: operations["PublicApiService_ApproveActivity"];
  };
  "/public/v1/submit/create_api_keys": {
    /** Add api keys to an existing User */
    post: operations["PublicApiService_CreateApiKeys"];
  };
  "/public/v1/submit/create_api_only_users": {
    /** Create API-only Users in an existing Organization */
    post: operations["PublicApiService_CreateApiOnlyUsers"];
  };
  "/public/v1/submit/create_authenticators": {
    /** Create Authenticators to authenticate requests to Turnkey */
    post: operations["PublicApiService_CreateAuthenticators"];
  };
  "/public/v1/submit/create_invitations": {
    /** Create Invitations to join an existing Organization */
    post: operations["PublicApiService_CreateInvitations"];
  };
  "/public/v1/submit/create_oauth_providers": {
    /** Creates Oauth providers for a specified user - BETA */
    post: operations["PublicApiService_CreateOauthProviders"];
  };
  "/public/v1/submit/create_policies": {
    /** Create new Policies */
    post: operations["PublicApiService_CreatePolicies"];
  };
  "/public/v1/submit/create_policy": {
    /** Create a new Policy */
    post: operations["PublicApiService_CreatePolicy"];
  };
  "/public/v1/submit/create_private_key_tag": {
    /** Create a private key tag and add it to private keys. */
    post: operations["PublicApiService_CreatePrivateKeyTag"];
  };
  "/public/v1/submit/create_private_keys": {
    /** Create new Private Keys */
    post: operations["PublicApiService_CreatePrivateKeys"];
  };
  "/public/v1/submit/create_read_only_session": {
    /** Create a read only session for a user (valid for 1 hour) */
    post: operations["PublicApiService_CreateReadOnlySession"];
  };
  "/public/v1/submit/create_read_write_session": {
    /** Create a read write session for a user */
    post: operations["PublicApiService_CreateReadWriteSession"];
  };
  "/public/v1/submit/create_sub_organization": {
    /** Create a new Sub-Organization */
    post: operations["PublicApiService_CreateSubOrganization"];
  };
  "/public/v1/submit/create_user_tag": {
    /** Create a user tag and add it to users. */
    post: operations["PublicApiService_CreateUserTag"];
  };
  "/public/v1/submit/create_users": {
    /** Create Users in an existing Organization */
    post: operations["PublicApiService_CreateUsers"];
  };
  "/public/v1/submit/create_wallet": {
    /** Create a Wallet and derive addresses */
    post: operations["PublicApiService_CreateWallet"];
  };
  "/public/v1/submit/create_wallet_accounts": {
    /** Derive additional addresses using an existing wallet */
    post: operations["PublicApiService_CreateWalletAccounts"];
  };
  "/public/v1/submit/delete_api_keys": {
    /** Remove api keys from a User */
    post: operations["PublicApiService_DeleteApiKeys"];
  };
  "/public/v1/submit/delete_authenticators": {
    /** Remove authenticators from a User */
    post: operations["PublicApiService_DeleteAuthenticators"];
  };
  "/public/v1/submit/delete_invitation": {
    /** Delete an existing Invitation */
    post: operations["PublicApiService_DeleteInvitation"];
  };
  "/public/v1/submit/delete_oauth_providers": {
    /** Removes Oauth providers for a specified user - BETA */
    post: operations["PublicApiService_DeleteOauthProviders"];
  };
  "/public/v1/submit/delete_policy": {
    /** Delete an existing Policy */
    post: operations["PublicApiService_DeletePolicy"];
  };
  "/public/v1/submit/delete_private_key_tags": {
    /** Delete Private Key Tags within an Organization */
    post: operations["PublicApiService_DeletePrivateKeyTags"];
  };
  "/public/v1/submit/delete_private_keys": {
    /** Deletes private keys for an organization */
    post: operations["PublicApiService_DeletePrivateKeys"];
  };
  "/public/v1/submit/delete_sub_organization": {
    /** Deletes a sub organization */
    post: operations["PublicApiService_DeleteSubOrganization"];
  };
  "/public/v1/submit/delete_user_tags": {
    /** Delete User Tags within an Organization */
    post: operations["PublicApiService_DeleteUserTags"];
  };
  "/public/v1/submit/delete_users": {
    /** Delete Users within an Organization */
    post: operations["PublicApiService_DeleteUsers"];
  };
  "/public/v1/submit/delete_wallets": {
    /** Deletes wallets for an organization */
    post: operations["PublicApiService_DeleteWallets"];
  };
  "/public/v1/submit/email_auth": {
    /** Authenticate a user via Email */
    post: operations["PublicApiService_EmailAuth"];
  };
  "/public/v1/submit/export_private_key": {
    /** Exports a Private Key */
    post: operations["PublicApiService_ExportPrivateKey"];
  };
  "/public/v1/submit/export_wallet": {
    /** Exports a Wallet */
    post: operations["PublicApiService_ExportWallet"];
  };
  "/public/v1/submit/export_wallet_account": {
    /** Exports a Wallet Account */
    post: operations["PublicApiService_ExportWalletAccount"];
  };
  "/public/v1/submit/import_private_key": {
    /** Imports a private key */
    post: operations["PublicApiService_ImportPrivateKey"];
  };
  "/public/v1/submit/import_wallet": {
    /** Imports a wallet */
    post: operations["PublicApiService_ImportWallet"];
  };
  "/public/v1/submit/init_import_private_key": {
    /** Initializes a new private key import */
    post: operations["PublicApiService_InitImportPrivateKey"];
  };
  "/public/v1/submit/init_import_wallet": {
    /** Initializes a new wallet import */
    post: operations["PublicApiService_InitImportWallet"];
  };
  "/public/v1/submit/init_otp_auth": {
    /** Initiate an OTP auth activity */
    post: operations["PublicApiService_InitOtpAuth"];
  };
  "/public/v1/submit/init_user_email_recovery": {
    /** Initializes a new email recovery */
    post: operations["PublicApiService_InitUserEmailRecovery"];
  };
  "/public/v1/submit/oauth": {
    /** Authenticate a user with an Oidc token (Oauth) - BETA */
    post: operations["PublicApiService_Oauth"];
  };
  "/public/v1/submit/otp_auth": {
    /** Authenticate a user with an OTP code sent via email or SMS */
    post: operations["PublicApiService_OtpAuth"];
  };
  "/public/v1/submit/recover_user": {
    /** Completes the process of recovering a user by adding an authenticator */
    post: operations["PublicApiService_RecoverUser"];
  };
  "/public/v1/submit/reject_activity": {
    /** Reject an Activity */
    post: operations["PublicApiService_RejectActivity"];
  };
  "/public/v1/submit/remove_organization_feature": {
    /** Removes an organization feature. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_RemoveOrganizationFeature"];
  };
  "/public/v1/submit/set_organization_feature": {
    /** Sets an organization feature. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_SetOrganizationFeature"];
  };
  "/public/v1/submit/sign_raw_payload": {
    /** Sign a raw payload */
    post: operations["PublicApiService_SignRawPayload"];
  };
  "/public/v1/submit/sign_raw_payloads": {
    /** Sign multiple raw payloads with the same signing parameters */
    post: operations["PublicApiService_SignRawPayloads"];
  };
  "/public/v1/submit/sign_transaction": {
    /** Sign a transaction */
    post: operations["PublicApiService_SignTransaction"];
  };
  "/public/v1/submit/update_policy": {
    /** Update an existing Policy */
    post: operations["PublicApiService_UpdatePolicy"];
  };
  "/public/v1/submit/update_private_key_tag": {
    /** Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
    post: operations["PublicApiService_UpdatePrivateKeyTag"];
  };
  "/public/v1/submit/update_root_quorum": {
    /** Set the threshold and members of the root quorum. This activity must be approved by the current root quorum. */
    post: operations["PublicApiService_UpdateRootQuorum"];
  };
  "/public/v1/submit/update_user": {
    /** Update a User in an existing Organization */
    post: operations["PublicApiService_UpdateUser"];
  };
  "/public/v1/submit/update_user_tag": {
    /** Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
    post: operations["PublicApiService_UpdateUserTag"];
  };
  "/public/v1/submit/update_wallet": {
    /** Update a wallet for an organization */
    post: operations["PublicApiService_UpdateWallet"];
  };
  "/tkhq/api/v1/noop-codegen-anchor": {
    post: operations["PublicApiService_NOOPCodegenAnchor"];
  };
  "/tkhq/api/v1/test_rate_limits": {
    /** Set a rate local rate limit just on the current endpoint, for purposes of testing with Vivosuite */
    post: operations["PublicApiService_TestRateLimits"];
  };
};

export type definitions = {
  apiApiKeyParams: {
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description Optional window (in seconds) indicating how long the API Key should last. */
    expirationSeconds?: string;
  };
  billingActivateBillingTierIntent: {
    /** @description The product that the customer wants to subscribe to. */
    productId: string;
  };
  billingActivateBillingTierResult: {
    /** @description The id of the product being subscribed to. */
    productId: string;
  };
  billingDeletePaymentMethodIntent: {
    /** @description The payment method that the customer wants to remove. */
    paymentMethodId: string;
  };
  billingDeletePaymentMethodResult: {
    /** @description The payment method that was removed. */
    paymentMethodId: string;
  };
  billingSetPaymentMethodIntent: {
    /** @description The account number of the customer's credit card. */
    number: string;
    /** @description The verification digits of the customer's credit card. */
    cvv: string;
    /** @description The month that the credit card expires. */
    expiryMonth: string;
    /** @description The year that the credit card expires. */
    expiryYear: string;
    /** @description The email that will receive invoices for the credit card. */
    cardHolderEmail: string;
    /** @description The name associated with the credit card. */
    cardHolderName: string;
  };
  billingSetPaymentMethodIntentV2: {
    /** @description The id of the payment method that was created clientside. */
    paymentMethodId: string;
    /** @description The email that will receive invoices for the credit card. */
    cardHolderEmail: string;
    /** @description The name associated with the credit card. */
    cardHolderName: string;
  };
  billingSetPaymentMethodResult: {
    /** @description The last four digits of the credit card added. */
    lastFour: string;
    /** @description The name associated with the payment method. */
    cardHolderName: string;
    /** @description The email address associated with the payment method. */
    cardHolderEmail: string;
  };
  datav1Tag: {
    /** @description Unique identifier for a given Tag. */
    tagId: string;
    /** @description Human-readable name for a Tag. */
    tagName: string;
    tagType: definitions["v1TagType"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  externaldatav1Address: {
    format?: definitions["v1AddressFormat"];
    address?: string;
  };
  externaldatav1Credential: {
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    type: definitions["v1CredentialType"];
  };
  externaldatav1Quorum: {
    /**
     * Format: int32
     * @description Count of unique approvals required to meet quorum.
     */
    threshold: number;
    /** @description Unique identifiers of quorum set members. */
    userIds: string[];
  };
  externaldatav1Timestamp: {
    seconds: string;
    nanos: string;
  };
  immutableactivityv1Address: {
    format?: definitions["v1AddressFormat"];
    address?: string;
  };
  protobufAny: {
    "@type"?: string;
  } & { [key: string]: unknown };
  rpcStatus: {
    /** Format: int32 */
    code?: number;
    message?: string;
    details?: definitions["protobufAny"][];
  };
  v1AcceptInvitationIntent: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
    authenticator: definitions["v1AuthenticatorParams"];
  };
  v1AcceptInvitationIntentV2: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
    authenticator: definitions["v1AuthenticatorParamsV2"];
  };
  v1AcceptInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  /** @enum {string} */
  v1AccessType: "ACCESS_TYPE_WEB" | "ACCESS_TYPE_API" | "ACCESS_TYPE_ALL";
  v1Activity: {
    /** @description Unique identifier for a given Activity object. */
    id: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description The current processing status of a specified Activity. */
    status: definitions["v1ActivityStatus"];
    /** @description Type of Activity, such as Add User, or Sign Transaction. */
    type: definitions["v1ActivityType"];
    /** @description Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
    intent: definitions["v1Intent"];
    /** @description Result of the intended action. */
    result: definitions["v1Result"];
    /** @description A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
    votes: definitions["v1Vote"][];
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
    canApprove: boolean;
    canReject: boolean;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Failure reason of the intended action. */
    failure?: definitions["rpcStatus"];
  };
  v1ActivityResponse: {
    /** @description An action that can that can be taken within the Turnkey infrastructure. */
    activity: definitions["v1Activity"];
  };
  /** @enum {string} */
  v1ActivityStatus:
    | "ACTIVITY_STATUS_CREATED"
    | "ACTIVITY_STATUS_PENDING"
    | "ACTIVITY_STATUS_COMPLETED"
    | "ACTIVITY_STATUS_FAILED"
    | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    | "ACTIVITY_STATUS_REJECTED";
  /** @enum {string} */
  v1ActivityType:
    | "ACTIVITY_TYPE_CREATE_API_KEYS"
    | "ACTIVITY_TYPE_CREATE_USERS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
    | "ACTIVITY_TYPE_CREATE_INVITATIONS"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION"
    | "ACTIVITY_TYPE_CREATE_POLICY"
    | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
    | "ACTIVITY_TYPE_DELETE_USERS"
    | "ACTIVITY_TYPE_DELETE_API_KEYS"
    | "ACTIVITY_TYPE_DELETE_INVITATION"
    | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
    | "ACTIVITY_TYPE_DELETE_POLICY"
    | "ACTIVITY_TYPE_CREATE_USER_TAG"
    | "ACTIVITY_TYPE_DELETE_USER_TAGS"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION"
    | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    | "ACTIVITY_TYPE_REJECT_ACTIVITY"
    | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    | "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
    | "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
    | "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
    | "ACTIVITY_TYPE_CREATE_POLICY_V2"
    | "ACTIVITY_TYPE_CREATE_POLICY_V3"
    | "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
    | "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
    | "ACTIVITY_TYPE_UPDATE_USER_TAG"
    | "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
    | "ACTIVITY_TYPE_CREATE_USERS_V2"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
    | "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
    | "ACTIVITY_TYPE_UPDATE_USER"
    | "ACTIVITY_TYPE_UPDATE_POLICY"
    | "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
    | "ACTIVITY_TYPE_CREATE_WALLET"
    | "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
    | "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
    | "ACTIVITY_TYPE_RECOVER_USER"
    | "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
    | "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    | "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_EXPORT_WALLET"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
    | "ACTIVITY_TYPE_EMAIL_AUTH"
    | "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
    | "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
    | "ACTIVITY_TYPE_IMPORT_WALLET"
    | "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
    | "ACTIVITY_TYPE_CREATE_POLICIES"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
    | "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
    | "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
    | "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
    | "ACTIVITY_TYPE_OAUTH"
    | "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
    | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
    | "ACTIVITY_TYPE_EMAIL_AUTH_V2"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_DELETE_WALLETS"
    | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
    | "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
    | "ACTIVITY_TYPE_INIT_OTP_AUTH"
    | "ACTIVITY_TYPE_OTP_AUTH"
    | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
    | "ACTIVITY_TYPE_UPDATE_WALLET";
  /** @enum {string} */
  v1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_SOLANA"
    | "ADDRESS_FORMAT_COSMOS"
    | "ADDRESS_FORMAT_TRON"
    | "ADDRESS_FORMAT_SUI"
    | "ADDRESS_FORMAT_APTOS"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
    | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
    | "ADDRESS_FORMAT_SEI"
    | "ADDRESS_FORMAT_XLM"
    | "ADDRESS_FORMAT_DOGE_MAINNET"
    | "ADDRESS_FORMAT_DOGE_TESTNET"
    | "ADDRESS_FORMAT_TON_V3R2"
    | "ADDRESS_FORMAT_TON_V4R2"
    | "ADDRESS_FORMAT_XRP";
  v1ApiKey: {
    /** @description A User credential that can be used to authenticate to Turnkey. */
    credential: definitions["externaldatav1Credential"];
    /** @description Unique identifier for a given API Key. */
    apiKeyId: string;
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /**
     * Format: uint64
     * @description Optional window (in seconds) indicating how long the API Key should last.
     */
    expirationSeconds?: string;
  };
  /** @enum {string} */
  v1ApiKeyCurve:
    | "API_KEY_CURVE_P256"
    | "API_KEY_CURVE_SECP256K1"
    | "API_KEY_CURVE_ED25519";
  v1ApiKeyParamsV2: {
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description The curve type to be used for processing API key signatures. */
    curveType: definitions["v1ApiKeyCurve"];
    /** @description Optional window (in seconds) indicating how long the API Key should last. */
    expirationSeconds?: string;
  };
  v1ApiOnlyUserParams: {
    /** @description The name of the new API-only User. */
    userName: string;
    /** @description The email address for this API-only User (optional). */
    userEmail?: string;
    /** @description A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
  };
  v1ApproveActivityIntent: {
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
  };
  v1ApproveActivityRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_APPROVE_ACTIVITY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ApproveActivityIntent"];
  };
  v1Attestation: {
    /** @description The cbor encoded then base64 url encoded id of the credential. */
    credentialId: string;
    /** @description A base64 url encoded payload containing metadata about the signing context and the challenge. */
    clientDataJson: string;
    /** @description A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
    attestationObject: string;
    /** @description The type of authenticator transports. */
    transports: definitions["v1AuthenticatorTransport"][];
  };
  v1Authenticator: {
    /** @description Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
    transports: definitions["v1AuthenticatorTransport"][];
    attestationType: string;
    /** @description Identifier indicating the type of the Security Key. */
    aaguid: string;
    /** @description Unique identifier for a WebAuthn credential. */
    credentialId: string;
    /** @description The type of Authenticator device. */
    model: string;
    /** @description A User credential that can be used to authenticate to Turnkey. */
    credential: definitions["externaldatav1Credential"];
    /** @description Unique identifier for a given Authenticator. */
    authenticatorId: string;
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1AuthenticatorAttestationResponse: {
    clientDataJson: string;
    attestationObject: string;
    transports?: definitions["v1AuthenticatorTransport"][];
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
  };
  v1AuthenticatorParams: {
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    attestation: definitions["v1PublicKeyCredentialWithAttestation"];
    /** @description Challenge presented for authentication purposes. */
    challenge: string;
  };
  v1AuthenticatorParamsV2: {
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    /** @description Challenge presented for authentication purposes. */
    challenge: string;
    /** @description The attestation that proves custody of the authenticator and provides metadata about it. */
    attestation: definitions["v1Attestation"];
  };
  /** @enum {string} */
  v1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  v1Config: {
    features?: definitions["v1Feature"][];
    quorum?: definitions["externaldatav1Quorum"];
  };
  v1CreateApiKeysIntent: {
    /** @description A list of API Keys. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateApiKeysIntentV2: {
    /** @description A list of API Keys. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateApiKeysIntentV2"];
  };
  v1CreateApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1CreateApiOnlyUsersIntent: {
    /** @description A list of API-only Users to create. */
    apiOnlyUsers: definitions["v1ApiOnlyUserParams"][];
  };
  v1CreateApiOnlyUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateApiOnlyUsersIntent"];
  };
  v1CreateApiOnlyUsersResult: {
    /** @description A list of API-only User IDs. */
    userIds: string[];
  };
  v1CreateAuthenticatorsIntent: {
    /** @description A list of Authenticators. */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateAuthenticatorsIntentV2: {
    /** @description A list of Authenticators. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1CreateAuthenticatorsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateAuthenticatorsIntentV2"];
  };
  v1CreateAuthenticatorsResult: {
    /** @description A list of Authenticator IDs. */
    authenticatorIds: string[];
  };
  v1CreateInvitationsIntent: {
    /** @description A list of Invitations. */
    invitations: definitions["v1InvitationParams"][];
  };
  v1CreateInvitationsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_INVITATIONS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateInvitationsIntent"];
  };
  v1CreateInvitationsResult: {
    /** @description A list of Invitation IDs */
    invitationIds: string[];
  };
  v1CreateOauthProvidersIntent: {
    /** @description The ID of the User to add an Oauth provider to */
    userId: string;
    /** @description A list of Oauth providers. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1CreateOauthProvidersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateOauthProvidersIntent"];
  };
  v1CreateOauthProvidersResult: {
    /** @description A list of unique identifiers for Oauth Providers */
    providerIds: string[];
  };
  v1CreateOrganizationIntent: {
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description The root user's email address. */
    rootEmail: string;
    /** @description The root user's Authenticator. */
    rootAuthenticator: definitions["v1AuthenticatorParams"];
    /** @description Unique identifier for the root user object. */
    rootUserId?: string;
  };
  v1CreateOrganizationIntentV2: {
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description The root user's email address. */
    rootEmail: string;
    /** @description The root user's Authenticator. */
    rootAuthenticator: definitions["v1AuthenticatorParamsV2"];
    /** @description Unique identifier for the root user object. */
    rootUserId?: string;
  };
  v1CreateOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1CreatePoliciesIntent: {
    /** @description An array of policy intents to be created. */
    policies: definitions["v1CreatePolicyIntentV3"][];
  };
  v1CreatePoliciesRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICIES";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePoliciesIntent"];
  };
  v1CreatePoliciesResult: {
    /** @description A list of unique identifiers for the created policies. */
    policyIds: string[];
  };
  v1CreatePolicyIntent: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
    selectors: definitions["v1Selector"][];
    /** @description The instruction to DENY or ALLOW a particular activity following policy selector(s). */
    effect: definitions["v1Effect"];
    notes?: string;
  };
  v1CreatePolicyIntentV2: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
    selectors: definitions["v1SelectorV2"][];
    /** @description Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
    effect: definitions["v1Effect"];
    notes?: string;
  };
  v1CreatePolicyIntentV3: {
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description The instruction to DENY or ALLOW an activity. */
    effect: definitions["v1Effect"];
    /** @description The condition expression that triggers the Effect */
    condition?: string;
    /** @description The consensus expression that triggers the Effect */
    consensus?: string;
    notes?: string;
  };
  v1CreatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICY_V3";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePolicyIntentV3"];
  };
  v1CreatePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1CreatePrivateKeyTagIntent: {
    /** @description Human-readable name for a Private Key Tag. */
    privateKeyTagName: string;
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeyTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeyTagIntent"];
  };
  v1CreatePrivateKeyTagResult: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysIntent: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysIntentV2: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeysIntentV2"];
  };
  v1CreatePrivateKeysResult: {
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysResultV2: {
    /** @description A list of Private Key IDs and addresses. */
    privateKeys: definitions["v1PrivateKeyResult"][];
  };
  v1CreateReadOnlySessionIntent: { [key: string]: unknown };
  v1CreateReadOnlySessionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateReadOnlySessionIntent"];
  };
  v1CreateReadOnlySessionResult: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description String representing a read only session */
    session: string;
    /**
     * Format: uint64
     * @description UTC timestamp in seconds representing the expiry time for the read only session.
     */
    sessionExpiry: string;
  };
  v1CreateReadWriteSessionIntent: {
    /** @description Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Email of the user to create a read write session for */
    email: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
  };
  v1CreateReadWriteSessionIntentV2: {
    /** @description Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Unique identifier for a given User. */
    userId?: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated ReadWriteSession API keys */
    invalidateExisting?: boolean;
  };
  v1CreateReadWriteSessionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateReadWriteSessionIntentV2"];
  };
  v1CreateReadWriteSessionResult: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  v1CreateReadWriteSessionResultV2: {
    /** @description Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  v1CreateSubOrganizationIntent: {
    /** @description Name for this sub-organization */
    name: string;
    /** @description Root User authenticator for this new sub-organization */
    rootAuthenticator: definitions["v1AuthenticatorParamsV2"];
  };
  v1CreateSubOrganizationIntentV2: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
  };
  v1CreateSubOrganizationIntentV3: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreateSubOrganizationIntentV4: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParams"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV5: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV2"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV6: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV3"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
  };
  v1CreateSubOrganizationIntentV7: {
    /** @description Name for this sub-organization */
    subOrganizationName: string;
    /** @description Root users to create within this sub-organization */
    rootUsers: definitions["v1RootUserParamsV4"][];
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
     */
    rootQuorumThreshold: number;
    /** @description The wallet to create for the sub-organization */
    wallet?: definitions["v1WalletParams"];
    /** @description Disable email recovery for the sub-organization */
    disableEmailRecovery?: boolean;
    /** @description Disable email auth for the sub-organization */
    disableEmailAuth?: boolean;
    /** @description Disable OTP SMS auth for the sub-organization */
    disableSmsAuth?: boolean;
    /** @description Disable OTP email auth for the sub-organization */
    disableOtpEmailAuth?: boolean;
  };
  v1CreateSubOrganizationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateSubOrganizationIntentV7"];
  };
  v1CreateSubOrganizationResult: {
    subOrganizationId: string;
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV3: {
    subOrganizationId: string;
    /** @description A list of Private Key IDs and addresses. */
    privateKeys: definitions["v1PrivateKeyResult"][];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV4: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV5: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV6: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateSubOrganizationResultV7: {
    subOrganizationId: string;
    wallet?: definitions["v1WalletResult"];
    rootUserIds?: string[];
  };
  v1CreateUserTagIntent: {
    /** @description Human-readable name for a User Tag. */
    userTagName: string;
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateUserTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_USER_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateUserTagIntent"];
  };
  v1CreateUserTagResult: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateUsersIntent: {
    /** @description A list of Users. */
    users: definitions["v1UserParams"][];
  };
  v1CreateUsersIntentV2: {
    /** @description A list of Users. */
    users: definitions["v1UserParamsV2"][];
  };
  v1CreateUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_USERS_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateUsersIntentV2"];
  };
  v1CreateUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateWalletAccountsIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description A list of wallet Accounts. */
    accounts: definitions["v1WalletAccountParams"][];
  };
  v1CreateWalletAccountsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateWalletAccountsIntent"];
  };
  v1CreateWalletAccountsResult: {
    /** @description A list of derived addresses. */
    addresses: string[];
  };
  v1CreateWalletIntent: {
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
    accounts: definitions["v1WalletAccountParams"][];
    /**
     * Format: int32
     * @description Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
     */
    mnemonicLength?: number;
  };
  v1CreateWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateWalletIntent"];
  };
  v1CreateWalletResult: {
    /** @description Unique identifier for a Wallet. */
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1CredPropsAuthenticationExtensionsClientOutputs: {
    rk: boolean;
  };
  /** @enum {string} */
  v1CredentialType:
    | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
    | "CREDENTIAL_TYPE_API_KEY_P256"
    | "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
    | "CREDENTIAL_TYPE_API_KEY_SECP256K1"
    | "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
    | "CREDENTIAL_TYPE_API_KEY_ED25519"
    | "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
    | "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
    | "CREDENTIAL_TYPE_OAUTH_KEY_P256";
  /** @enum {string} */
  v1Curve: "CURVE_SECP256K1" | "CURVE_ED25519";
  v1DeleteApiKeysIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1DeleteApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_API_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteApiKeysIntent"];
  };
  v1DeleteApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1DeleteAuthenticatorsIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description A list of Authenticator IDs. */
    authenticatorIds: string[];
  };
  v1DeleteAuthenticatorsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteAuthenticatorsIntent"];
  };
  v1DeleteAuthenticatorsResult: {
    /** @description Unique identifier for a given Authenticator. */
    authenticatorIds: string[];
  };
  v1DeleteInvitationIntent: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
  };
  v1DeleteInvitationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_INVITATION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteInvitationIntent"];
  };
  v1DeleteInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
  };
  v1DeleteOauthProvidersIntent: {
    /** @description The ID of the User to remove an Oauth provider from */
    userId: string;
    /** @description Unique identifier for a given Provider. */
    providerIds: string[];
  };
  v1DeleteOauthProvidersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteOauthProvidersIntent"];
  };
  v1DeleteOauthProvidersResult: {
    /** @description A list of unique identifiers for Oauth Providers */
    providerIds: string[];
  };
  v1DeleteOrganizationIntent: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1DeleteOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1DeletePolicyIntent: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1DeletePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_POLICY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePolicyIntent"];
  };
  v1DeletePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1DeletePrivateKeyTagsIntent: {
    /** @description A list of Private Key Tag IDs. */
    privateKeyTagIds: string[];
  };
  v1DeletePrivateKeyTagsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePrivateKeyTagsIntent"];
  };
  v1DeletePrivateKeyTagsResult: {
    /** @description A list of Private Key Tag IDs. */
    privateKeyTagIds: string[];
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1DeletePrivateKeysIntent: {
    /** @description List of unique identifiers for private keys within an organization */
    privateKeyIds: string[];
    /** @description Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
    deleteWithoutExport?: boolean;
  };
  v1DeletePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePrivateKeysIntent"];
  };
  v1DeletePrivateKeysResult: {
    /** @description A list of private key unique identifiers that were removed */
    privateKeyIds: string[];
  };
  v1DeleteSubOrganizationIntent: {
    /** @description Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
    deleteWithoutExport?: boolean;
  };
  v1DeleteSubOrganizationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteSubOrganizationIntent"];
  };
  v1DeleteSubOrganizationResult: {
    /** @description Unique identifier of the sub organization that was removed */
    subOrganizationUuid: string;
  };
  v1DeleteUserTagsIntent: {
    /** @description A list of User Tag IDs. */
    userTagIds: string[];
  };
  v1DeleteUserTagsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_USER_TAGS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteUserTagsIntent"];
  };
  v1DeleteUserTagsResult: {
    /** @description A list of User Tag IDs. */
    userTagIds: string[];
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteUsersIntent: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_USERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteUsersIntent"];
  };
  v1DeleteUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteWalletsIntent: {
    /** @description List of unique identifiers for wallets within an organization */
    walletIds: string[];
    /** @description Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
    deleteWithoutExport?: boolean;
  };
  v1DeleteWalletsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_WALLETS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteWalletsIntent"];
  };
  v1DeleteWalletsResult: {
    /** @description A list of wallet unique identifiers that were removed */
    walletIds: string[];
  };
  v1DisablePrivateKeyIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1DisablePrivateKeyResult: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  /** @enum {string} */
  v1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  v1EmailAuthIntent: {
    /** @description Email of the authenticating user. */
    email: string;
    /** @description Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Invalidate all other previously generated Email Auth API keys */
    invalidateExisting?: boolean;
    /** @description Optional custom email address from which to send the email */
    sendFromEmailAddress?: string;
  };
  v1EmailAuthIntentV2: {
    /** @description Email of the authenticating user. */
    email: string;
    /** @description Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Invalidate all other previously generated Email Auth API keys */
    invalidateExisting?: boolean;
    /** @description Optional custom email address from which to send the email */
    sendFromEmailAddress?: string;
  };
  v1EmailAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EMAIL_AUTH_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1EmailAuthIntentV2"];
  };
  v1EmailAuthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
  };
  v1EmailCustomizationParams: {
    /** @description The name of the application. */
    appName?: string;
    /** @description A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
    logoUrl?: string;
    /** @description A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
    magicLinkTemplate?: string;
    /** @description JSON object containing key/value pairs to be used with custom templates. */
    templateVariables?: string;
    /** @description Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
    templateId?: string;
  };
  v1ExportPrivateKeyIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
  };
  v1ExportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportPrivateKeyIntent"];
  };
  v1ExportPrivateKeyResult: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Export bundle containing a private key encrypted to the client's target public key. */
    exportBundle: string;
  };
  v1ExportWalletAccountIntent: {
    /** @description Address to identify Wallet Account. */
    address: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
  };
  v1ExportWalletAccountRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportWalletAccountIntent"];
  };
  v1ExportWalletAccountResult: {
    /** @description Address to identify Wallet Account. */
    address: string;
    /** @description Export bundle containing a private key encrypted by the client's target public key. */
    exportBundle: string;
  };
  v1ExportWalletIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Client-side public key generated by the user, to which the export bundle will be encrypted. */
    targetPublicKey: string;
    /** @description The language of the mnemonic to export. Defaults to English. */
    language?: definitions["v1MnemonicLanguage"];
  };
  v1ExportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_EXPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ExportWalletIntent"];
  };
  v1ExportWalletResult: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
    exportBundle: string;
  };
  v1Feature: {
    name?: definitions["v1FeatureName"];
    value?: string;
  };
  /** @enum {string} */
  v1FeatureName:
    | "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
    | "FEATURE_NAME_WEBAUTHN_ORIGINS"
    | "FEATURE_NAME_EMAIL_AUTH"
    | "FEATURE_NAME_EMAIL_RECOVERY"
    | "FEATURE_NAME_WEBHOOK"
    | "FEATURE_NAME_SMS_AUTH"
    | "FEATURE_NAME_OTP_EMAIL_AUTH";
  v1GetActivitiesRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Array of Activity Statuses filtering which Activities will be listed in the response. */
    filterByStatus?: definitions["v1ActivityStatus"][];
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
    /** @description Array of Activity Types filtering which Activities will be listed in the response. */
    filterByType?: definitions["v1ActivityType"][];
  };
  v1GetActivitiesResponse: {
    /** @description A list of Activities. */
    activities: definitions["v1Activity"][];
  };
  v1GetActivityRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Activity object. */
    activityId: string;
  };
  v1GetApiKeyRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given API key. */
    apiKeyId: string;
  };
  v1GetApiKeyResponse: {
    /** @description An API key. */
    apiKey: definitions["v1ApiKey"];
  };
  v1GetApiKeysRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given User. */
    userId?: string;
  };
  v1GetApiKeysResponse: {
    /** @description A list of API keys. */
    apiKeys: definitions["v1ApiKey"][];
  };
  v1GetAttestationDocumentRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description The enclave type, one of: ump, notarizer, signer, evm-parser */
    enclaveType: string;
  };
  v1GetAttestationDocumentResponse: {
    /**
     * Format: byte
     * @description Raw (CBOR-encoded) attestation document
     */
    attestationDocument: string;
  };
  v1GetAuthenticatorRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Authenticator. */
    authenticatorId: string;
  };
  v1GetAuthenticatorResponse: {
    /** @description An authenticator. */
    authenticator: definitions["v1Authenticator"];
  };
  v1GetAuthenticatorsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1GetAuthenticatorsResponse: {
    /** @description A list of authenticators. */
    authenticators: definitions["v1Authenticator"][];
  };
  v1GetOauthProvidersRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given User. */
    userId?: string;
  };
  v1GetOauthProvidersResponse: {
    /** @description A list of Oauth Providers */
    oauthProviders: definitions["v1OauthProvider"][];
  };
  v1GetOrganizationConfigsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetOrganizationConfigsResponse: {
    /** @description Organization configs including quorum settings and organization features */
    configs: definitions["v1Config"];
  };
  v1GetOrganizationRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetOrganizationResponse: {
    /** @description Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
    organizationData: definitions["v1OrganizationData"];
  };
  v1GetPoliciesRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetPoliciesResponse: {
    /** @description A list of Policies. */
    policies: definitions["v1Policy"][];
  };
  v1GetPolicyRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1GetPolicyResponse: {
    /** @description Object that codifies rules defining the actions that are permissible within an Organization. */
    policy: definitions["v1Policy"];
  };
  v1GetPrivateKeyRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1GetPrivateKeyResponse: {
    /** @description Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
    privateKey: definitions["v1PrivateKey"];
  };
  v1GetPrivateKeysRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetPrivateKeysResponse: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKey"][];
  };
  v1GetSubOrgIdsRequest: {
    /** @description Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
    organizationId: string;
    /** @description Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
    filterType?: string;
    /** @description The value of the filter to apply for the specified type. For example, a specific email or name string. */
    filterValue?: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetSubOrgIdsResponse: {
    /** @description List of unique identifiers for the matching sub-organizations. */
    organizationIds: string[];
  };
  v1GetUserRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1GetUserResponse: {
    /** @description Web and/or API user within your Organization. */
    user: definitions["v1User"];
  };
  v1GetUsersRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetUsersResponse: {
    /** @description A list of Users. */
    users: definitions["v1User"][];
  };
  v1GetVerifiedSubOrgIdsRequest: {
    /** @description Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
    organizationId: string;
    /** @description Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER' */
    filterType?: string;
    /** @description The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
    filterValue?: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetVerifiedSubOrgIdsResponse: {
    /** @description List of unique identifiers for the matching sub-organizations. */
    organizationIds: string[];
  };
  v1GetWalletAccountRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Address corresponding to a Wallet Account. */
    address?: string;
    /** @description Path corresponding to a Wallet Account. */
    path?: string;
  };
  v1GetWalletAccountResponse: {
    /** @description The resulting Wallet Account. */
    account: definitions["v1WalletAccount"];
  };
  v1GetWalletAccountsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Parameters used for cursor-based pagination. */
    paginationOptions?: definitions["v1Pagination"];
  };
  v1GetWalletAccountsResponse: {
    /** @description A list of Accounts generated from a Wallet that share a common seed. */
    accounts: definitions["v1WalletAccount"][];
  };
  v1GetWalletRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
  };
  v1GetWalletResponse: {
    /** @description A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
    wallet: definitions["v1Wallet"];
  };
  v1GetWalletsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetWalletsResponse: {
    /** @description A list of Wallets. */
    wallets: definitions["v1Wallet"][];
  };
  v1GetWhoamiRequest: {
    /** @description Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
    organizationId: string;
  };
  v1GetWhoamiResponse: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
  };
  /** @enum {string} */
  v1HashFunction:
    | "HASH_FUNCTION_NO_OP"
    | "HASH_FUNCTION_SHA256"
    | "HASH_FUNCTION_KECCAK256"
    | "HASH_FUNCTION_NOT_APPLICABLE";
  v1ImportPrivateKeyIntent: {
    /** @description The ID of the User importing a Private Key. */
    userId: string;
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Bundle containing a raw private key encrypted to the enclave's target public key. */
    encryptedBundle: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
    addressFormats: definitions["v1AddressFormat"][];
  };
  v1ImportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ImportPrivateKeyIntent"];
  };
  v1ImportPrivateKeyResult: {
    /** @description Unique identifier for a Private Key. */
    privateKeyId: string;
    /** @description A list of addresses. */
    addresses: definitions["immutableactivityv1Address"][];
  };
  v1ImportWalletIntent: {
    /** @description The ID of the User importing a Wallet. */
    userId: string;
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
    encryptedBundle: string;
    /** @description A list of wallet Accounts. */
    accounts: definitions["v1WalletAccountParams"][];
  };
  v1ImportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_IMPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1ImportWalletIntent"];
  };
  v1ImportWalletResult: {
    /** @description Unique identifier for a Wallet. */
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1InitImportPrivateKeyIntent: {
    /** @description The ID of the User importing a Private Key. */
    userId: string;
  };
  v1InitImportPrivateKeyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitImportPrivateKeyIntent"];
  };
  v1InitImportPrivateKeyResult: {
    /** @description Import bundle containing a public key and signature to use for importing client data. */
    importBundle: string;
  };
  v1InitImportWalletIntent: {
    /** @description The ID of the User importing a Wallet. */
    userId: string;
  };
  v1InitImportWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitImportWalletIntent"];
  };
  v1InitImportWalletResult: {
    /** @description Import bundle containing a public key and signature to use for importing client data. */
    importBundle: string;
  };
  v1InitOtpAuthIntent: {
    /** @description Enum to specifiy whether to send OTP via SMS or email */
    otpType: string;
    /** @description Email or phone number to send the OTP code to */
    contact: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
    /** @description Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
    smsCustomization?: definitions["v1SmsCustomizationParams"];
    /** @description Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
    userIdentifier?: string;
    /** @description Optional custom email address from which to send the OTP email */
    sendFromEmailAddress?: string;
  };
  v1InitOtpAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_OTP_AUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitOtpAuthIntent"];
  };
  v1InitOtpAuthResult: {
    /** @description Unique identifier for an OTP authentication */
    otpId: string;
  };
  v1InitUserEmailRecoveryIntent: {
    /** @description Email of the user starting recovery */
    email: string;
    /** @description Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
    targetPublicKey: string;
    /** @description Expiration window (in seconds) indicating how long the recovery credential is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Optional parameters for customizing emails. If not provided, the default email will be used. */
    emailCustomization?: definitions["v1EmailCustomizationParams"];
  };
  v1InitUserEmailRecoveryRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1InitUserEmailRecoveryIntent"];
  };
  v1InitUserEmailRecoveryResult: {
    /** @description Unique identifier for the user being recovered. */
    userId: string;
  };
  v1Intent: {
    createOrganizationIntent?: definitions["v1CreateOrganizationIntent"];
    createAuthenticatorsIntent?: definitions["v1CreateAuthenticatorsIntent"];
    createUsersIntent?: definitions["v1CreateUsersIntent"];
    createPrivateKeysIntent?: definitions["v1CreatePrivateKeysIntent"];
    signRawPayloadIntent?: definitions["v1SignRawPayloadIntent"];
    createInvitationsIntent?: definitions["v1CreateInvitationsIntent"];
    acceptInvitationIntent?: definitions["v1AcceptInvitationIntent"];
    createPolicyIntent?: definitions["v1CreatePolicyIntent"];
    disablePrivateKeyIntent?: definitions["v1DisablePrivateKeyIntent"];
    deleteUsersIntent?: definitions["v1DeleteUsersIntent"];
    deleteAuthenticatorsIntent?: definitions["v1DeleteAuthenticatorsIntent"];
    deleteInvitationIntent?: definitions["v1DeleteInvitationIntent"];
    deleteOrganizationIntent?: definitions["v1DeleteOrganizationIntent"];
    deletePolicyIntent?: definitions["v1DeletePolicyIntent"];
    createUserTagIntent?: definitions["v1CreateUserTagIntent"];
    deleteUserTagsIntent?: definitions["v1DeleteUserTagsIntent"];
    signTransactionIntent?: definitions["v1SignTransactionIntent"];
    createApiKeysIntent?: definitions["v1CreateApiKeysIntent"];
    deleteApiKeysIntent?: definitions["v1DeleteApiKeysIntent"];
    approveActivityIntent?: definitions["v1ApproveActivityIntent"];
    rejectActivityIntent?: definitions["v1RejectActivityIntent"];
    createPrivateKeyTagIntent?: definitions["v1CreatePrivateKeyTagIntent"];
    deletePrivateKeyTagsIntent?: definitions["v1DeletePrivateKeyTagsIntent"];
    createPolicyIntentV2?: definitions["v1CreatePolicyIntentV2"];
    setPaymentMethodIntent?: definitions["billingSetPaymentMethodIntent"];
    activateBillingTierIntent?: definitions["billingActivateBillingTierIntent"];
    deletePaymentMethodIntent?: definitions["billingDeletePaymentMethodIntent"];
    createPolicyIntentV3?: definitions["v1CreatePolicyIntentV3"];
    createApiOnlyUsersIntent?: definitions["v1CreateApiOnlyUsersIntent"];
    updateRootQuorumIntent?: definitions["v1UpdateRootQuorumIntent"];
    updateUserTagIntent?: definitions["v1UpdateUserTagIntent"];
    updatePrivateKeyTagIntent?: definitions["v1UpdatePrivateKeyTagIntent"];
    createAuthenticatorsIntentV2?: definitions["v1CreateAuthenticatorsIntentV2"];
    acceptInvitationIntentV2?: definitions["v1AcceptInvitationIntentV2"];
    createOrganizationIntentV2?: definitions["v1CreateOrganizationIntentV2"];
    createUsersIntentV2?: definitions["v1CreateUsersIntentV2"];
    createSubOrganizationIntent?: definitions["v1CreateSubOrganizationIntent"];
    createSubOrganizationIntentV2?: definitions["v1CreateSubOrganizationIntentV2"];
    updateAllowedOriginsIntent?: definitions["v1UpdateAllowedOriginsIntent"];
    createPrivateKeysIntentV2?: definitions["v1CreatePrivateKeysIntentV2"];
    updateUserIntent?: definitions["v1UpdateUserIntent"];
    updatePolicyIntent?: definitions["v1UpdatePolicyIntent"];
    setPaymentMethodIntentV2?: definitions["billingSetPaymentMethodIntentV2"];
    createSubOrganizationIntentV3?: definitions["v1CreateSubOrganizationIntentV3"];
    createWalletIntent?: definitions["v1CreateWalletIntent"];
    createWalletAccountsIntent?: definitions["v1CreateWalletAccountsIntent"];
    initUserEmailRecoveryIntent?: definitions["v1InitUserEmailRecoveryIntent"];
    recoverUserIntent?: definitions["v1RecoverUserIntent"];
    setOrganizationFeatureIntent?: definitions["v1SetOrganizationFeatureIntent"];
    removeOrganizationFeatureIntent?: definitions["v1RemoveOrganizationFeatureIntent"];
    signRawPayloadIntentV2?: definitions["v1SignRawPayloadIntentV2"];
    signTransactionIntentV2?: definitions["v1SignTransactionIntentV2"];
    exportPrivateKeyIntent?: definitions["v1ExportPrivateKeyIntent"];
    exportWalletIntent?: definitions["v1ExportWalletIntent"];
    createSubOrganizationIntentV4?: definitions["v1CreateSubOrganizationIntentV4"];
    emailAuthIntent?: definitions["v1EmailAuthIntent"];
    exportWalletAccountIntent?: definitions["v1ExportWalletAccountIntent"];
    initImportWalletIntent?: definitions["v1InitImportWalletIntent"];
    importWalletIntent?: definitions["v1ImportWalletIntent"];
    initImportPrivateKeyIntent?: definitions["v1InitImportPrivateKeyIntent"];
    importPrivateKeyIntent?: definitions["v1ImportPrivateKeyIntent"];
    createPoliciesIntent?: definitions["v1CreatePoliciesIntent"];
    signRawPayloadsIntent?: definitions["v1SignRawPayloadsIntent"];
    createReadOnlySessionIntent?: definitions["v1CreateReadOnlySessionIntent"];
    createOauthProvidersIntent?: definitions["v1CreateOauthProvidersIntent"];
    deleteOauthProvidersIntent?: definitions["v1DeleteOauthProvidersIntent"];
    createSubOrganizationIntentV5?: definitions["v1CreateSubOrganizationIntentV5"];
    oauthIntent?: definitions["v1OauthIntent"];
    createApiKeysIntentV2?: definitions["v1CreateApiKeysIntentV2"];
    createReadWriteSessionIntent?: definitions["v1CreateReadWriteSessionIntent"];
    emailAuthIntentV2?: definitions["v1EmailAuthIntentV2"];
    createSubOrganizationIntentV6?: definitions["v1CreateSubOrganizationIntentV6"];
    deletePrivateKeysIntent?: definitions["v1DeletePrivateKeysIntent"];
    deleteWalletsIntent?: definitions["v1DeleteWalletsIntent"];
    createReadWriteSessionIntentV2?: definitions["v1CreateReadWriteSessionIntentV2"];
    deleteSubOrganizationIntent?: definitions["v1DeleteSubOrganizationIntent"];
    initOtpAuthIntent?: definitions["v1InitOtpAuthIntent"];
    otpAuthIntent?: definitions["v1OtpAuthIntent"];
    createSubOrganizationIntentV7?: definitions["v1CreateSubOrganizationIntentV7"];
    updateWalletIntent?: definitions["v1UpdateWalletIntent"];
  };
  v1Invitation: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description The name of the intended Invitation recipient. */
    receiverUserName: string;
    /** @description The email address of the intended Invitation recipient. */
    receiverEmail: string;
    /** @description A list of tags assigned to the Invitation recipient. */
    receiverUserTags: string[];
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description The current processing status of a specified Invitation. */
    status: definitions["v1InvitationStatus"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Unique identifier for the Sender of an Invitation. */
    senderUserId: string;
  };
  v1InvitationParams: {
    /** @description The name of the intended Invitation recipient. */
    receiverUserName: string;
    /** @description The email address of the intended Invitation recipient. */
    receiverUserEmail: string;
    /** @description A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
    receiverUserTags: string[];
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description Unique identifier for the Sender of an Invitation. */
    senderUserId: string;
  };
  /** @enum {string} */
  v1InvitationStatus:
    | "INVITATION_STATUS_CREATED"
    | "INVITATION_STATUS_ACCEPTED"
    | "INVITATION_STATUS_REVOKED";
  v1ListPrivateKeyTagsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1ListPrivateKeyTagsResponse: {
    /** @description A list of Private Key Tags */
    privateKeyTags: definitions["datav1Tag"][];
  };
  v1ListUserTagsRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1ListUserTagsResponse: {
    /** @description A list of User Tags */
    userTags: definitions["datav1Tag"][];
  };
  /** @enum {string} */
  v1MnemonicLanguage:
    | "MNEMONIC_LANGUAGE_ENGLISH"
    | "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
    | "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
    | "MNEMONIC_LANGUAGE_CZECH"
    | "MNEMONIC_LANGUAGE_FRENCH"
    | "MNEMONIC_LANGUAGE_ITALIAN"
    | "MNEMONIC_LANGUAGE_JAPANESE"
    | "MNEMONIC_LANGUAGE_KOREAN"
    | "MNEMONIC_LANGUAGE_SPANISH";
  v1NOOPCodegenAnchorResponse: {
    stamp: definitions["v1WebAuthnStamp"];
  };
  v1OauthIntent: {
    /** @description Base64 encoded OIDC token */
    oidcToken: string;
    /** @description Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
    targetPublicKey: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated Oauth API keys */
    invalidateExisting?: boolean;
  };
  v1OauthProvider: {
    /** @description Unique identifier for an OAuth Provider */
    providerId: string;
    /** @description Human-readable name to identify a Provider. */
    providerName: string;
    /** @description The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
    issuer: string;
    /** @description Expected audience ('aud' attribute of the signed token) which represents the app ID */
    audience: string;
    /** @description Expected subject ('sub' attribute of the signed token) which represents the user ID */
    subject: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1OauthProviderParams: {
    /** @description Human-readable name to identify a Provider. */
    providerName: string;
    /** @description Base64 encoded OIDC token */
    oidcToken: string;
  };
  v1OauthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OAUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OauthIntent"];
  };
  v1OauthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle: string;
  };
  /** @enum {string} */
  v1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL"
    | "OPERATOR_IN"
    | "OPERATOR_NOT_IN"
    | "OPERATOR_CONTAINS_ONE"
    | "OPERATOR_CONTAINS_ALL";
  v1OrganizationData: {
    organizationId?: string;
    name?: string;
    users?: definitions["v1User"][];
    policies?: definitions["v1Policy"][];
    privateKeys?: definitions["v1PrivateKey"][];
    invitations?: definitions["v1Invitation"][];
    tags?: definitions["datav1Tag"][];
    rootQuorum?: definitions["externaldatav1Quorum"];
    features?: definitions["v1Feature"][];
    wallets?: definitions["v1Wallet"][];
  };
  v1OtpAuthIntent: {
    /** @description ID representing the result of an init OTP activity. */
    otpId: string;
    /** @description 6 digit OTP code sent out to a user's contact (email or SMS) */
    otpCode: string;
    /** @description Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
    targetPublicKey?: string;
    /** @description Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
    apiKeyName?: string;
    /** @description Expiration window (in seconds) indicating how long the API key is valid. If not provided, a default of 15 minutes will be used. */
    expirationSeconds?: string;
    /** @description Invalidate all other previously generated OTP Auth API keys */
    invalidateExisting?: boolean;
  };
  v1OtpAuthRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_OTP_AUTH";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1OtpAuthIntent"];
  };
  v1OtpAuthResult: {
    /** @description Unique identifier for the authenticating User. */
    userId: string;
    /** @description Unique identifier for the created API key. */
    apiKeyId?: string;
    /** @description HPKE encrypted credential bundle */
    credentialBundle?: string;
  };
  v1Pagination: {
    /** @description A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
    limit?: string;
    /** @description A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
    before?: string;
    /** @description A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
    after?: string;
  };
  /** @enum {string} */
  v1PathFormat: "PATH_FORMAT_BIP32";
  /** @enum {string} */
  v1PayloadEncoding:
    | "PAYLOAD_ENCODING_HEXADECIMAL"
    | "PAYLOAD_ENCODING_TEXT_UTF8";
  v1Policy: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName: string;
    /** @description The instruction to DENY or ALLOW a particular activity following policy selector(s). */
    effect: definitions["v1Effect"];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description Human-readable notes added by a User to describe a particular policy. */
    notes: string;
    /** @description A consensus expression that evalutes to true or false. */
    consensus: string;
    /** @description A condition expression that evalutes to true or false. */
    condition: string;
  };
  v1PrivateKey: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description Derived cryptocurrency addresses for a given Private Key. */
    addresses: definitions["externaldatav1Address"][];
    /** @description A list of Private Key Tag IDs. */
    privateKeyTags: string[];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description True when a given Private Key is exported, false otherwise. */
    exported: boolean;
    /** @description True when a given Private Key is imported, false otherwise. */
    imported: boolean;
  };
  v1PrivateKeyParams: {
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    /** @description Cryptographic Curve used to generate a given Private Key. */
    curve: definitions["v1Curve"];
    /** @description A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
    privateKeyTags: string[];
    /** @description Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
    addressFormats: definitions["v1AddressFormat"][];
  };
  v1PrivateKeyResult: {
    privateKeyId?: string;
    addresses?: definitions["immutableactivityv1Address"][];
  };
  v1PublicKeyCredentialWithAttestation: {
    id: string;
    /** @enum {string} */
    type: "public-key";
    rawId: string;
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
    response: definitions["v1AuthenticatorAttestationResponse"];
    clientExtensionResults: definitions["v1SimpleClientExtensionResults"];
  };
  v1RecoverUserIntent: {
    /** @description The new authenticator to register. */
    authenticator: definitions["v1AuthenticatorParamsV2"];
    /** @description Unique identifier for the user performing recovery. */
    userId: string;
  };
  v1RecoverUserRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_RECOVER_USER";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RecoverUserIntent"];
  };
  v1RecoverUserResult: {
    /** @description ID of the authenticator created. */
    authenticatorId: string[];
  };
  v1RejectActivityIntent: {
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
  };
  v1RejectActivityRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REJECT_ACTIVITY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RejectActivityIntent"];
  };
  v1RemoveOrganizationFeatureIntent: {
    /** @description Name of the feature to remove */
    name: definitions["v1FeatureName"];
  };
  v1RemoveOrganizationFeatureRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1RemoveOrganizationFeatureIntent"];
  };
  v1RemoveOrganizationFeatureResult: {
    /** @description Resulting list of organization features. */
    features: definitions["v1Feature"][];
  };
  v1Result: {
    createOrganizationResult?: definitions["v1CreateOrganizationResult"];
    createAuthenticatorsResult?: definitions["v1CreateAuthenticatorsResult"];
    createUsersResult?: definitions["v1CreateUsersResult"];
    createPrivateKeysResult?: definitions["v1CreatePrivateKeysResult"];
    createInvitationsResult?: definitions["v1CreateInvitationsResult"];
    acceptInvitationResult?: definitions["v1AcceptInvitationResult"];
    signRawPayloadResult?: definitions["v1SignRawPayloadResult"];
    createPolicyResult?: definitions["v1CreatePolicyResult"];
    disablePrivateKeyResult?: definitions["v1DisablePrivateKeyResult"];
    deleteUsersResult?: definitions["v1DeleteUsersResult"];
    deleteAuthenticatorsResult?: definitions["v1DeleteAuthenticatorsResult"];
    deleteInvitationResult?: definitions["v1DeleteInvitationResult"];
    deleteOrganizationResult?: definitions["v1DeleteOrganizationResult"];
    deletePolicyResult?: definitions["v1DeletePolicyResult"];
    createUserTagResult?: definitions["v1CreateUserTagResult"];
    deleteUserTagsResult?: definitions["v1DeleteUserTagsResult"];
    signTransactionResult?: definitions["v1SignTransactionResult"];
    deleteApiKeysResult?: definitions["v1DeleteApiKeysResult"];
    createApiKeysResult?: definitions["v1CreateApiKeysResult"];
    createPrivateKeyTagResult?: definitions["v1CreatePrivateKeyTagResult"];
    deletePrivateKeyTagsResult?: definitions["v1DeletePrivateKeyTagsResult"];
    setPaymentMethodResult?: definitions["billingSetPaymentMethodResult"];
    activateBillingTierResult?: definitions["billingActivateBillingTierResult"];
    deletePaymentMethodResult?: definitions["billingDeletePaymentMethodResult"];
    createApiOnlyUsersResult?: definitions["v1CreateApiOnlyUsersResult"];
    updateRootQuorumResult?: definitions["v1UpdateRootQuorumResult"];
    updateUserTagResult?: definitions["v1UpdateUserTagResult"];
    updatePrivateKeyTagResult?: definitions["v1UpdatePrivateKeyTagResult"];
    createSubOrganizationResult?: definitions["v1CreateSubOrganizationResult"];
    updateAllowedOriginsResult?: definitions["v1UpdateAllowedOriginsResult"];
    createPrivateKeysResultV2?: definitions["v1CreatePrivateKeysResultV2"];
    updateUserResult?: definitions["v1UpdateUserResult"];
    updatePolicyResult?: definitions["v1UpdatePolicyResult"];
    createSubOrganizationResultV3?: definitions["v1CreateSubOrganizationResultV3"];
    createWalletResult?: definitions["v1CreateWalletResult"];
    createWalletAccountsResult?: definitions["v1CreateWalletAccountsResult"];
    initUserEmailRecoveryResult?: definitions["v1InitUserEmailRecoveryResult"];
    recoverUserResult?: definitions["v1RecoverUserResult"];
    setOrganizationFeatureResult?: definitions["v1SetOrganizationFeatureResult"];
    removeOrganizationFeatureResult?: definitions["v1RemoveOrganizationFeatureResult"];
    exportPrivateKeyResult?: definitions["v1ExportPrivateKeyResult"];
    exportWalletResult?: definitions["v1ExportWalletResult"];
    createSubOrganizationResultV4?: definitions["v1CreateSubOrganizationResultV4"];
    emailAuthResult?: definitions["v1EmailAuthResult"];
    exportWalletAccountResult?: definitions["v1ExportWalletAccountResult"];
    initImportWalletResult?: definitions["v1InitImportWalletResult"];
    importWalletResult?: definitions["v1ImportWalletResult"];
    initImportPrivateKeyResult?: definitions["v1InitImportPrivateKeyResult"];
    importPrivateKeyResult?: definitions["v1ImportPrivateKeyResult"];
    createPoliciesResult?: definitions["v1CreatePoliciesResult"];
    signRawPayloadsResult?: definitions["v1SignRawPayloadsResult"];
    createReadOnlySessionResult?: definitions["v1CreateReadOnlySessionResult"];
    createOauthProvidersResult?: definitions["v1CreateOauthProvidersResult"];
    deleteOauthProvidersResult?: definitions["v1DeleteOauthProvidersResult"];
    createSubOrganizationResultV5?: definitions["v1CreateSubOrganizationResultV5"];
    oauthResult?: definitions["v1OauthResult"];
    createReadWriteSessionResult?: definitions["v1CreateReadWriteSessionResult"];
    createSubOrganizationResultV6?: definitions["v1CreateSubOrganizationResultV6"];
    deletePrivateKeysResult?: definitions["v1DeletePrivateKeysResult"];
    deleteWalletsResult?: definitions["v1DeleteWalletsResult"];
    createReadWriteSessionResultV2?: definitions["v1CreateReadWriteSessionResultV2"];
    deleteSubOrganizationResult?: definitions["v1DeleteSubOrganizationResult"];
    initOtpAuthResult?: definitions["v1InitOtpAuthResult"];
    otpAuthResult?: definitions["v1OtpAuthResult"];
    createSubOrganizationResultV7?: definitions["v1CreateSubOrganizationResultV7"];
    updateWalletResult?: definitions["v1UpdateWalletResult"];
  };
  v1RootUserParams: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
  };
  v1RootUserParamsV2: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1RootUserParamsV3: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1RootUserParamsV4: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKeyParamsV2"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
    oauthProviders: definitions["v1OauthProviderParams"][];
  };
  v1Selector: {
    subject?: string;
    operator?: definitions["v1Operator"];
    target?: string;
  };
  v1SelectorV2: {
    subject?: string;
    operator?: definitions["v1Operator"];
    targets?: string[];
  };
  v1SetOrganizationFeatureIntent: {
    /** @description Name of the feature to set */
    name: definitions["v1FeatureName"];
    /** @description Optional value for the feature. Will override existing values if feature is already set. */
    value: string;
  };
  v1SetOrganizationFeatureRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SetOrganizationFeatureIntent"];
  };
  v1SetOrganizationFeatureResult: {
    /** @description Resulting list of organization features. */
    features: definitions["v1Feature"][];
  };
  v1SignRawPayloadIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Raw unsigned payload to be signed. */
    payload: string;
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadIntentV2: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description Raw unsigned payload to be signed. */
    payload: string;
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignRawPayloadIntentV2"];
  };
  v1SignRawPayloadResult: {
    /** @description Component of an ECSDA signature. */
    r: string;
    /** @description Component of an ECSDA signature. */
    s: string;
    /** @description Component of an ECSDA signature. */
    v: string;
  };
  v1SignRawPayloadsIntent: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description An array of raw unsigned payloads to be signed. */
    payloads: string[];
    /** @description Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
    encoding: definitions["v1PayloadEncoding"];
    /** @description Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignRawPayloadsIntent"];
  };
  v1SignRawPayloadsResult: {
    signatures?: definitions["v1SignRawPayloadResult"][];
  };
  v1SignTransactionIntent: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description Raw unsigned transaction to be signed by a particular Private Key. */
    unsignedTransaction: string;
    type: definitions["v1TransactionType"];
  };
  v1SignTransactionIntentV2: {
    /** @description A Wallet account address, Private Key address, or Private Key identifier. */
    signWith: string;
    /** @description Raw unsigned transaction to be signed */
    unsignedTransaction: string;
    type: definitions["v1TransactionType"];
  };
  v1SignTransactionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignTransactionIntentV2"];
  };
  v1SignTransactionResult: {
    signedTransaction: string;
  };
  v1SimpleClientExtensionResults: {
    appid?: boolean;
    appidExclude?: boolean;
    credProps?: definitions["v1CredPropsAuthenticationExtensionsClientOutputs"];
  };
  v1SmsCustomizationParams: {
    /** @description Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
    template?: string;
  };
  /** @enum {string} */
  v1TagType: "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";
  v1TestRateLimitsRequest: {
    /** @description Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
    organizationId: string;
    /** @description Whether or not to set a limit on this request. */
    isSetLimit: boolean;
    /**
     * Format: int64
     * @description Rate limit to set for org, if is_set_limit is set to true
     */
    limit: number;
  };
  v1TestRateLimitsResponse: { [key: string]: unknown };
  /** @enum {string} */
  v1TransactionType: "TRANSACTION_TYPE_ETHEREUM" | "TRANSACTION_TYPE_SOLANA";
  v1UpdateAllowedOriginsIntent: {
    /** @description Additional origins requests are allowed from besides Turnkey origins */
    allowedOrigins: string[];
  };
  v1UpdateAllowedOriginsResult: { [key: string]: unknown };
  v1UpdatePolicyIntent: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName?: string;
    /** @description The instruction to DENY or ALLOW an activity (optional). */
    policyEffect?: definitions["v1Effect"];
    /** @description The condition expression that triggers the Effect (optional). */
    policyCondition?: string;
    /** @description The consensus expression that triggers the Effect (optional). */
    policyConsensus?: string;
    /** @description Accompanying notes for a Policy (optional). */
    policyNotes?: string;
  };
  v1UpdatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_POLICY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdatePolicyIntent"];
  };
  v1UpdatePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1UpdatePrivateKeyTagIntent: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
    /** @description The new, human-readable name for the tag with the given ID. */
    newPrivateKeyTagName?: string;
    /** @description A list of Private Keys IDs to add this tag to. */
    addPrivateKeyIds: string[];
    /** @description A list of Private Key IDs to remove this tag from. */
    removePrivateKeyIds: string[];
  };
  v1UpdatePrivateKeyTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdatePrivateKeyTagIntent"];
  };
  v1UpdatePrivateKeyTagResult: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
  };
  v1UpdateRootQuorumIntent: {
    /**
     * Format: int32
     * @description The threshold of unique approvals to reach quorum.
     */
    threshold: number;
    /** @description The unique identifiers of users who comprise the quorum set. */
    userIds: string[];
  };
  v1UpdateRootQuorumRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateRootQuorumIntent"];
  };
  v1UpdateRootQuorumResult: { [key: string]: unknown };
  v1UpdateUserIntent: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName?: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
    userTagIds?: string[];
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
  };
  v1UpdateUserRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserIntent"];
  };
  v1UpdateUserResult: {
    /** @description A User ID. */
    userId: string;
  };
  v1UpdateUserTagIntent: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
    /** @description The new, human-readable name for the tag with the given ID. */
    newUserTagName?: string;
    /** @description A list of User IDs to add this tag to. */
    addUserIds: string[];
    /** @description A list of User IDs to remove this tag from. */
    removeUserIds: string[];
  };
  v1UpdateUserTagRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_USER_TAG";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateUserTagIntent"];
  };
  v1UpdateUserTagResult: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
  };
  v1UpdateWalletIntent: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Human-readable name for a Wallet. */
    walletName?: string;
  };
  v1UpdateWalletRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_UPDATE_WALLET";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1UpdateWalletIntent"];
  };
  v1UpdateWalletResult: {
    /** @description A Wallet ID. */
    walletId: string;
  };
  v1User: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The user's phone number in E.164 format e.g. +13214567890 */
    userPhoneNumber?: string;
    /** @description A list of Authenticator parameters. */
    authenticators: definitions["v1Authenticator"][];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["v1ApiKey"][];
    /** @description A list of User Tag IDs. */
    userTags: string[];
    /** @description A list of Oauth Providers. */
    oauthProviders: definitions["v1OauthProvider"][];
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1UserParams: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description The User's permissible access method(s). */
    accessType: definitions["v1AccessType"];
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParams"][];
    /** @description A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
  };
  v1UserParamsV2: {
    /** @description Human-readable name for a User. */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    /** @description A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
    apiKeys: definitions["apiApiKeyParams"][];
    /** @description A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
    authenticators: definitions["v1AuthenticatorParamsV2"][];
    /** @description A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
    userTags: string[];
  };
  v1Vote: {
    /** @description Unique identifier for a given Vote object. */
    id: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Web and/or API user within your Organization. */
    user: definitions["v1User"];
    /** @description Unique identifier for a given Activity object. */
    activityId: string;
    /** @enum {string} */
    selection: "VOTE_SELECTION_APPROVED" | "VOTE_SELECTION_REJECTED";
    /** @description The raw message being signed within a Vote. */
    message: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description The signature applied to a particular vote. */
    signature: string;
    /** @description Method used to produce a signature. */
    scheme: string;
    createdAt: definitions["externaldatav1Timestamp"];
  };
  v1Wallet: {
    /** @description Unique identifier for a given Wallet. */
    walletId: string;
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
    /** @description True when a given Wallet is exported, false otherwise. */
    exported: boolean;
    /** @description True when a given Wallet is imported, false otherwise. */
    imported: boolean;
  };
  v1WalletAccount: {
    /** @description Unique identifier for a given Wallet Account. */
    walletAccountId: string;
    /** @description The Organization the Account belongs to. */
    organizationId: string;
    /** @description The Wallet the Account was derived from. */
    walletId: string;
    /** @description Cryptographic curve used to generate the Account. */
    curve: definitions["v1Curve"];
    /** @description Path format used to generate the Account. */
    pathFormat: definitions["v1PathFormat"];
    /** @description Path used to generate the Account. */
    path: string;
    /** @description Address format used to generate the Acccount. */
    addressFormat: definitions["v1AddressFormat"];
    /** @description Address generated using the Wallet seed and Account parameters. */
    address: string;
    createdAt: definitions["externaldatav1Timestamp"];
    updatedAt: definitions["externaldatav1Timestamp"];
  };
  v1WalletAccountParams: {
    /** @description Cryptographic curve used to generate a wallet Account. */
    curve: definitions["v1Curve"];
    /** @description Path format used to generate a wallet Account. */
    pathFormat: definitions["v1PathFormat"];
    /** @description Path used to generate a wallet Account. */
    path: string;
    /** @description Address format used to generate a wallet Acccount. */
    addressFormat: definitions["v1AddressFormat"];
  };
  v1WalletParams: {
    /** @description Human-readable name for a Wallet. */
    walletName: string;
    /** @description A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
    accounts: definitions["v1WalletAccountParams"][];
    /**
     * Format: int32
     * @description Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
     */
    mnemonicLength?: number;
  };
  v1WalletResult: {
    walletId: string;
    /** @description A list of account addresses. */
    addresses: string[];
  };
  v1WebAuthnStamp: {
    /** @description A base64 url encoded Unique identifier for a given credential. */
    credentialId: string;
    /** @description A base64 encoded payload containing metadata about the signing context and the challenge. */
    clientDataJson: string;
    /** @description A base64 encoded payload containing metadata about the authenticator. */
    authenticatorData: string;
    /** @description The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
    signature: string;
  };
};

export type operations = {
  /** Get details about an Activity */
  PublicApiService_GetActivity: {
    parameters: {
      body: {
        body: definitions["v1GetActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an API key */
  PublicApiService_GetApiKey: {
    parameters: {
      body: {
        body: definitions["v1GetApiKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetApiKeyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about API keys for a user */
  PublicApiService_GetApiKeys: {
    parameters: {
      body: {
        body: definitions["v1GetApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetApiKeysResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get the attestation document corresponding to an enclave. */
  PublicApiService_GetAttestationDocument: {
    parameters: {
      body: {
        body: definitions["v1GetAttestationDocumentRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAttestationDocumentResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an authenticator */
  PublicApiService_GetAuthenticator: {
    parameters: {
      body: {
        body: definitions["v1GetAuthenticatorRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAuthenticatorResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about authenticators for a user */
  PublicApiService_GetAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1GetAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetAuthenticatorsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about Oauth providers for a user */
  PublicApiService_GetOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1GetOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOauthProvidersResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an Organization */
  PublicApiService_GetOrganization: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get quorum settings and features for an organization */
  PublicApiService_GetOrganizationConfigs: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationConfigsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationConfigsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Policy */
  PublicApiService_GetPolicy: {
    parameters: {
      body: {
        body: definitions["v1GetPolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPolicyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Private Key */
  PublicApiService_GetPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeyResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a User */
  PublicApiService_GetUser: {
    parameters: {
      body: {
        body: definitions["v1GetUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUserResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Wallet */
  PublicApiService_GetWallet: {
    parameters: {
      body: {
        body: definitions["v1GetWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get a single wallet account */
  PublicApiService_GetWalletAccount: {
    parameters: {
      body: {
        body: definitions["v1GetWalletAccountRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletAccountResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Activities within an Organization */
  PublicApiService_GetActivities: {
    parameters: {
      body: {
        body: definitions["v1GetActivitiesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetActivitiesResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Policies within an Organization */
  PublicApiService_GetPolicies: {
    parameters: {
      body: {
        body: definitions["v1GetPoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPoliciesResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Private Key Tags within an Organization */
  PublicApiService_ListPrivateKeyTags: {
    parameters: {
      body: {
        body: definitions["v1ListPrivateKeyTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ListPrivateKeyTagsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Private Keys within an Organization */
  PublicApiService_GetPrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeysResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get all suborg IDs associated given a parent org ID and an optional filter. */
  PublicApiService_GetSubOrgIds: {
    parameters: {
      body: {
        body: definitions["v1GetSubOrgIdsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetSubOrgIdsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all User Tags within an Organization */
  PublicApiService_ListUserTags: {
    parameters: {
      body: {
        body: definitions["v1ListUserTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ListUserTagsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Users within an Organization */
  PublicApiService_GetUsers: {
    parameters: {
      body: {
        body: definitions["v1GetUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUsersResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get all email or phone verified suborg IDs associated given a parent org ID. */
  PublicApiService_GetVerifiedSubOrgIds: {
    parameters: {
      body: {
        body: definitions["v1GetVerifiedSubOrgIdsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetVerifiedSubOrgIdsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Accounts within a Wallet */
  PublicApiService_GetWalletAccounts: {
    parameters: {
      body: {
        body: definitions["v1GetWalletAccountsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletAccountsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Wallets within an Organization */
  PublicApiService_GetWallets: {
    parameters: {
      body: {
        body: definitions["v1GetWalletsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWalletsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get basic information about your current API or WebAuthN user and their organization. Affords Sub-Organization look ups via Parent Organization for WebAuthN or API key users. */
  PublicApiService_GetWhoami: {
    parameters: {
      body: {
        body: definitions["v1GetWhoamiRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWhoamiResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Approve an Activity */
  PublicApiService_ApproveActivity: {
    parameters: {
      body: {
        body: definitions["v1ApproveActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Add api keys to an existing User */
  PublicApiService_CreateApiKeys: {
    parameters: {
      body: {
        body: definitions["v1CreateApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create API-only Users in an existing Organization */
  PublicApiService_CreateApiOnlyUsers: {
    parameters: {
      body: {
        body: definitions["v1CreateApiOnlyUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Authenticators to authenticate requests to Turnkey */
  PublicApiService_CreateAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1CreateAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Invitations to join an existing Organization */
  PublicApiService_CreateInvitations: {
    parameters: {
      body: {
        body: definitions["v1CreateInvitationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Creates Oauth providers for a specified user - BETA */
  PublicApiService_CreateOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1CreateOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new Policies */
  PublicApiService_CreatePolicies: {
    parameters: {
      body: {
        body: definitions["v1CreatePoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new Policy */
  PublicApiService_CreatePolicy: {
    parameters: {
      body: {
        body: definitions["v1CreatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a private key tag and add it to private keys. */
  PublicApiService_CreatePrivateKeyTag: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeyTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new Private Keys */
  PublicApiService_CreatePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a read only session for a user (valid for 1 hour) */
  PublicApiService_CreateReadOnlySession: {
    parameters: {
      body: {
        body: definitions["v1CreateReadOnlySessionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a read write session for a user */
  PublicApiService_CreateReadWriteSession: {
    parameters: {
      body: {
        body: definitions["v1CreateReadWriteSessionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new Sub-Organization */
  PublicApiService_CreateSubOrganization: {
    parameters: {
      body: {
        body: definitions["v1CreateSubOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a user tag and add it to users. */
  PublicApiService_CreateUserTag: {
    parameters: {
      body: {
        body: definitions["v1CreateUserTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Users in an existing Organization */
  PublicApiService_CreateUsers: {
    parameters: {
      body: {
        body: definitions["v1CreateUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a Wallet and derive addresses */
  PublicApiService_CreateWallet: {
    parameters: {
      body: {
        body: definitions["v1CreateWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Derive additional addresses using an existing wallet */
  PublicApiService_CreateWalletAccounts: {
    parameters: {
      body: {
        body: definitions["v1CreateWalletAccountsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove api keys from a User */
  PublicApiService_DeleteApiKeys: {
    parameters: {
      body: {
        body: definitions["v1DeleteApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove authenticators from a User */
  PublicApiService_DeleteAuthenticators: {
    parameters: {
      body: {
        body: definitions["v1DeleteAuthenticatorsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Invitation */
  PublicApiService_DeleteInvitation: {
    parameters: {
      body: {
        body: definitions["v1DeleteInvitationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Removes Oauth providers for a specified user - BETA */
  PublicApiService_DeleteOauthProviders: {
    parameters: {
      body: {
        body: definitions["v1DeleteOauthProvidersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Policy */
  PublicApiService_DeletePolicy: {
    parameters: {
      body: {
        body: definitions["v1DeletePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete Private Key Tags within an Organization */
  PublicApiService_DeletePrivateKeyTags: {
    parameters: {
      body: {
        body: definitions["v1DeletePrivateKeyTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Deletes private keys for an organization */
  PublicApiService_DeletePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1DeletePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Deletes a sub organization */
  PublicApiService_DeleteSubOrganization: {
    parameters: {
      body: {
        body: definitions["v1DeleteSubOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete User Tags within an Organization */
  PublicApiService_DeleteUserTags: {
    parameters: {
      body: {
        body: definitions["v1DeleteUserTagsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete Users within an Organization */
  PublicApiService_DeleteUsers: {
    parameters: {
      body: {
        body: definitions["v1DeleteUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Deletes wallets for an organization */
  PublicApiService_DeleteWallets: {
    parameters: {
      body: {
        body: definitions["v1DeleteWalletsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user via Email */
  PublicApiService_EmailAuth: {
    parameters: {
      body: {
        body: definitions["v1EmailAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Exports a Private Key */
  PublicApiService_ExportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1ExportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Exports a Wallet */
  PublicApiService_ExportWallet: {
    parameters: {
      body: {
        body: definitions["v1ExportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Exports a Wallet Account */
  PublicApiService_ExportWalletAccount: {
    parameters: {
      body: {
        body: definitions["v1ExportWalletAccountRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Imports a private key */
  PublicApiService_ImportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1ImportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Imports a wallet */
  PublicApiService_ImportWallet: {
    parameters: {
      body: {
        body: definitions["v1ImportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initializes a new private key import */
  PublicApiService_InitImportPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1InitImportPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initializes a new wallet import */
  PublicApiService_InitImportWallet: {
    parameters: {
      body: {
        body: definitions["v1InitImportWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initiate an OTP auth activity */
  PublicApiService_InitOtpAuth: {
    parameters: {
      body: {
        body: definitions["v1InitOtpAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Initializes a new email recovery */
  PublicApiService_InitUserEmailRecovery: {
    parameters: {
      body: {
        body: definitions["v1InitUserEmailRecoveryRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user with an Oidc token (Oauth) - BETA */
  PublicApiService_Oauth: {
    parameters: {
      body: {
        body: definitions["v1OauthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Authenticate a user with an OTP code sent via email or SMS */
  PublicApiService_OtpAuth: {
    parameters: {
      body: {
        body: definitions["v1OtpAuthRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Completes the process of recovering a user by adding an authenticator */
  PublicApiService_RecoverUser: {
    parameters: {
      body: {
        body: definitions["v1RecoverUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Reject an Activity */
  PublicApiService_RejectActivity: {
    parameters: {
      body: {
        body: definitions["v1RejectActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Removes an organization feature. This activity must be approved by the current root quorum. */
  PublicApiService_RemoveOrganizationFeature: {
    parameters: {
      body: {
        body: definitions["v1RemoveOrganizationFeatureRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sets an organization feature. This activity must be approved by the current root quorum. */
  PublicApiService_SetOrganizationFeature: {
    parameters: {
      body: {
        body: definitions["v1SetOrganizationFeatureRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a raw payload */
  PublicApiService_SignRawPayload: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign multiple raw payloads with the same signing parameters */
  PublicApiService_SignRawPayloads: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a transaction */
  PublicApiService_SignTransaction: {
    parameters: {
      body: {
        body: definitions["v1SignTransactionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update an existing Policy */
  PublicApiService_UpdatePolicy: {
    parameters: {
      body: {
        body: definitions["v1UpdatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
  PublicApiService_UpdatePrivateKeyTag: {
    parameters: {
      body: {
        body: definitions["v1UpdatePrivateKeyTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Set the threshold and members of the root quorum. This activity must be approved by the current root quorum. */
  PublicApiService_UpdateRootQuorum: {
    parameters: {
      body: {
        body: definitions["v1UpdateRootQuorumRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a User in an existing Organization */
  PublicApiService_UpdateUser: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail. */
  PublicApiService_UpdateUserTag: {
    parameters: {
      body: {
        body: definitions["v1UpdateUserTagRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Update a wallet for an organization */
  PublicApiService_UpdateWallet: {
    parameters: {
      body: {
        body: definitions["v1UpdateWalletRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  PublicApiService_NOOPCodegenAnchor: {
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1NOOPCodegenAnchorResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Set a rate local rate limit just on the current endpoint, for purposes of testing with Vivosuite */
  PublicApiService_TestRateLimits: {
    parameters: {
      body: {
        body: definitions["v1TestRateLimitsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1TestRateLimitsResponse"];
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
};

export type external = {};
