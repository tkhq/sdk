/* @generated by codegen. DO NOT EDIT BY HAND */

import {
  TERMINAL_ACTIVITY_STATUSES,
  TActivityResponse,
  TActivityStatus,
  TSignedRequest,
} from "@turnkey/http";

import type { definitions } from "../__inputs__/public_api.types";

import {
  GrpcStatus,
  TStamper,
  TurnkeyRequestError,
  TurnkeyHttpClientConfig,
} from "../__types__/base";

import { VERSION } from "../__generated__/version";

import type * as SdkTypes from "@turnkey/sdk-types";

import { StorageBase } from "../__storage__/base";

import { parseSession } from "../utils";

import { StamperType } from "../__types__/base";

export class TurnkeySDKClientBase {
  config: TurnkeyHttpClientConfig;

  // Store stampers
  private apiKeyStamper?: TStamper | undefined;
  private passkeyStamper?: TStamper | undefined;

  // Storage manager
  private storageManager?: StorageBase | undefined;

  constructor(config: TurnkeyHttpClientConfig) {
    this.config = config;

    if (config.apiKeyStamper) {
      this.apiKeyStamper = config.apiKeyStamper;
    }
    if (config.passkeyStamper) {
      this.passkeyStamper = config.passkeyStamper;
    }
    if (config.storageManager) {
      this.storageManager = config.storageManager;
    }
  }

  private getStamper(stampWith?: StamperType): TStamper | undefined {
    if (!stampWith) return this.apiKeyStamper || this.passkeyStamper;

    switch (stampWith) {
      case StamperType.ApiKey:
        return this.apiKeyStamper;
      case StamperType.Passkey:
        return this.passkeyStamper;
      default:
        return this.apiKeyStamper;
    }
  }

  async request<TBodyType, TResponseType>(
    url: string,
    body: TBodyType,
    stampWith?: StamperType,
  ): Promise<TResponseType> {
    const fullUrl = this.config.apiBaseUrl + url;
    const stringifiedBody = JSON.stringify(body);
    var headers: Record<string, string> = {
      "X-Client-Version": VERSION,
    };

    // Use the specified stamper for this request
    const activeStamper = this.getStamper(stampWith);

    if (activeStamper) {
      const stamp = await activeStamper.stamp(stringifiedBody);
      headers[stamp.stampHeaderName] = stamp.stampHeaderValue;
    }

    if (this.config.readOnlySession) {
      headers["X-Session"] = this.config.readOnlySession;
    }

    const response = await fetch(fullUrl, {
      method: "POST",
      headers: headers,
      body: stringifiedBody,
      redirect: "follow",
    });

    if (!response.ok) {
      let res: GrpcStatus;
      try {
        res = await response.json();
      } catch (_) {
        throw new Error(`${response.status} ${response.statusText}`);
      }

      throw new TurnkeyRequestError(res);
    }

    const data = await response.json();
    return data as TResponseType;
  }

  async command<TBodyType, TResponseType>(
    url: string,
    body: TBodyType,
    resultKey: string,
    stampWith?: StamperType,
  ): Promise<TResponseType> {
    const pollingDuration = this.config.activityPoller?.intervalMs ?? 1000;
    const maxRetries = this.config.activityPoller?.numRetries ?? 3;

    const sleep = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));

    const handleResponse = (activityData: TActivityResponse): TResponseType => {
      const { result, status } = activityData.activity;

      if (status === "ACTIVITY_STATUS_COMPLETED") {
        return {
          ...result[`${resultKey}` as keyof definitions["v1Result"]],
          ...activityData,
        } as TResponseType;
      }

      return activityData as TResponseType;
    };

    let attempts = 0;

    const pollStatus = async (activityId: string): Promise<TResponseType> => {
      const pollBody = { activityId };
      // Pass the stampWith parameter to getActivity
      const pollData = (await this.getActivity(
        pollBody,
        stampWith,
      )) as TActivityResponse;

      if (attempts > maxRetries) {
        return handleResponse(pollData);
      }

      attempts += 1;

      if (
        !TERMINAL_ACTIVITY_STATUSES.includes(
          pollData.activity.status as TActivityStatus,
        )
      ) {
        await sleep(pollingDuration);
        return pollStatus(activityId);
      }

      return handleResponse(pollData);
    };

    // Use the specified stamper for the initial request
    const responseData = (await this.request<TBodyType, TResponseType>(
      url,
      body,
      stampWith,
    )) as TActivityResponse;

    if (
      !TERMINAL_ACTIVITY_STATUSES.includes(
        responseData.activity.status as TActivityStatus,
      )
    ) {
      return pollStatus(responseData.activity.id);
    }

    return handleResponse(responseData);
  }

  async activityDecision<TBodyType, TResponseType>(
    url: string,
    body: TBodyType,
    stampWith?: StamperType,
  ): Promise<TResponseType> {
    // Use the specified stamper for this request
    const activityData = (await this.request(
      url,
      body,
      stampWith,
    )) as TActivityResponse;

    return {
      ...activityData["activity"]["result"],
      ...activityData,
    } as TResponseType;
  }

  getActivity = async (
    input: SdkTypes.TGetActivityBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetActivityResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_activity",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetActivity = async (
    input: SdkTypes.TGetActivityBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_activity";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getApiKey = async (
    input: SdkTypes.TGetApiKeyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetApiKeyResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_api_key",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetApiKey = async (
    input: SdkTypes.TGetApiKeyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_key";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getApiKeys = async (
    input: SdkTypes.TGetApiKeysBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetApiKeysResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_api_keys",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetApiKeys = async (
    input: SdkTypes.TGetApiKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getAttestationDocument = async (
    input: SdkTypes.TGetAttestationDocumentBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetAttestationDocumentResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_attestation",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetAttestationDocument = async (
    input: SdkTypes.TGetAttestationDocumentBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_attestation";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getAuthenticator = async (
    input: SdkTypes.TGetAuthenticatorBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetAuthenticatorResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_authenticator",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetAuthenticator = async (
    input: SdkTypes.TGetAuthenticatorBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_authenticator";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getAuthenticators = async (
    input: SdkTypes.TGetAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetAuthenticatorsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_authenticators",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetAuthenticators = async (
    input: SdkTypes.TGetAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_authenticators";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getOauthProviders = async (
    input: SdkTypes.TGetOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetOauthProvidersResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_oauth_providers",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetOauthProviders = async (
    input: SdkTypes.TGetOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_oauth_providers";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getOrganization = async (
    input: SdkTypes.TGetOrganizationBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetOrganizationResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_organization",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetOrganization = async (
    input: SdkTypes.TGetOrganizationBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_organization";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getOrganizationConfigs = async (
    input: SdkTypes.TGetOrganizationConfigsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetOrganizationConfigsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_organization_configs",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetOrganizationConfigs = async (
    input: SdkTypes.TGetOrganizationConfigsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_organization_configs";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getPolicy = async (
    input: SdkTypes.TGetPolicyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetPolicyResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_policy",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetPolicy = async (
    input: SdkTypes.TGetPolicyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_policy";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getPrivateKey = async (
    input: SdkTypes.TGetPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetPrivateKeyResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_private_key",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetPrivateKey = async (
    input: SdkTypes.TGetPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_private_key";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getUser = async (
    input: SdkTypes.TGetUserBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetUserResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_user",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetUser = async (
    input: SdkTypes.TGetUserBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_user";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getWallet = async (
    input: SdkTypes.TGetWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetWalletResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_wallet",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetWallet = async (
    input: SdkTypes.TGetWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getWalletAccount = async (
    input: SdkTypes.TGetWalletAccountBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetWalletAccountResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/get_wallet_account",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetWalletAccount = async (
    input: SdkTypes.TGetWalletAccountBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/get_wallet_account";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getActivities = async (
    input: SdkTypes.TGetActivitiesBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetActivitiesResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_activities",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetActivities = async (
    input: SdkTypes.TGetActivitiesBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_activities";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getPolicies = async (
    input: SdkTypes.TGetPoliciesBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetPoliciesResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_policies",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetPolicies = async (
    input: SdkTypes.TGetPoliciesBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_policies";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  listPrivateKeyTags = async (
    input: SdkTypes.TListPrivateKeyTagsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TListPrivateKeyTagsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_private_key_tags",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampListPrivateKeyTags = async (
    input: SdkTypes.TListPrivateKeyTagsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/list_private_key_tags";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getPrivateKeys = async (
    input: SdkTypes.TGetPrivateKeysBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetPrivateKeysResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_private_keys",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetPrivateKeys = async (
    input: SdkTypes.TGetPrivateKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/list_private_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getSubOrgIds = async (
    input: SdkTypes.TGetSubOrgIdsBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetSubOrgIdsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_suborgs",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetSubOrgIds = async (
    input: SdkTypes.TGetSubOrgIdsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_suborgs";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  listUserTags = async (
    input: SdkTypes.TListUserTagsBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TListUserTagsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_user_tags",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampListUserTags = async (
    input: SdkTypes.TListUserTagsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_user_tags";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getUsers = async (
    input: SdkTypes.TGetUsersBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetUsersResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_users",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetUsers = async (
    input: SdkTypes.TGetUsersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_users";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getVerifiedSubOrgIds = async (
    input: SdkTypes.TGetVerifiedSubOrgIdsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetVerifiedSubOrgIdsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_verified_suborgs",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetVerifiedSubOrgIds = async (
    input: SdkTypes.TGetVerifiedSubOrgIdsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/list_verified_suborgs";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getWalletAccounts = async (
    input: SdkTypes.TGetWalletAccountsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetWalletAccountsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_wallet_accounts",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetWalletAccounts = async (
    input: SdkTypes.TGetWalletAccountsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/query/list_wallet_accounts";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getWallets = async (
    input: SdkTypes.TGetWalletsBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetWalletsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/list_wallets",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetWallets = async (
    input: SdkTypes.TGetWalletsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_wallets";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  getWhoami = async (
    input: SdkTypes.TGetWhoamiBody = {},
    stampWith?: StamperType,
  ): Promise<SdkTypes.TGetWhoamiResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/public/v1/query/whoami",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampGetWhoami = async (
    input: SdkTypes.TGetWhoamiBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/query/whoami";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  approveActivity = async (
    input: SdkTypes.TApproveActivityBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TApproveActivityResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.activityDecision(
      "/public/v1/submit/approve_activity",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_APPROVE_ACTIVITY",
      },
      stampWith,
    );
  };

  stampApproveActivity = async (
    input: SdkTypes.TApproveActivityBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/approve_activity";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createApiKeys = async (
    input: SdkTypes.TCreateApiKeysBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateApiKeysResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_api_keys",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
      },
      "createApiKeysResult",
      stampWith,
    );
  };

  stampCreateApiKeys = async (
    input: SdkTypes.TCreateApiKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_api_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createApiOnlyUsers = async (
    input: SdkTypes.TCreateApiOnlyUsersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateApiOnlyUsersResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_api_only_users",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS",
      },
      "createApiOnlyUsersResult",
      stampWith,
    );
  };

  stampCreateApiOnlyUsers = async (
    input: SdkTypes.TCreateApiOnlyUsersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_api_only_users";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createAuthenticators = async (
    input: SdkTypes.TCreateAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateAuthenticatorsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_authenticators",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
      },
      "createAuthenticatorsResult",
      stampWith,
    );
  };

  stampCreateAuthenticators = async (
    input: SdkTypes.TCreateAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_authenticators";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createInvitations = async (
    input: SdkTypes.TCreateInvitationsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateInvitationsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_invitations",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_INVITATIONS",
      },
      "createInvitationsResult",
      stampWith,
    );
  };

  stampCreateInvitations = async (
    input: SdkTypes.TCreateInvitationsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_invitations";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createOauthProviders = async (
    input: SdkTypes.TCreateOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateOauthProvidersResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_oauth_providers",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS",
      },
      "createOauthProvidersResult",
      stampWith,
    );
  };

  stampCreateOauthProviders = async (
    input: SdkTypes.TCreateOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_oauth_providers";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createPolicies = async (
    input: SdkTypes.TCreatePoliciesBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreatePoliciesResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_policies",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_POLICIES",
      },
      "createPoliciesResult",
      stampWith,
    );
  };

  stampCreatePolicies = async (
    input: SdkTypes.TCreatePoliciesBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_policies";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createPolicy = async (
    input: SdkTypes.TCreatePolicyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreatePolicyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_policy",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_POLICY_V3",
      },
      "createPolicyResult",
      stampWith,
    );
  };

  stampCreatePolicy = async (
    input: SdkTypes.TCreatePolicyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_policy";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createPrivateKeyTag = async (
    input: SdkTypes.TCreatePrivateKeyTagBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreatePrivateKeyTagResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_private_key_tag",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG",
      },
      "createPrivateKeyTagResult",
      stampWith,
    );
  };

  stampCreatePrivateKeyTag = async (
    input: SdkTypes.TCreatePrivateKeyTagBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_private_key_tag";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createPrivateKeys = async (
    input: SdkTypes.TCreatePrivateKeysBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreatePrivateKeysResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_private_keys",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
      },
      "createPrivateKeysResultV2",
      stampWith,
    );
  };

  stampCreatePrivateKeys = async (
    input: SdkTypes.TCreatePrivateKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_private_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createReadOnlySession = async (
    input: SdkTypes.TCreateReadOnlySessionBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateReadOnlySessionResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_read_only_session",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION",
      },
      "createReadOnlySessionResult",
      stampWith,
    );
  };

  stampCreateReadOnlySession = async (
    input: SdkTypes.TCreateReadOnlySessionBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_read_only_session";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createReadWriteSession = async (
    input: SdkTypes.TCreateReadWriteSessionBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateReadWriteSessionResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_read_write_session",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
      },
      "createReadWriteSessionResultV2",
      stampWith,
    );
  };

  stampCreateReadWriteSession = async (
    input: SdkTypes.TCreateReadWriteSessionBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_read_write_session";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createSubOrganization = async (
    input: SdkTypes.TCreateSubOrganizationBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateSubOrganizationResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_sub_organization",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
      },
      "createSubOrganizationResultV7",
      stampWith,
    );
  };

  stampCreateSubOrganization = async (
    input: SdkTypes.TCreateSubOrganizationBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_sub_organization";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createUserTag = async (
    input: SdkTypes.TCreateUserTagBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateUserTagResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_user_tag",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_USER_TAG",
      },
      "createUserTagResult",
      stampWith,
    );
  };

  stampCreateUserTag = async (
    input: SdkTypes.TCreateUserTagBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_user_tag";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createUsers = async (
    input: SdkTypes.TCreateUsersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateUsersResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_users",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_USERS_V3",
      },
      "createUsersResult",
      stampWith,
    );
  };

  stampCreateUsers = async (
    input: SdkTypes.TCreateUsersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_users";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createWallet = async (
    input: SdkTypes.TCreateWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateWalletResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_wallet",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_WALLET",
      },
      "createWalletResult",
      stampWith,
    );
  };

  stampCreateWallet = async (
    input: SdkTypes.TCreateWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  createWalletAccounts = async (
    input: SdkTypes.TCreateWalletAccountsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TCreateWalletAccountsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/create_wallet_accounts",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS",
      },
      "createWalletAccountsResult",
      stampWith,
    );
  };

  stampCreateWalletAccounts = async (
    input: SdkTypes.TCreateWalletAccountsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/create_wallet_accounts";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteApiKeys = async (
    input: SdkTypes.TDeleteApiKeysBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteApiKeysResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_api_keys",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_API_KEYS",
      },
      "deleteApiKeysResult",
      stampWith,
    );
  };

  stampDeleteApiKeys = async (
    input: SdkTypes.TDeleteApiKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_api_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteAuthenticators = async (
    input: SdkTypes.TDeleteAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteAuthenticatorsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_authenticators",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS",
      },
      "deleteAuthenticatorsResult",
      stampWith,
    );
  };

  stampDeleteAuthenticators = async (
    input: SdkTypes.TDeleteAuthenticatorsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_authenticators";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteInvitation = async (
    input: SdkTypes.TDeleteInvitationBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteInvitationResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_invitation",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_INVITATION",
      },
      "deleteInvitationResult",
      stampWith,
    );
  };

  stampDeleteInvitation = async (
    input: SdkTypes.TDeleteInvitationBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_invitation";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteOauthProviders = async (
    input: SdkTypes.TDeleteOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteOauthProvidersResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_oauth_providers",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS",
      },
      "deleteOauthProvidersResult",
      stampWith,
    );
  };

  stampDeleteOauthProviders = async (
    input: SdkTypes.TDeleteOauthProvidersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_oauth_providers";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deletePolicy = async (
    input: SdkTypes.TDeletePolicyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeletePolicyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_policy",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_POLICY",
      },
      "deletePolicyResult",
      stampWith,
    );
  };

  stampDeletePolicy = async (
    input: SdkTypes.TDeletePolicyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_policy";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deletePrivateKeyTags = async (
    input: SdkTypes.TDeletePrivateKeyTagsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeletePrivateKeyTagsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_private_key_tags",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS",
      },
      "deletePrivateKeyTagsResult",
      stampWith,
    );
  };

  stampDeletePrivateKeyTags = async (
    input: SdkTypes.TDeletePrivateKeyTagsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_private_key_tags";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deletePrivateKeys = async (
    input: SdkTypes.TDeletePrivateKeysBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeletePrivateKeysResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_private_keys",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS",
      },
      "deletePrivateKeysResult",
      stampWith,
    );
  };

  stampDeletePrivateKeys = async (
    input: SdkTypes.TDeletePrivateKeysBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_private_keys";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteSubOrganization = async (
    input: SdkTypes.TDeleteSubOrganizationBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteSubOrganizationResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_sub_organization",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION",
      },
      "deleteSubOrganizationResult",
      stampWith,
    );
  };

  stampDeleteSubOrganization = async (
    input: SdkTypes.TDeleteSubOrganizationBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_sub_organization";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteUserTags = async (
    input: SdkTypes.TDeleteUserTagsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteUserTagsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_user_tags",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_USER_TAGS",
      },
      "deleteUserTagsResult",
      stampWith,
    );
  };

  stampDeleteUserTags = async (
    input: SdkTypes.TDeleteUserTagsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/delete_user_tags";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteUsers = async (
    input: SdkTypes.TDeleteUsersBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteUsersResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_users",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_USERS",
      },
      "deleteUsersResult",
      stampWith,
    );
  };

  stampDeleteUsers = async (
    input: SdkTypes.TDeleteUsersBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_users";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  deleteWallets = async (
    input: SdkTypes.TDeleteWalletsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TDeleteWalletsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/delete_wallets",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_DELETE_WALLETS",
      },
      "deleteWalletsResult",
      stampWith,
    );
  };

  stampDeleteWallets = async (
    input: SdkTypes.TDeleteWalletsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_wallets";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  emailAuth = async (
    input: SdkTypes.TEmailAuthBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TEmailAuthResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/email_auth",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_EMAIL_AUTH_V2",
      },
      "emailAuthResult",
      stampWith,
    );
  };

  stampEmailAuth = async (
    input: SdkTypes.TEmailAuthBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/email_auth";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  exportPrivateKey = async (
    input: SdkTypes.TExportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TExportPrivateKeyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/export_private_key",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY",
      },
      "exportPrivateKeyResult",
      stampWith,
    );
  };

  stampExportPrivateKey = async (
    input: SdkTypes.TExportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/export_private_key";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  exportWallet = async (
    input: SdkTypes.TExportWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TExportWalletResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/export_wallet",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_EXPORT_WALLET",
      },
      "exportWalletResult",
      stampWith,
    );
  };

  stampExportWallet = async (
    input: SdkTypes.TExportWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  exportWalletAccount = async (
    input: SdkTypes.TExportWalletAccountBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TExportWalletAccountResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/export_wallet_account",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT",
      },
      "exportWalletAccountResult",
      stampWith,
    );
  };

  stampExportWalletAccount = async (
    input: SdkTypes.TExportWalletAccountBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/export_wallet_account";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  importPrivateKey = async (
    input: SdkTypes.TImportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TImportPrivateKeyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/import_private_key",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY",
      },
      "importPrivateKeyResult",
      stampWith,
    );
  };

  stampImportPrivateKey = async (
    input: SdkTypes.TImportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/import_private_key";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  importWallet = async (
    input: SdkTypes.TImportWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TImportWalletResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/import_wallet",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_IMPORT_WALLET",
      },
      "importWalletResult",
      stampWith,
    );
  };

  stampImportWallet = async (
    input: SdkTypes.TImportWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/import_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  initImportPrivateKey = async (
    input: SdkTypes.TInitImportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TInitImportPrivateKeyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/init_import_private_key",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY",
      },
      "initImportPrivateKeyResult",
      stampWith,
    );
  };

  stampInitImportPrivateKey = async (
    input: SdkTypes.TInitImportPrivateKeyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/init_import_private_key";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  initImportWallet = async (
    input: SdkTypes.TInitImportWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TInitImportWalletResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/init_import_wallet",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET",
      },
      "initImportWalletResult",
      stampWith,
    );
  };

  stampInitImportWallet = async (
    input: SdkTypes.TInitImportWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/init_import_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  initOtp = async (
    input: SdkTypes.TInitOtpBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TInitOtpResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/init_otp",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_INIT_OTP",
      },
      "initOtpResult",
      stampWith,
    );
  };

  stampInitOtp = async (
    input: SdkTypes.TInitOtpBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  initOtpAuth = async (
    input: SdkTypes.TInitOtpAuthBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TInitOtpAuthResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/init_otp_auth",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
      },
      "initOtpAuthResultV2",
      stampWith,
    );
  };

  stampInitOtpAuth = async (
    input: SdkTypes.TInitOtpAuthBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp_auth";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  initUserEmailRecovery = async (
    input: SdkTypes.TInitUserEmailRecoveryBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TInitUserEmailRecoveryResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/init_user_email_recovery",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY",
      },
      "initUserEmailRecoveryResult",
      stampWith,
    );
  };

  stampInitUserEmailRecovery = async (
    input: SdkTypes.TInitUserEmailRecoveryBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/init_user_email_recovery";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  oauth = async (
    input: SdkTypes.TOauthBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TOauthResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/oauth",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_OAUTH",
      },
      "oauthResult",
      stampWith,
    );
  };

  stampOauth = async (
    input: SdkTypes.TOauthBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  oauthLogin = async (
    input: SdkTypes.TOauthLoginBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TOauthLoginResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/oauth_login",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_OAUTH_LOGIN",
      },
      "oauthLoginResult",
      stampWith,
    );
  };

  stampOauthLogin = async (
    input: SdkTypes.TOauthLoginBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth_login";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  otpAuth = async (
    input: SdkTypes.TOtpAuthBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TOtpAuthResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/otp_auth",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_OTP_AUTH",
      },
      "otpAuthResult",
      stampWith,
    );
  };

  stampOtpAuth = async (
    input: SdkTypes.TOtpAuthBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_auth";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  otpLogin = async (
    input: SdkTypes.TOtpLoginBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TOtpLoginResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/otp_login",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_OTP_LOGIN",
      },
      "otpLoginResult",
      stampWith,
    );
  };

  stampOtpLogin = async (
    input: SdkTypes.TOtpLoginBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_login";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  recoverUser = async (
    input: SdkTypes.TRecoverUserBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TRecoverUserResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/recover_user",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_RECOVER_USER",
      },
      "recoverUserResult",
      stampWith,
    );
  };

  stampRecoverUser = async (
    input: SdkTypes.TRecoverUserBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/recover_user";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  rejectActivity = async (
    input: SdkTypes.TRejectActivityBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TRejectActivityResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.activityDecision(
      "/public/v1/submit/reject_activity",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_REJECT_ACTIVITY",
      },
      stampWith,
    );
  };

  stampRejectActivity = async (
    input: SdkTypes.TRejectActivityBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/reject_activity";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  removeOrganizationFeature = async (
    input: SdkTypes.TRemoveOrganizationFeatureBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TRemoveOrganizationFeatureResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/remove_organization_feature",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE",
      },
      "removeOrganizationFeatureResult",
      stampWith,
    );
  };

  stampRemoveOrganizationFeature = async (
    input: SdkTypes.TRemoveOrganizationFeatureBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/remove_organization_feature";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  setOrganizationFeature = async (
    input: SdkTypes.TSetOrganizationFeatureBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TSetOrganizationFeatureResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/set_organization_feature",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE",
      },
      "setOrganizationFeatureResult",
      stampWith,
    );
  };

  stampSetOrganizationFeature = async (
    input: SdkTypes.TSetOrganizationFeatureBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/set_organization_feature";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  signRawPayload = async (
    input: SdkTypes.TSignRawPayloadBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TSignRawPayloadResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/sign_raw_payload",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
      },
      "signRawPayloadResult",
      stampWith,
    );
  };

  stampSignRawPayload = async (
    input: SdkTypes.TSignRawPayloadBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payload";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  signRawPayloads = async (
    input: SdkTypes.TSignRawPayloadsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TSignRawPayloadsResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/sign_raw_payloads",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS",
      },
      "signRawPayloadsResult",
      stampWith,
    );
  };

  stampSignRawPayloads = async (
    input: SdkTypes.TSignRawPayloadsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payloads";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  signTransaction = async (
    input: SdkTypes.TSignTransactionBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TSignTransactionResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/sign_transaction",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
      },
      "signTransactionResult",
      stampWith,
    );
  };

  stampSignTransaction = async (
    input: SdkTypes.TSignTransactionBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/sign_transaction";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  stampLogin = async (
    input: SdkTypes.TStampLoginBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TStampLoginResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/stamp_login",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_STAMP_LOGIN",
      },
      "stampLoginResult",
      stampWith,
    );
  };

  stampStampLogin = async (
    input: SdkTypes.TStampLoginBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/stamp_login";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updatePolicy = async (
    input: SdkTypes.TUpdatePolicyBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdatePolicyResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_policy",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_POLICY_V2",
      },
      "updatePolicyResultV2",
      stampWith,
    );
  };

  stampUpdatePolicy = async (
    input: SdkTypes.TUpdatePolicyBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_policy";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updatePrivateKeyTag = async (
    input: SdkTypes.TUpdatePrivateKeyTagBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdatePrivateKeyTagResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_private_key_tag",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG",
      },
      "updatePrivateKeyTagResult",
      stampWith,
    );
  };

  stampUpdatePrivateKeyTag = async (
    input: SdkTypes.TUpdatePrivateKeyTagBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/update_private_key_tag";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updateRootQuorum = async (
    input: SdkTypes.TUpdateRootQuorumBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdateRootQuorumResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_root_quorum",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM",
      },
      "updateRootQuorumResult",
      stampWith,
    );
  };

  stampUpdateRootQuorum = async (
    input: SdkTypes.TUpdateRootQuorumBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/update_root_quorum";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updateUser = async (
    input: SdkTypes.TUpdateUserBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdateUserResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_user",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_USER",
      },
      "updateUserResult",
      stampWith,
    );
  };

  stampUpdateUser = async (
    input: SdkTypes.TUpdateUserBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updateUserTag = async (
    input: SdkTypes.TUpdateUserTagBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdateUserTagResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_user_tag",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_USER_TAG",
      },
      "updateUserTagResult",
      stampWith,
    );
  };

  stampUpdateUserTag = async (
    input: SdkTypes.TUpdateUserTagBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl =
      this.config.apiBaseUrl + "/public/v1/submit/update_user_tag";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  updateWallet = async (
    input: SdkTypes.TUpdateWalletBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TUpdateWalletResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/update_wallet",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_UPDATE_WALLET",
      },
      "updateWalletResult",
      stampWith,
    );
  };

  stampUpdateWallet = async (
    input: SdkTypes.TUpdateWalletBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_wallet";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  verifyOtp = async (
    input: SdkTypes.TVerifyOtpBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TVerifyOtpResponse> => {
    const { organizationId, timestampMs, ...rest } = input;
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage

    return this.command(
      "/public/v1/submit/verify_otp",
      {
        parameters: rest,
        organizationId:
          organizationId ??
          session?.organizationId ??
          this.config.organizationId,
        timestampMs: timestampMs ?? String(Date.now()),
        type: "ACTIVITY_TYPE_VERIFY_OTP",
      },
      "verifyOtpResult",
      stampWith,
    );
  };

  stampVerifyOtp = async (
    input: SdkTypes.TVerifyOtpBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/verify_otp";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };

  testRateLimits = async (
    input: SdkTypes.TTestRateLimitsBody,
    stampWith?: StamperType,
  ): Promise<SdkTypes.TTestRateLimitsResponse> => {
    let session = await this.storageManager?.getActiveSession();
    session = parseSession(session!); // TODO (Amir): We may not need this anymore since we want to store the full session object in storage
    return this.request(
      "/tkhq/api/v1/test_rate_limits",
      {
        ...input,
        organizationId:
          input.organizationId ??
          session?.organizationId ??
          this.config.organizationId,
      },
      stampWith,
    );
  };

  stampTestRateLimits = async (
    input: SdkTypes.TTestRateLimitsBody,
    stampWith?: StamperType,
  ): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const fullUrl = this.config.apiBaseUrl + "/tkhq/api/v1/test_rate_limits";
    const body = JSON.stringify(input);
    const stamp = await activeStamper.stamp(body);
    return {
      body: body,
      stamp: stamp,
      url: fullUrl,
    };
  };
}
