const fs = require("fs");
const path = require("path");

const SOURCE_DIRECTORY = path.resolve(__dirname, "../src");
const PUBLIC_API_SWAGGER_PATH = path.resolve(
  `${SOURCE_DIRECTORY}/__inputs__`,
  "public_api.swagger.json"
);
const AUTH_PROXY_SWAGGER_PATH = path.resolve(
  `${SOURCE_DIRECTORY}/__inputs__`,
  "auth_proxy.swagger.json"
);
const TARGET_SDK_CLIENT_PATH = path.resolve(
  `${SOURCE_DIRECTORY}/__generated__`,
  "sdk-client-base.ts"
);

const COMMENT_HEADER = "/* @generated by codegen. DO NOT EDIT BY HAND */";

const VERSIONED_ACTIVITY_TYPES = {
  ACTIVITY_TYPE_CREATE_AUTHENTICATORS: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
  ACTIVITY_TYPE_CREATE_API_KEYS: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
  ACTIVITY_TYPE_CREATE_POLICY: "ACTIVITY_TYPE_CREATE_POLICY_V3",
  ACTIVITY_TYPE_CREATE_PRIVATE_KEYS: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
  ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION:
    "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
  ACTIVITY_TYPE_CREATE_USERS: "ACTIVITY_TYPE_CREATE_USERS_V3",
  ACTIVITY_TYPE_SIGN_RAW_PAYLOAD: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
  ACTIVITY_TYPE_SIGN_TRANSACTION: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
  ACTIVITY_TYPE_EMAIL_AUTH: "ACTIVITY_TYPE_EMAIL_AUTH_V2",
  ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION:
    "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
  ACTIVITY_TYPE_UPDATE_POLICY: "ACTIVITY_TYPE_UPDATE_POLICY_V2",
  ACTIVITY_TYPE_INIT_OTP_AUTH: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
};

const METHODS_WITH_ONLY_OPTIONAL_PARAMETERS = [
  "getActivities",
  "getApiKeys",
  "getOrganization",
  "getPolicies",
  "getPrivateKeys",
  "getSubOrgIds",
  "getUsers",
  "getWallets",
  "getWhoami",
  "listPrivateKeys",
  "listUserTags",
];

/**
 * @param {string} methodName
 * @returns {string}
 */
function methodTypeFromMethodName(methodName) {
  if (["approveActivity", "rejectActivity"].includes(methodName)) {
    return "activityDecision";
  }
  if (methodName.startsWith("nOOP")) {
    return "noop";
  }
  // TODO: filter out unnecessary client methods, whether here or from the source
  if (
    methodName.startsWith("get") ||
    methodName.startsWith("list") ||
    methodName.startsWith("test")
  ) {
    return "query";
  }
  return "activity";
}

// Helper that takes in swagger definitions and returns a map containing the latest version of a field.
// The intent is to consolidate a field with multiple versions (e.g. v1CreateSubOrganizationResult, v1CreateSubOrganizationResultV2...)
// in order to get just the latest (v1CreateSubOrganizationResultV4).
function extractLatestVersions(definitions) {
  const latestVersions = {};

  // Regex to separate the version prefix, base activity details, and (optional) activity version
  const keyVersionRegex = /^(v\d+)([A-Z][a-z0-9]*(?:[A-Z][a-z0-9]*)*)(V\d+)?$/;

  Object.keys(definitions).forEach((key) => {
    const match = key.match(keyVersionRegex);
    if (match) {
      const fullName = match[0];
      const baseName = match[2]; // Field without any version-related prefixes or suffixes
      const versionSuffix = match[3]; // Version (optional)
      const formattedKeyName =
        baseName.charAt(0).toLowerCase() +
        baseName.slice(1) +
        (versionSuffix || ""); // Reconstruct the original key with version

      // Determine if this version is newer or if no version was previously stored
      if (
        !latestVersions[baseName] ||
        versionSuffix > (latestVersions[baseName].versionSuffix || "")
      ) {
        latestVersions[baseName] = {
          fullName,
          formattedKeyName,
          versionSuffix,
        };
      }
    }
  });

  return latestVersions;
}

const generateSDKClientFromSwagger = async (
  swaggerSpec,
  authProxySwaggerSpec,
  targetPath
) => {
  const namespace = swaggerSpec.tags?.find((item) => item.name != null)?.name;
  const authProxyNamespace = authProxySwaggerSpec.tags?.find(
    (item) => item.name != null
  )?.name;

  /** @type {Array<string>} */
  const codeBuffer = [];

  /** @type {Array<string>} */
  const imports = [];

  imports.push(
    'import { TERMINAL_ACTIVITY_STATUSES, type TActivityResponse, type TActivityStatus, type TSignedRequest } from "@turnkey/http";'
  );

  imports.push(
    'import { type GrpcStatus, type TStamper, TurnkeyRequestError, type TurnkeyHttpClientConfig, type StorageBase } from "../__types__/base";'
  );

  imports.push('import { VERSION } from "../__generated__/version";');

  imports.push('import type * as SdkTypes from "@turnkey/sdk-types";');
  imports.push(
    'import { TurnkeyError, TurnkeyErrorCodes } from "@turnkey/sdk-types";'
  );

  imports.push('import { StamperType } from "../__types__/base";');

  codeBuffer.push(`
    export class TurnkeySDKClientBase {
    config: TurnkeyHttpClientConfig;

    // Store stampers
    private apiKeyStamper?: TStamper | undefined;
    private passkeyStamper?: TStamper | undefined;
    private walletStamper?: TStamper | undefined;

    
    // Storage manager
    private storageManager?: StorageBase | undefined;

    constructor(config: TurnkeyHttpClientConfig) {
        this.config = config;
        
        if (config.apiKeyStamper) {
        this.apiKeyStamper = config.apiKeyStamper;
        }
        if (config.passkeyStamper) {
        this.passkeyStamper = config.passkeyStamper;
        }
        if (config.walletStamper) {
        this.walletStamper = config.walletStamper;
        }
        if (config.storageManager) {
        this.storageManager = config.storageManager;
        }
    }

    private getStamper(stampWith?: StamperType): TStamper | undefined {
        if (!stampWith) return this.apiKeyStamper || this.passkeyStamper || this.walletStamper;
        
        switch (stampWith) {
        case StamperType.ApiKey:
            return this.apiKeyStamper;
        case StamperType.Passkey:
            return this.passkeyStamper;
        case StamperType.Wallet:
            return this.walletStamper;
        default:
            return this.apiKeyStamper;
        }
    }

    async request<TBodyType, TResponseType>(
        url: string,
        body: TBodyType,
        stampWith?: StamperType
    ): Promise<TResponseType> {
        const fullUrl = this.config.apiBaseUrl + url;
        const stringifiedBody = JSON.stringify(body);
        var headers: Record<string, string> = {
        "X-Client-Version": VERSION
        }
        
        // Use the specified stamper for this request
        const activeStamper = this.getStamper(stampWith);
        
        if (activeStamper) {
        const stamp = await activeStamper.stamp(stringifiedBody);
        headers[stamp.stampHeaderName] = stamp.stampHeaderValue
        }

        const response = await fetch(fullUrl, {
        method: "POST",
        headers: headers,
        body: stringifiedBody,
        redirect: "follow"
        });

        if (!response.ok) {
        let res: GrpcStatus;
        try {
            res = await response.json();
        } catch (_) {
            throw new Error(\`\${response.status} \${response.statusText}\`);
        }

        throw new TurnkeyRequestError(res);
        }

        const data = await response.json();
        return data as TResponseType;
    }

    async activity<TBodyType, TResponseType>(
        url: string,
        body: TBodyType,
        resultKey: string,
        stampWith?: StamperType
    ): Promise<TResponseType> {
        const pollingDuration = this.config.activityPoller?.intervalMs ?? 1000;
        const maxRetries = this.config.activityPoller?.numRetries ?? 3;

        const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

        const handleResponse = (activityData: TActivityResponse): TResponseType => {
        const { result, status } = activityData.activity;

        if (status === "ACTIVITY_STATUS_COMPLETED") {
            return {
            ...result[\`\${resultKey}\` as keyof SdkTypes.v1Result],
            ...activityData
            } as TResponseType;
        }

        return activityData as TResponseType;
        };

        let attempts = 0;

        const pollStatus = async (activityId: string): Promise<TResponseType> => {
        const pollBody = { activityId };
        // Pass the stampWith parameter to getActivity
        const pollData = await this.getActivity(pollBody, stampWith) as TActivityResponse;

        if (attempts > maxRetries) {
            return handleResponse(pollData);
        }

        attempts += 1;
        
        if (!TERMINAL_ACTIVITY_STATUSES.includes(pollData.activity.status as TActivityStatus)) {
            await sleep(pollingDuration);
            return pollStatus(activityId);
        }

        return handleResponse(pollData);
        };

        // Use the specified stamper for the initial request
        const responseData = await this.request<TBodyType, TResponseType>(url, body, stampWith) as TActivityResponse;
        
        if (!TERMINAL_ACTIVITY_STATUSES.includes(responseData.activity.status as TActivityStatus)) {
        return pollStatus(responseData.activity.id);
        }

        return handleResponse(responseData);
    }

    async activityDecision<TBodyType, TResponseType>(
        url: string,
        body: TBodyType,
        stampWith?: StamperType
    ): Promise<TResponseType> {
        // Use the specified stamper for this request
        const activityData = await this.request(url, body, stampWith) as TActivityResponse;

        return {
        ...activityData["activity"]["result"],
        ...activityData
        } as TResponseType;
    }
    
    async authProxyRequest<TBodyType, TResponseType>(
        url: string,
        body: TBodyType,
    ): Promise<TResponseType> {
        if (!this.config.authProxyUrl || !this.config.authProxyConfigId) {
        throw new TurnkeyError("Auth Proxy URL or ID is not configured.", TurnkeyErrorCodes.INVALID_CONFIGURATION);
        }
        const fullUrl = this.config.authProxyUrl + url;
        const stringifiedBody = JSON.stringify(body);
        var headers: Record<string, string> = {
        "Content-Type": "application/json",
        "X-Auth-Proxy-Config-ID": this.config.authProxyConfigId,
        }

        const response = await fetch(fullUrl, {
        method: "POST",
        headers: headers,
        body: stringifiedBody,
        });

        if (!response.ok) {
        let res: GrpcStatus;
        try {
            res = await response.json();
        } catch (_) {
            throw new Error(\`\${response.status} \${response.statusText}\`);
        }

        throw new TurnkeyRequestError(res);
        }

        const data = await response.json();
        return data as TResponseType;
    }`);
  const latestVersions = extractLatestVersions(swaggerSpec.definitions);

  for (const endpointPath in swaggerSpec.paths) {
    const methodMap = swaggerSpec.paths[endpointPath];
    const operation = methodMap.post;
    const operationId = operation.operationId;

    const operationNameWithoutNamespace = operationId.replace(
      new RegExp(`${namespace}_`),
      ""
    );

    if (operationNameWithoutNamespace === "NOOPCodegenAnchor") {
      continue;
    }

    const methodName = `${
      operationNameWithoutNamespace.charAt(0).toLowerCase() +
      operationNameWithoutNamespace.slice(1)
    }`;

    const methodType = methodTypeFromMethodName(methodName);
    const inputType = `T${operationNameWithoutNamespace}Body`;
    const responseType = `T${operationNameWithoutNamespace}Response`;

    // For query methods
    if (methodType === "query") {
      codeBuffer.push(
        `\n\t${methodName} = async (input: SdkTypes.${inputType}${
          METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.includes(methodName)
            ? " = {}"
            : ""
        }, stampWith?: StamperType): Promise<SdkTypes.${responseType}> => {
      const session = await this.storageManager?.getActiveSession();
      return this.request("${endpointPath}", {
        ...input,
        organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
      }, stampWith);
    }`
      );
    } else if (methodType === "activity") {
      // For activity methods
      const unversionedActivityType = `ACTIVITY_TYPE_${operationNameWithoutNamespace
        .replace(/([a-z])([A-Z])/g, "$1_$2")
        .toUpperCase()}`;
      const versionedActivityType =
        VERSIONED_ACTIVITY_TYPES[unversionedActivityType];

      const resultKey = operationNameWithoutNamespace + "Result";
      const versionedMethodName = latestVersions[resultKey].formattedKeyName;

      codeBuffer.push(
        `\n\t${methodName} = async (input: SdkTypes.${inputType}, stampWith?: StamperType): Promise<SdkTypes.${responseType}> => {
      const { organizationId, timestampMs, ...rest } = input;
      const session = await this.storageManager?.getActiveSession();
  
      return this.activity("${endpointPath}", {
        parameters: rest,
        organizationId: organizationId ?? (session?.organizationId ?? this.config.organizationId),
        timestampMs: timestampMs ?? String(Date.now()),
        type: "${versionedActivityType ?? unversionedActivityType}"
      }, "${versionedMethodName}", stampWith);
    }`
      );
    } else if (methodType === "activityDecision") {
      // For activityDecision methods
      codeBuffer.push(
        `\n\t${methodName} = async (input: SdkTypes.${inputType}, stampWith?: StamperType): Promise<SdkTypes.${responseType}> => {
      const { organizationId, timestampMs, ...rest } = input;
      const session = await this.storageManager?.getActiveSession();
      return this.activityDecision("${endpointPath}",
        {
          parameters: rest,
          organizationId: organizationId ?? (session?.organizationId ?? this.config.organizationId),
          timestampMs: timestampMs ?? String(Date.now()),
          type: "ACTIVITY_TYPE_${operationNameWithoutNamespace
            .replace(/([a-z])([A-Z])/g, "$1_$2")
            .toUpperCase()}"
        }, stampWith);
    }`
      );
    }

    const unversionedActivityType = `ACTIVITY_TYPE_${operationNameWithoutNamespace
      .replace(/([a-z])([A-Z])/g, "$1_$2")
      .toUpperCase()}`;
    const versionedActivityType =
      VERSIONED_ACTIVITY_TYPES[unversionedActivityType];

    // generate a stamping method for each method
    codeBuffer.push(
      `\n\tstamp${operationNameWithoutNamespace} = async (input: SdkTypes.${inputType}, stampWith?: StamperType): Promise<TSignedRequest | undefined> => {
    const activeStamper = this.getStamper(stampWith);
    if (!activeStamper) {
      return undefined;
    }

    const { organizationId${methodType === "activity" || methodType === "activityDecision" ? ", timestampMs" : ""}, ...parameters } = input;

    const fullUrl = this.config.apiBaseUrl + "${endpointPath}";
    const bodyWithType = {
      parameters,
      organizationId,${
        methodType === "activity" || methodType === "activityDecision"
          ? "\n      timestampMs: timestampMs ?? String(Date.now()),"
          : ""
      }
      type: "${versionedActivityType ?? unversionedActivityType}"
    };


    const stringifiedBody = JSON.stringify(bodyWithType);
    const stamp = await activeStamper.stamp(stringifiedBody);
    return {
      body: stringifiedBody,
      stamp: stamp,
      url: fullUrl,
    };
  }`
    );
  }

  for (const endpointPath in authProxySwaggerSpec.paths) {
    const methodMap = authProxySwaggerSpec.paths[endpointPath];
    const operation = methodMap.post;
    const operationId = operation.operationId;

    const operationNameWithoutNamespace = operationId.replace(
      new RegExp(`${authProxyNamespace}_`),
      ""
    );

    const methodName = `proxy${
      operationNameWithoutNamespace.charAt(0).toUpperCase() +
      operationNameWithoutNamespace.slice(1)
    }`;

    const inputType = `ProxyT${operationNameWithoutNamespace}Body`;
    const responseType = `ProxyT${operationNameWithoutNamespace}Response`;

    codeBuffer.push(
      `\n\t${methodName} = async (input: SdkTypes.${inputType}${
        METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.includes(methodName)
          ? " = {}"
          : ""
      }): Promise<SdkTypes.${responseType}> => {
      return this.authProxyRequest("${endpointPath}", input);
    }`
    );
  }

  // End of the TurnkeySDKClient Class Definition
  codeBuffer.push(`}`);

  await fs.promises.writeFile(
    targetPath,
    [COMMENT_HEADER].concat(imports).concat(codeBuffer).join("\n\n")
  );
};

// Main Runner
main().catch((error) => {
  console.error(error);
  process.exit(1);
});

async function main() {
  const swaggerSpecFile = await fs.promises.readFile(
    PUBLIC_API_SWAGGER_PATH,
    "utf-8"
  );
  const authProxySwaggerSpecFile = await fs.promises.readFile(
    AUTH_PROXY_SWAGGER_PATH,
    "utf-8"
  );

  const swaggerSpec = JSON.parse(swaggerSpecFile);
  const authProxySwaggerSpec = JSON.parse(authProxySwaggerSpecFile);

  await generateSDKClientFromSwagger(
    swaggerSpec,
    authProxySwaggerSpec,
    TARGET_SDK_CLIENT_PATH
  );
}
