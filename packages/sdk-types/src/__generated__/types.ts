// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by codegen.js

// --- Base Types from Swagger Definitions ---
export type apiApiKeyParams = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type billingActivateBillingTierIntent = {
  /** The product that the customer wants to subscribe to. */
  productId: string;
};

export type billingActivateBillingTierResult = {
  /** The id of the product being subscribed to. */
  productId: string;
};

export type billingDeletePaymentMethodIntent = {
  /** The payment method that the customer wants to remove. */
  paymentMethodId: string;
};

export type billingDeletePaymentMethodResult = {
  /** The payment method that was removed. */
  paymentMethodId: string;
};

export type billingSetPaymentMethodIntent = {
  /** The account number of the customer's credit card. */
  number: string;
  /** The verification digits of the customer's credit card. */
  cvv: string;
  /** The month that the credit card expires. */
  expiryMonth: string;
  /** The year that the credit card expires. */
  expiryYear: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodIntentV2 = {
  /** The id of the payment method that was created clientside. */
  paymentMethodId: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodResult = {
  /** The last four digits of the credit card added. */
  lastFour: string;
  /** The name associated with the payment method. */
  cardHolderName: string;
  /** The email address associated with the payment method. */
  cardHolderEmail: string;
};

export type datav1Tag = {
  /** Unique identifier for a given Tag. */
  tagId: string;
  /** Human-readable name for a Tag. */
  tagName: string;
  tagType: TagType;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type externaldatav1Address = {
  format?: AddressFormat;
  address?: string;
};

export type externaldatav1Credential = {
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  type: CredentialType;
};

export type externaldatav1Quorum = {
  /** Count of unique approvals required to meet quorum. */
  threshold: number;
  /** Unique identifiers of quorum set members. */
  userIds: string[];
};

export type externaldatav1Timestamp = {
  seconds: string;
  nanos: string;
};

export type immutableactivityv1Address = {
  format?: AddressFormat;
  address?: string;
};

export type protobufAny = {
  "@type"?: string;
  [key: string]: any;
};

export type rpcStatus = {
  code?: number;
  message?: string;
  details?: protobufAny[];
};

export type AcceptInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: AuthenticatorParams;
};

export type AcceptInvitationIntentV2 = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: AuthenticatorParamsV2;
};

export type AcceptInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type AccessType =
  | "ACCESS_TYPE_WEB"
  | "ACCESS_TYPE_API"
  | "ACCESS_TYPE_ALL";

export type Activity = {
  /** Unique identifier for a given Activity object. */
  id: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The current processing status of a specified Activity. */
  status: ActivityStatus;
  /** Type of Activity, such as Add User, or Sign Transaction. */
  type: ActivityType;
  /** Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  intent: Intent;
  /** Result of the intended action. */
  result: Result;
  /** A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  votes: Vote[];
  /** An artifact verifying a User's action. */
  fingerprint: string;
  canApprove: boolean;
  canReject: boolean;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Failure reason of the intended action. */
  failure?: rpcStatus;
};

export type ActivityResponse = {
  /** An action that can that can be taken within the Turnkey infrastructure. */
  activity: Activity;
};

export type ActivityStatus =
  | "ACTIVITY_STATUS_CREATED"
  | "ACTIVITY_STATUS_PENDING"
  | "ACTIVITY_STATUS_COMPLETED"
  | "ACTIVITY_STATUS_FAILED"
  | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
  | "ACTIVITY_STATUS_REJECTED";

export type ActivityType =
  | "ACTIVITY_TYPE_CREATE_API_KEYS"
  | "ACTIVITY_TYPE_CREATE_USERS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
  | "ACTIVITY_TYPE_CREATE_INVITATIONS"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION"
  | "ACTIVITY_TYPE_CREATE_POLICY"
  | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
  | "ACTIVITY_TYPE_DELETE_USERS"
  | "ACTIVITY_TYPE_DELETE_API_KEYS"
  | "ACTIVITY_TYPE_DELETE_INVITATION"
  | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
  | "ACTIVITY_TYPE_DELETE_POLICY"
  | "ACTIVITY_TYPE_CREATE_USER_TAG"
  | "ACTIVITY_TYPE_DELETE_USER_TAGS"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION"
  | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
  | "ACTIVITY_TYPE_REJECT_ACTIVITY"
  | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
  | "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_CREATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_POLICY_V3"
  | "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
  | "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
  | "ACTIVITY_TYPE_UPDATE_USER_TAG"
  | "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V2"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
  | "ACTIVITY_TYPE_UPDATE_USER"
  | "ACTIVITY_TYPE_UPDATE_POLICY"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
  | "ACTIVITY_TYPE_CREATE_WALLET"
  | "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
  | "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
  | "ACTIVITY_TYPE_RECOVER_USER"
  | "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
  | "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_EXPORT_WALLET"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
  | "ACTIVITY_TYPE_EMAIL_AUTH"
  | "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
  | "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
  | "ACTIVITY_TYPE_IMPORT_WALLET"
  | "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_CREATE_POLICIES"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
  | "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
  | "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
  | "ACTIVITY_TYPE_OAUTH"
  | "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
  | "ACTIVITY_TYPE_EMAIL_AUTH_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_DELETE_WALLETS"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
  | "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH"
  | "ACTIVITY_TYPE_OTP_AUTH"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
  | "ACTIVITY_TYPE_UPDATE_WALLET"
  | "ACTIVITY_TYPE_UPDATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V3"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
  | "ACTIVITY_TYPE_INIT_OTP"
  | "ACTIVITY_TYPE_VERIFY_OTP"
  | "ACTIVITY_TYPE_OTP_LOGIN"
  | "ACTIVITY_TYPE_STAMP_LOGIN"
  | "ACTIVITY_TYPE_OAUTH_LOGIN";

export type AddressFormat =
  | "ADDRESS_FORMAT_UNCOMPRESSED"
  | "ADDRESS_FORMAT_COMPRESSED"
  | "ADDRESS_FORMAT_ETHEREUM"
  | "ADDRESS_FORMAT_SOLANA"
  | "ADDRESS_FORMAT_COSMOS"
  | "ADDRESS_FORMAT_TRON"
  | "ADDRESS_FORMAT_SUI"
  | "ADDRESS_FORMAT_APTOS"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
  | "ADDRESS_FORMAT_SEI"
  | "ADDRESS_FORMAT_XLM"
  | "ADDRESS_FORMAT_DOGE_MAINNET"
  | "ADDRESS_FORMAT_DOGE_TESTNET"
  | "ADDRESS_FORMAT_TON_V3R2"
  | "ADDRESS_FORMAT_TON_V4R2"
  | "ADDRESS_FORMAT_TON_V5R1"
  | "ADDRESS_FORMAT_XRP";

export type ApiKey = {
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given API Key. */
  apiKeyId: string;
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type ApiKeyCurve =
  | "API_KEY_CURVE_P256"
  | "API_KEY_CURVE_SECP256K1"
  | "API_KEY_CURVE_ED25519";

export type ApiKeyParamsV2 = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The curve type to be used for processing API key signatures. */
  curveType: ApiKeyCurve;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type ApiOnlyUserParams = {
  /** The name of the new API-only User. */
  userName: string;
  /** The email address for this API-only User (optional). */
  userEmail?: string;
  /** A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
};

export type ApproveActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type ApproveActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ApproveActivityIntent;
};

export type Attestation = {
  /** The cbor encoded then base64 url encoded id of the credential. */
  credentialId: string;
  /** A base64 url encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
  attestationObject: string;
  /** The type of authenticator transports. */
  transports: AuthenticatorTransport[];
};

export type Authenticator = {
  /** Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
  transports: AuthenticatorTransport[];
  attestationType: string;
  /** Identifier indicating the type of the Security Key. */
  aaguid: string;
  /** Unique identifier for a WebAuthn credential. */
  credentialId: string;
  /** The type of Authenticator device. */
  model: string;
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type AuthenticatorAttestationResponse = {
  clientDataJson: string;
  attestationObject: string;
  transports?: AuthenticatorTransport[];
  authenticatorAttachment?: string;
};

export type AuthenticatorParams = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Unique identifier for a given User. */
  userId: string;
  attestation: PublicKeyCredentialWithAttestation;
  /** Challenge presented for authentication purposes. */
  challenge: string;
};

export type AuthenticatorParamsV2 = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Challenge presented for authentication purposes. */
  challenge: string;
  /** The attestation that proves custody of the authenticator and provides metadata about it. */
  attestation: Attestation;
};

export type AuthenticatorTransport =
  | "AUTHENTICATOR_TRANSPORT_BLE"
  | "AUTHENTICATOR_TRANSPORT_INTERNAL"
  | "AUTHENTICATOR_TRANSPORT_NFC"
  | "AUTHENTICATOR_TRANSPORT_USB"
  | "AUTHENTICATOR_TRANSPORT_HYBRID";

export type Config = {
  features?: Feature[];
  quorum?: externaldatav1Quorum;
};

export type CreateApiKeysIntent = {
  /** A list of API Keys. */
  apiKeys: apiApiKeyParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateApiKeysIntentV2 = {
  /** A list of API Keys. */
  apiKeys: ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateApiKeysIntentV2;
};

export type CreateApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type CreateApiOnlyUsersIntent = {
  /** A list of API-only Users to create. */
  apiOnlyUsers: ApiOnlyUserParams[];
};

export type CreateApiOnlyUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateApiOnlyUsersIntent;
};

export type CreateApiOnlyUsersResult = {
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type CreateAuthenticatorsIntent = {
  /** A list of Authenticators. */
  authenticators: AuthenticatorParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateAuthenticatorsIntentV2 = {
  /** A list of Authenticators. */
  authenticators: AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateAuthenticatorsIntentV2;
};

export type CreateAuthenticatorsResult = {
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type CreateInvitationsIntent = {
  /** A list of Invitations. */
  invitations: InvitationParams[];
};

export type CreateInvitationsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateInvitationsIntent;
};

export type CreateInvitationsResult = {
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type CreateOauthProvidersIntent = {
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: OauthProviderParams[];
};

export type CreateOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateOauthProvidersIntent;
};

export type CreateOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type CreateOrganizationIntent = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: AuthenticatorParams;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type CreateOrganizationIntentV2 = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: AuthenticatorParamsV2;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type CreateOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type CreatePoliciesIntent = {
  /** An array of policy intents to be created. */
  policies: CreatePolicyIntentV3[];
};

export type CreatePoliciesRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreatePoliciesIntent;
};

export type CreatePoliciesResult = {
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type CreatePolicyIntent = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: Selector[];
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: Effect;
  notes?: string;
};

export type CreatePolicyIntentV2 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: SelectorV2[];
  /** Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
  effect: Effect;
  notes?: string;
};

export type CreatePolicyIntentV3 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type CreatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreatePolicyIntentV3;
};

export type CreatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type CreatePrivateKeyTagIntent = {
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type CreatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreatePrivateKeyTagIntent;
};

export type CreatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type CreatePrivateKeysIntent = {
  /** A list of Private Keys. */
  privateKeys: PrivateKeyParams[];
};

export type CreatePrivateKeysIntentV2 = {
  /** A list of Private Keys. */
  privateKeys: PrivateKeyParams[];
};

export type CreatePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreatePrivateKeysIntentV2;
};

export type CreatePrivateKeysResult = {
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type CreatePrivateKeysResultV2 = {
  /** A list of Private Key IDs and addresses. */
  privateKeys: PrivateKeyResult[];
};

export type CreateReadOnlySessionIntent = any;
export type CreateReadOnlySessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateReadOnlySessionIntent;
};

export type CreateReadOnlySessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type CreateReadWriteSessionIntent = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Email of the user to create a read write session for */
  email: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
};

export type CreateReadWriteSessionIntentV2 = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type CreateReadWriteSessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateReadWriteSessionIntentV2;
};

export type CreateReadWriteSessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type CreateReadWriteSessionResultV2 = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type CreateSubOrganizationIntent = {
  /** Name for this sub-organization */
  name: string;
  /** Root User authenticator for this new sub-organization */
  rootAuthenticator: AuthenticatorParamsV2;
};

export type CreateSubOrganizationIntentV2 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
};

export type CreateSubOrganizationIntentV3 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** A list of Private Keys. */
  privateKeys: PrivateKeyParams[];
};

export type CreateSubOrganizationIntentV4 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type CreateSubOrganizationIntentV5 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParamsV2[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type CreateSubOrganizationIntentV6 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParamsV3[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type CreateSubOrganizationIntentV7 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
};

export type CreateSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateSubOrganizationIntentV7;
};

export type CreateSubOrganizationResult = {
  subOrganizationId: string;
  rootUserIds?: string[];
};

export type CreateSubOrganizationResultV3 = {
  subOrganizationId: string;
  /** A list of Private Key IDs and addresses. */
  privateKeys: PrivateKeyResult[];
  rootUserIds?: string[];
};

export type CreateSubOrganizationResultV4 = {
  subOrganizationId: string;
  wallet?: WalletResult;
  rootUserIds?: string[];
};

export type CreateSubOrganizationResultV5 = {
  subOrganizationId: string;
  wallet?: WalletResult;
  rootUserIds?: string[];
};

export type CreateSubOrganizationResultV6 = {
  subOrganizationId: string;
  wallet?: WalletResult;
  rootUserIds?: string[];
};

export type CreateSubOrganizationResultV7 = {
  subOrganizationId: string;
  wallet?: WalletResult;
  rootUserIds?: string[];
};

export type CreateUserTagIntent = {
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type CreateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateUserTagIntent;
};

export type CreateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type CreateUsersIntent = {
  /** A list of Users. */
  users: UserParams[];
};

export type CreateUsersIntentV2 = {
  /** A list of Users. */
  users: UserParamsV2[];
};

export type CreateUsersIntentV3 = {
  /** A list of Users. */
  users: UserParamsV3[];
};

export type CreateUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateUsersIntentV3;
};

export type CreateUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type CreateWalletAccountsIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: WalletAccountParams[];
};

export type CreateWalletAccountsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateWalletAccountsIntent;
};

export type CreateWalletAccountsResult = {
  /** A list of derived addresses. */
  addresses: string[];
};

export type CreateWalletIntent = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type CreateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: CreateWalletIntent;
};

export type CreateWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type CredPropsAuthenticationExtensionsClientOutputs = {
  rk: boolean;
};

export type CredentialType =
  | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
  | "CREDENTIAL_TYPE_API_KEY_P256"
  | "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_SECP256K1"
  | "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_ED25519"
  | "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
  | "CREDENTIAL_TYPE_OAUTH_KEY_P256"
  | "CREDENTIAL_TYPE_LOGIN";

export type Curve = "CURVE_SECP256K1" | "CURVE_ED25519";

export type DeleteApiKeysIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type DeleteApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteApiKeysIntent;
};

export type DeleteApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type DeleteAuthenticatorsIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type DeleteAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteAuthenticatorsIntent;
};

export type DeleteAuthenticatorsResult = {
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type DeleteInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type DeleteInvitationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteInvitationIntent;
};

export type DeleteInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type DeleteOauthProvidersIntent = {
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type DeleteOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteOauthProvidersIntent;
};

export type DeleteOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type DeleteOrganizationIntent = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type DeleteOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type DeletePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type DeletePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeletePolicyIntent;
};

export type DeletePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type DeletePrivateKeyTagsIntent = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type DeletePrivateKeyTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeletePrivateKeyTagsIntent;
};

export type DeletePrivateKeyTagsResult = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type DeletePrivateKeysIntent = {
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type DeletePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeletePrivateKeysIntent;
};

export type DeletePrivateKeysResult = {
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type DeleteSubOrganizationIntent = {
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type DeleteSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteSubOrganizationIntent;
};

export type DeleteSubOrganizationResult = {
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type DeleteUserTagsIntent = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type DeleteUserTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteUserTagsIntent;
};

export type DeleteUserTagsResult = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type DeleteUsersIntent = {
  /** A list of User IDs. */
  userIds: string[];
};

export type DeleteUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteUsersIntent;
};

export type DeleteUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type DeleteWalletsIntent = {
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type DeleteWalletsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: DeleteWalletsIntent;
};

export type DeleteWalletsResult = {
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type DisablePrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type DisablePrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type Effect = "EFFECT_ALLOW" | "EFFECT_DENY";

export type EmailAuthIntent = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type EmailAuthIntentV2 = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type EmailAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: EmailAuthIntentV2;
};

export type EmailAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type EmailCustomizationParams = {
  /** The name of the application. */
  appName?: string;
  /** A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
  logoUrl?: string;
  /** A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
  magicLinkTemplate?: string;
  /** JSON object containing key/value pairs to be used with custom templates. */
  templateVariables?: string;
  /** Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
  templateId?: string;
};

export type ExportPrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type ExportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ExportPrivateKeyIntent;
};

export type ExportPrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type ExportWalletAccountIntent = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type ExportWalletAccountRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ExportWalletAccountIntent;
};

export type ExportWalletAccountResult = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type ExportWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: MnemonicLanguage;
};

export type ExportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ExportWalletIntent;
};

export type ExportWalletResult = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type Feature = {
  name?: FeatureName;
  value?: string;
};

export type FeatureName =
  | "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBAUTHN_ORIGINS"
  | "FEATURE_NAME_EMAIL_AUTH"
  | "FEATURE_NAME_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBHOOK"
  | "FEATURE_NAME_SMS_AUTH"
  | "FEATURE_NAME_OTP_EMAIL_AUTH";

export type GetActivitiesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Array of Activity Statuses filtering which Activities will be listed in the response. */
  filterByStatus?: ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: Pagination;
  /** Array of Activity Types filtering which Activities will be listed in the response. */
  filterByType?: ActivityType[];
};

export type GetActivitiesResponse = {
  /** A list of Activities. */
  activities: Activity[];
};

export type GetActivityRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Activity object. */
  activityId: string;
};

export type GetApiKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type GetApiKeyResponse = {
  /** An API key. */
  apiKey: ApiKey;
};

export type GetApiKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type GetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: ApiKey[];
};

export type GetAttestationDocumentRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser */
  enclaveType: string;
};

export type GetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document */
  attestationDocument: string;
};

export type GetAuthenticatorRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
};

export type GetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: Authenticator;
};

export type GetAuthenticatorsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type GetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: Authenticator[];
};

export type GetOauthProvidersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type GetOauthProvidersResponse = {
  /** A list of Oauth Providers */
  oauthProviders: OauthProvider[];
};

export type GetOrganizationConfigsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features */
  configs: Config;
};

export type GetOrganizationRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
  organizationData: OrganizationData;
};

export type GetPoliciesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetPoliciesResponse = {
  /** A list of Policies. */
  policies: Policy[];
};

export type GetPolicyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type GetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an Organization. */
  policy: Policy;
};

export type GetPrivateKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type GetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: PrivateKey;
};

export type GetPrivateKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetPrivateKeysResponse = {
  /** A list of Private Keys. */
  privateKeys: PrivateKey[];
};

export type GetSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: Pagination;
};

export type GetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type GetUserRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type GetUserResponse = {
  /** Web and/or API user within your Organization. */
  user: User;
};

export type GetUsersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetUsersResponse = {
  /** A list of Users. */
  users: User[];
};

export type GetVerifiedSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: Pagination;
};

export type GetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type GetWalletAccountRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Address corresponding to a Wallet Account. */
  address?: string;
  /** Path corresponding to a Wallet Account. */
  path?: string;
};

export type GetWalletAccountResponse = {
  /** The resulting Wallet Account. */
  account: WalletAccount;
};

export type GetWalletAccountsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: Pagination;
};

export type GetWalletAccountsResponse = {
  /** A list of Accounts generated from a Wallet that share a common seed. */
  accounts: WalletAccount[];
};

export type GetWalletRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
};

export type GetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
  wallet: Wallet;
};

export type GetWalletsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type GetWalletsResponse = {
  /** A list of Wallets. */
  wallets: Wallet[];
};

export type GetWhoamiRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
};

export type GetWhoamiResponse = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
};

export type HashFunction =
  | "HASH_FUNCTION_NO_OP"
  | "HASH_FUNCTION_SHA256"
  | "HASH_FUNCTION_KECCAK256"
  | "HASH_FUNCTION_NOT_APPLICABLE";

export type ImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: AddressFormat[];
};

export type ImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ImportPrivateKeyIntent;
};

export type ImportPrivateKeyResult = {
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type ImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: WalletAccountParams[];
};

export type ImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: ImportWalletIntent;
};

export type ImportWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type InitImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type InitImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: InitImportPrivateKeyIntent;
};

export type InitImportPrivateKeyResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type InitImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type InitImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: InitImportWalletIntent;
};

export type InitImportWalletResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type InitOtpAuthIntent = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type InitOtpAuthIntentV2 = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type InitOtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: InitOtpAuthIntentV2;
};

export type InitOtpAuthResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type InitOtpAuthResultV2 = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type InitOtpIntent = {
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type InitOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: InitOtpIntent;
};

export type InitOtpResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type InitUserEmailRecoveryIntent = {
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: EmailCustomizationParams;
};

export type InitUserEmailRecoveryRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: InitUserEmailRecoveryIntent;
};

export type InitUserEmailRecoveryResult = {
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type Intent = {
  createOrganizationIntent?: CreateOrganizationIntent;
  createAuthenticatorsIntent?: CreateAuthenticatorsIntent;
  createUsersIntent?: CreateUsersIntent;
  createPrivateKeysIntent?: CreatePrivateKeysIntent;
  signRawPayloadIntent?: SignRawPayloadIntent;
  createInvitationsIntent?: CreateInvitationsIntent;
  acceptInvitationIntent?: AcceptInvitationIntent;
  createPolicyIntent?: CreatePolicyIntent;
  disablePrivateKeyIntent?: DisablePrivateKeyIntent;
  deleteUsersIntent?: DeleteUsersIntent;
  deleteAuthenticatorsIntent?: DeleteAuthenticatorsIntent;
  deleteInvitationIntent?: DeleteInvitationIntent;
  deleteOrganizationIntent?: DeleteOrganizationIntent;
  deletePolicyIntent?: DeletePolicyIntent;
  createUserTagIntent?: CreateUserTagIntent;
  deleteUserTagsIntent?: DeleteUserTagsIntent;
  signTransactionIntent?: SignTransactionIntent;
  createApiKeysIntent?: CreateApiKeysIntent;
  deleteApiKeysIntent?: DeleteApiKeysIntent;
  approveActivityIntent?: ApproveActivityIntent;
  rejectActivityIntent?: RejectActivityIntent;
  createPrivateKeyTagIntent?: CreatePrivateKeyTagIntent;
  deletePrivateKeyTagsIntent?: DeletePrivateKeyTagsIntent;
  createPolicyIntentV2?: CreatePolicyIntentV2;
  setPaymentMethodIntent?: billingSetPaymentMethodIntent;
  activateBillingTierIntent?: billingActivateBillingTierIntent;
  deletePaymentMethodIntent?: billingDeletePaymentMethodIntent;
  createPolicyIntentV3?: CreatePolicyIntentV3;
  createApiOnlyUsersIntent?: CreateApiOnlyUsersIntent;
  updateRootQuorumIntent?: UpdateRootQuorumIntent;
  updateUserTagIntent?: UpdateUserTagIntent;
  updatePrivateKeyTagIntent?: UpdatePrivateKeyTagIntent;
  createAuthenticatorsIntentV2?: CreateAuthenticatorsIntentV2;
  acceptInvitationIntentV2?: AcceptInvitationIntentV2;
  createOrganizationIntentV2?: CreateOrganizationIntentV2;
  createUsersIntentV2?: CreateUsersIntentV2;
  createSubOrganizationIntent?: CreateSubOrganizationIntent;
  createSubOrganizationIntentV2?: CreateSubOrganizationIntentV2;
  updateAllowedOriginsIntent?: UpdateAllowedOriginsIntent;
  createPrivateKeysIntentV2?: CreatePrivateKeysIntentV2;
  updateUserIntent?: UpdateUserIntent;
  updatePolicyIntent?: UpdatePolicyIntent;
  setPaymentMethodIntentV2?: billingSetPaymentMethodIntentV2;
  createSubOrganizationIntentV3?: CreateSubOrganizationIntentV3;
  createWalletIntent?: CreateWalletIntent;
  createWalletAccountsIntent?: CreateWalletAccountsIntent;
  initUserEmailRecoveryIntent?: InitUserEmailRecoveryIntent;
  recoverUserIntent?: RecoverUserIntent;
  setOrganizationFeatureIntent?: SetOrganizationFeatureIntent;
  removeOrganizationFeatureIntent?: RemoveOrganizationFeatureIntent;
  signRawPayloadIntentV2?: SignRawPayloadIntentV2;
  signTransactionIntentV2?: SignTransactionIntentV2;
  exportPrivateKeyIntent?: ExportPrivateKeyIntent;
  exportWalletIntent?: ExportWalletIntent;
  createSubOrganizationIntentV4?: CreateSubOrganizationIntentV4;
  emailAuthIntent?: EmailAuthIntent;
  exportWalletAccountIntent?: ExportWalletAccountIntent;
  initImportWalletIntent?: InitImportWalletIntent;
  importWalletIntent?: ImportWalletIntent;
  initImportPrivateKeyIntent?: InitImportPrivateKeyIntent;
  importPrivateKeyIntent?: ImportPrivateKeyIntent;
  createPoliciesIntent?: CreatePoliciesIntent;
  signRawPayloadsIntent?: SignRawPayloadsIntent;
  createReadOnlySessionIntent?: CreateReadOnlySessionIntent;
  createOauthProvidersIntent?: CreateOauthProvidersIntent;
  deleteOauthProvidersIntent?: DeleteOauthProvidersIntent;
  createSubOrganizationIntentV5?: CreateSubOrganizationIntentV5;
  oauthIntent?: OauthIntent;
  createApiKeysIntentV2?: CreateApiKeysIntentV2;
  createReadWriteSessionIntent?: CreateReadWriteSessionIntent;
  emailAuthIntentV2?: EmailAuthIntentV2;
  createSubOrganizationIntentV6?: CreateSubOrganizationIntentV6;
  deletePrivateKeysIntent?: DeletePrivateKeysIntent;
  deleteWalletsIntent?: DeleteWalletsIntent;
  createReadWriteSessionIntentV2?: CreateReadWriteSessionIntentV2;
  deleteSubOrganizationIntent?: DeleteSubOrganizationIntent;
  initOtpAuthIntent?: InitOtpAuthIntent;
  otpAuthIntent?: OtpAuthIntent;
  createSubOrganizationIntentV7?: CreateSubOrganizationIntentV7;
  updateWalletIntent?: UpdateWalletIntent;
  updatePolicyIntentV2?: UpdatePolicyIntentV2;
  createUsersIntentV3?: CreateUsersIntentV3;
  initOtpAuthIntentV2?: InitOtpAuthIntentV2;
  initOtpIntent?: InitOtpIntent;
  verifyOtpIntent?: VerifyOtpIntent;
  otpLoginIntent?: OtpLoginIntent;
  stampLoginIntent?: StampLoginIntent;
  oauthLoginIntent?: OauthLoginIntent;
};

export type Invitation = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverEmail: string;
  /** A list of tags assigned to the Invitation recipient. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: AccessType;
  /** The current processing status of a specified Invitation. */
  status: InvitationStatus;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type InvitationParams = {
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverUserEmail: string;
  /** A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: AccessType;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type InvitationStatus =
  | "INVITATION_STATUS_CREATED"
  | "INVITATION_STATUS_ACCEPTED"
  | "INVITATION_STATUS_REVOKED";

export type ListPrivateKeyTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type ListPrivateKeyTagsResponse = {
  /** A list of Private Key Tags */
  privateKeyTags: datav1Tag[];
};

export type ListUserTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type ListUserTagsResponse = {
  /** A list of User Tags */
  userTags: datav1Tag[];
};

export type MnemonicLanguage =
  | "MNEMONIC_LANGUAGE_ENGLISH"
  | "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
  | "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
  | "MNEMONIC_LANGUAGE_CZECH"
  | "MNEMONIC_LANGUAGE_FRENCH"
  | "MNEMONIC_LANGUAGE_ITALIAN"
  | "MNEMONIC_LANGUAGE_JAPANESE"
  | "MNEMONIC_LANGUAGE_KOREAN"
  | "MNEMONIC_LANGUAGE_SPANISH";

export type NOOPCodegenAnchorResponse = {
  stamp: WebAuthnStamp;
};

export type OauthIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type OauthLoginIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type OauthLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: OauthLoginIntent;
};

export type OauthLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type OauthProvider = {
  /** Unique identifier for an OAuth Provider */
  providerId: string;
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
  issuer: string;
  /** Expected audience ('aud' attribute of the signed token) which represents the app ID */
  audience: string;
  /** Expected subject ('sub' attribute of the signed token) which represents the user ID */
  subject: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type OauthProviderParams = {
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
};

export type OauthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: OauthIntent;
};

export type OauthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type Operator =
  | "OPERATOR_EQUAL"
  | "OPERATOR_MORE_THAN"
  | "OPERATOR_MORE_THAN_OR_EQUAL"
  | "OPERATOR_LESS_THAN"
  | "OPERATOR_LESS_THAN_OR_EQUAL"
  | "OPERATOR_CONTAINS"
  | "OPERATOR_NOT_EQUAL"
  | "OPERATOR_IN"
  | "OPERATOR_NOT_IN"
  | "OPERATOR_CONTAINS_ONE"
  | "OPERATOR_CONTAINS_ALL";

export type OrganizationData = {
  organizationId?: string;
  name?: string;
  users?: User[];
  policies?: Policy[];
  privateKeys?: PrivateKey[];
  invitations?: Invitation[];
  tags?: datav1Tag[];
  rootQuorum?: externaldatav1Quorum;
  features?: Feature[];
  wallets?: Wallet[];
};

export type OtpAuthIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type OtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: OtpAuthIntent;
};

export type OtpAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type OtpLoginIntent = {
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type OtpLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: OtpLoginIntent;
};

export type OtpLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type Pagination = {
  /** A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
  limit?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
  before?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
  after?: string;
};

export type PathFormat = "PATH_FORMAT_BIP32";

export type PayloadEncoding =
  | "PAYLOAD_ENCODING_HEXADECIMAL"
  | "PAYLOAD_ENCODING_TEXT_UTF8";

export type Policy = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: Effect;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Human-readable notes added by a User to describe a particular policy. */
  notes: string;
  /** A consensus expression that evalutes to true or false. */
  consensus: string;
  /** A condition expression that evalutes to true or false. */
  condition: string;
};

export type PrivateKey = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: Curve;
  /** Derived cryptocurrency addresses for a given Private Key. */
  addresses: externaldatav1Address[];
  /** A list of Private Key Tag IDs. */
  privateKeyTags: string[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Private Key is exported, false otherwise. */
  exported: boolean;
  /** True when a given Private Key is imported, false otherwise. */
  imported: boolean;
};

export type PrivateKeyParams = {
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: Curve;
  /** A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
  privateKeyTags: string[];
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: AddressFormat[];
};

export type PrivateKeyResult = {
  privateKeyId?: string;
  addresses?: immutableactivityv1Address[];
};

export type PublicKeyCredentialWithAttestation = {
  id: string;
  type: string;
  rawId: string;
  authenticatorAttachment?: string;
  response: AuthenticatorAttestationResponse;
  clientExtensionResults: SimpleClientExtensionResults;
};

export type RecoverUserIntent = {
  /** The new authenticator to register. */
  authenticator: AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type RecoverUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: RecoverUserIntent;
};

export type RecoverUserResult = {
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type RejectActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type RejectActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: RejectActivityIntent;
};

export type RemoveOrganizationFeatureIntent = {
  /** Name of the feature to remove */
  name: FeatureName;
};

export type RemoveOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: RemoveOrganizationFeatureIntent;
};

export type RemoveOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: Feature[];
};

export type Result = {
  createOrganizationResult?: CreateOrganizationResult;
  createAuthenticatorsResult?: CreateAuthenticatorsResult;
  createUsersResult?: CreateUsersResult;
  createPrivateKeysResult?: CreatePrivateKeysResult;
  createInvitationsResult?: CreateInvitationsResult;
  acceptInvitationResult?: AcceptInvitationResult;
  signRawPayloadResult?: SignRawPayloadResult;
  createPolicyResult?: CreatePolicyResult;
  disablePrivateKeyResult?: DisablePrivateKeyResult;
  deleteUsersResult?: DeleteUsersResult;
  deleteAuthenticatorsResult?: DeleteAuthenticatorsResult;
  deleteInvitationResult?: DeleteInvitationResult;
  deleteOrganizationResult?: DeleteOrganizationResult;
  deletePolicyResult?: DeletePolicyResult;
  createUserTagResult?: CreateUserTagResult;
  deleteUserTagsResult?: DeleteUserTagsResult;
  signTransactionResult?: SignTransactionResult;
  deleteApiKeysResult?: DeleteApiKeysResult;
  createApiKeysResult?: CreateApiKeysResult;
  createPrivateKeyTagResult?: CreatePrivateKeyTagResult;
  deletePrivateKeyTagsResult?: DeletePrivateKeyTagsResult;
  setPaymentMethodResult?: billingSetPaymentMethodResult;
  activateBillingTierResult?: billingActivateBillingTierResult;
  deletePaymentMethodResult?: billingDeletePaymentMethodResult;
  createApiOnlyUsersResult?: CreateApiOnlyUsersResult;
  updateRootQuorumResult?: UpdateRootQuorumResult;
  updateUserTagResult?: UpdateUserTagResult;
  updatePrivateKeyTagResult?: UpdatePrivateKeyTagResult;
  createSubOrganizationResult?: CreateSubOrganizationResult;
  updateAllowedOriginsResult?: UpdateAllowedOriginsResult;
  createPrivateKeysResultV2?: CreatePrivateKeysResultV2;
  updateUserResult?: UpdateUserResult;
  updatePolicyResult?: UpdatePolicyResult;
  createSubOrganizationResultV3?: CreateSubOrganizationResultV3;
  createWalletResult?: CreateWalletResult;
  createWalletAccountsResult?: CreateWalletAccountsResult;
  initUserEmailRecoveryResult?: InitUserEmailRecoveryResult;
  recoverUserResult?: RecoverUserResult;
  setOrganizationFeatureResult?: SetOrganizationFeatureResult;
  removeOrganizationFeatureResult?: RemoveOrganizationFeatureResult;
  exportPrivateKeyResult?: ExportPrivateKeyResult;
  exportWalletResult?: ExportWalletResult;
  createSubOrganizationResultV4?: CreateSubOrganizationResultV4;
  emailAuthResult?: EmailAuthResult;
  exportWalletAccountResult?: ExportWalletAccountResult;
  initImportWalletResult?: InitImportWalletResult;
  importWalletResult?: ImportWalletResult;
  initImportPrivateKeyResult?: InitImportPrivateKeyResult;
  importPrivateKeyResult?: ImportPrivateKeyResult;
  createPoliciesResult?: CreatePoliciesResult;
  signRawPayloadsResult?: SignRawPayloadsResult;
  createReadOnlySessionResult?: CreateReadOnlySessionResult;
  createOauthProvidersResult?: CreateOauthProvidersResult;
  deleteOauthProvidersResult?: DeleteOauthProvidersResult;
  createSubOrganizationResultV5?: CreateSubOrganizationResultV5;
  oauthResult?: OauthResult;
  createReadWriteSessionResult?: CreateReadWriteSessionResult;
  createSubOrganizationResultV6?: CreateSubOrganizationResultV6;
  deletePrivateKeysResult?: DeletePrivateKeysResult;
  deleteWalletsResult?: DeleteWalletsResult;
  createReadWriteSessionResultV2?: CreateReadWriteSessionResultV2;
  deleteSubOrganizationResult?: DeleteSubOrganizationResult;
  initOtpAuthResult?: InitOtpAuthResult;
  otpAuthResult?: OtpAuthResult;
  createSubOrganizationResultV7?: CreateSubOrganizationResultV7;
  updateWalletResult?: UpdateWalletResult;
  updatePolicyResultV2?: UpdatePolicyResultV2;
  initOtpAuthResultV2?: InitOtpAuthResultV2;
  initOtpResult?: InitOtpResult;
  verifyOtpResult?: VerifyOtpResult;
  otpLoginResult?: OtpLoginResult;
  stampLoginResult?: StampLoginResult;
  oauthLoginResult?: OauthLoginResult;
};

export type RootUserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
};

export type RootUserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: OauthProviderParams[];
};

export type RootUserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: OauthProviderParams[];
};

export type RootUserParamsV4 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: OauthProviderParams[];
};

export type Selector = {
  subject?: string;
  operator?: Operator;
  target?: string;
};

export type SelectorV2 = {
  subject?: string;
  operator?: Operator;
  targets?: string[];
};

export type SetOrganizationFeatureIntent = {
  /** Name of the feature to set */
  name: FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type SetOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: SetOrganizationFeatureIntent;
};

export type SetOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: Feature[];
};

export type SignRawPayloadIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: HashFunction;
};

export type SignRawPayloadIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: HashFunction;
};

export type SignRawPayloadRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: SignRawPayloadIntentV2;
};

export type SignRawPayloadResult = {
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type SignRawPayloadsIntent = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: HashFunction;
};

export type SignRawPayloadsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: SignRawPayloadsIntent;
};

export type SignRawPayloadsResult = {
  signatures?: SignRawPayloadResult[];
};

export type SignTransactionIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned transaction to be signed by a particular Private Key. */
  unsignedTransaction: string;
  type: TransactionType;
};

export type SignTransactionIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: TransactionType;
};

export type SignTransactionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: SignTransactionIntentV2;
};

export type SignTransactionResult = {
  signedTransaction: string;
};

export type SimpleClientExtensionResults = {
  appid?: boolean;
  appidExclude?: boolean;
  credProps?: CredPropsAuthenticationExtensionsClientOutputs;
};

export type SmsCustomizationParams = {
  /** Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
  template?: string;
};

export type StampLoginIntent = {
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type StampLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: StampLoginIntent;
};

export type StampLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TagType = "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";

export type TestRateLimitsRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true */
  limit: number;
};

export type TestRateLimitsResponse = any;
export type TransactionType =
  | "TRANSACTION_TYPE_ETHEREUM"
  | "TRANSACTION_TYPE_SOLANA"
  | "TRANSACTION_TYPE_TRON";

export type UpdateAllowedOriginsIntent = {
  /** Additional origins requests are allowed from besides Turnkey origins */
  allowedOrigins: string[];
};

export type UpdateAllowedOriginsResult = any;
export type UpdatePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type UpdatePolicyIntentV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type UpdatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdatePolicyIntentV2;
};

export type UpdatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type UpdatePolicyResultV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type UpdatePrivateKeyTagIntent = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type UpdatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdatePrivateKeyTagIntent;
};

export type UpdatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type UpdateRootQuorumIntent = {
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type UpdateRootQuorumRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdateRootQuorumIntent;
};

export type UpdateRootQuorumResult = any;
export type UpdateUserIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type UpdateUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdateUserIntent;
};

export type UpdateUserResult = {
  /** A User ID. */
  userId: string;
};

export type UpdateUserTagIntent = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type UpdateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdateUserTagIntent;
};

export type UpdateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type UpdateWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type UpdateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: UpdateWalletIntent;
};

export type UpdateWalletResult = {
  /** A Wallet ID. */
  walletId: string;
};

export type User = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of Authenticator parameters. */
  authenticators: Authenticator[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: ApiKey[];
  /** A list of User Tag IDs. */
  userTags: string[];
  /** A list of Oauth Providers. */
  oauthProviders: OauthProvider[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type UserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The User's permissible access method(s). */
  accessType: AccessType;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type UserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type UserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: OauthProviderParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type VerifyOtpIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
};

export type VerifyOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: VerifyOtpIntent;
};

export type VerifyOtpResult = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type Vote = {
  /** Unique identifier for a given Vote object. */
  id: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Web and/or API user within your Organization. */
  user: User;
  /** Unique identifier for a given Activity object. */
  activityId: string;
  selection: string;
  /** The raw message being signed within a Vote. */
  message: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The signature applied to a particular vote. */
  signature: string;
  /** Method used to produce a signature. */
  scheme: string;
  createdAt: externaldatav1Timestamp;
};

export type Wallet = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Wallet is exported, false otherwise. */
  exported: boolean;
  /** True when a given Wallet is imported, false otherwise. */
  imported: boolean;
};

export type WalletAccount = {
  /** Unique identifier for a given Wallet Account. */
  walletAccountId: string;
  /** The Organization the Account belongs to. */
  organizationId: string;
  /** The Wallet the Account was derived from. */
  walletId: string;
  /** Cryptographic curve used to generate the Account. */
  curve: Curve;
  /** Path format used to generate the Account. */
  pathFormat: PathFormat;
  /** Path used to generate the Account. */
  path: string;
  /** Address format used to generate the Account. */
  addressFormat: AddressFormat;
  /** Address generated using the Wallet seed and Account parameters. */
  address: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** The public component of this wallet account's underlying cryptographic key pair. */
  publicKey?: string;
};

export type WalletAccountParams = {
  /** Cryptographic curve used to generate a wallet Account. */
  curve: Curve;
  /** Path format used to generate a wallet Account. */
  pathFormat: PathFormat;
  /** Path used to generate a wallet Account. */
  path: string;
  /** Address format used to generate a wallet Acccount. */
  addressFormat: AddressFormat;
};

export type WalletParams = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type WalletResult = {
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type WebAuthnStamp = {
  /** A base64 url encoded Unique identifier for a given credential. */
  credentialId: string;
  /** A base64 encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 encoded payload containing metadata about the authenticator. */
  authenticatorData: string;
  /** The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
  signature: string;
};
