/* @generated by codegen. DO NOT EDIT BY HAND */

// --- Base Types from Swagger Definitions ---
export type apiApiKeyParams = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type billingActivateBillingTierIntent = {
  /** The product that the customer wants to subscribe to. */
  productId: string;
};

export type billingActivateBillingTierResult = {
  /** The id of the product being subscribed to. */
  productId: string;
};

export type billingDeletePaymentMethodIntent = {
  /** The payment method that the customer wants to remove. */
  paymentMethodId: string;
};

export type billingDeletePaymentMethodResult = {
  /** The payment method that was removed. */
  paymentMethodId: string;
};

export type billingSetPaymentMethodIntent = {
  /** The account number of the customer's credit card. */
  number: string;
  /** The verification digits of the customer's credit card. */
  cvv: string;
  /** The month that the credit card expires. */
  expiryMonth: string;
  /** The year that the credit card expires. */
  expiryYear: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodIntentV2 = {
  /** The id of the payment method that was created clientside. */
  paymentMethodId: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodResult = {
  /** The last four digits of the credit card added. */
  lastFour: string;
  /** The name associated with the payment method. */
  cardHolderName: string;
  /** The email address associated with the payment method. */
  cardHolderEmail: string;
};

export type datav1Tag = {
  /** Unique identifier for a given Tag. */
  tagId: string;
  /** Human-readable name for a Tag. */
  tagName: string;
  tagType: v1TagType;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type externaldatav1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type externaldatav1Credential = {
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  type: v1CredentialType;
};

export type externaldatav1Quorum = {
  /** Count of unique approvals required to meet quorum. */
  threshold: number;
  /** Unique identifiers of quorum set members. */
  userIds: string[];
};

export type externaldatav1Timestamp = {
  seconds: string;
  nanos: string;
};

export type immutableactivityv1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type protobufAny = {
  "@type"?: string;
  [key: string]: any;
};

export type rpcStatus = {
  code?: number;
  message?: string;
  details?: protobufAny[];
};

export type v1AcceptInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParams;
};

export type v1AcceptInvitationIntentV2 = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParamsV2;
};

export type v1AcceptInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1AccessType =
  | "ACCESS_TYPE_WEB"
  | "ACCESS_TYPE_API"
  | "ACCESS_TYPE_ALL";

export type v1Activity = {
  /** Unique identifier for a given Activity object. */
  id: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The current processing status of a specified Activity. */
  status: v1ActivityStatus;
  /** Type of Activity, such as Add User, or Sign Transaction. */
  type: v1ActivityType;
  /** Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  intent: v1Intent;
  /** Result of the intended action. */
  result: v1Result;
  /** A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  votes: v1Vote[];
  /** An artifact verifying a User's action. */
  fingerprint: string;
  canApprove: boolean;
  canReject: boolean;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Failure reason of the intended action. */
  failure?: rpcStatus;
};

export type v1ActivityResponse = {
  /** An action that can that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type v1ActivityStatus =
  | "ACTIVITY_STATUS_CREATED"
  | "ACTIVITY_STATUS_PENDING"
  | "ACTIVITY_STATUS_COMPLETED"
  | "ACTIVITY_STATUS_FAILED"
  | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
  | "ACTIVITY_STATUS_REJECTED";

export type v1ActivityType =
  | "ACTIVITY_TYPE_CREATE_API_KEYS"
  | "ACTIVITY_TYPE_CREATE_USERS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
  | "ACTIVITY_TYPE_CREATE_INVITATIONS"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION"
  | "ACTIVITY_TYPE_CREATE_POLICY"
  | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
  | "ACTIVITY_TYPE_DELETE_USERS"
  | "ACTIVITY_TYPE_DELETE_API_KEYS"
  | "ACTIVITY_TYPE_DELETE_INVITATION"
  | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
  | "ACTIVITY_TYPE_DELETE_POLICY"
  | "ACTIVITY_TYPE_CREATE_USER_TAG"
  | "ACTIVITY_TYPE_DELETE_USER_TAGS"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION"
  | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
  | "ACTIVITY_TYPE_REJECT_ACTIVITY"
  | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
  | "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_CREATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_POLICY_V3"
  | "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
  | "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
  | "ACTIVITY_TYPE_UPDATE_USER_TAG"
  | "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V2"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
  | "ACTIVITY_TYPE_UPDATE_USER"
  | "ACTIVITY_TYPE_UPDATE_POLICY"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
  | "ACTIVITY_TYPE_CREATE_WALLET"
  | "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
  | "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
  | "ACTIVITY_TYPE_RECOVER_USER"
  | "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
  | "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_EXPORT_WALLET"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
  | "ACTIVITY_TYPE_EMAIL_AUTH"
  | "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
  | "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
  | "ACTIVITY_TYPE_IMPORT_WALLET"
  | "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_CREATE_POLICIES"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
  | "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
  | "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
  | "ACTIVITY_TYPE_OAUTH"
  | "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
  | "ACTIVITY_TYPE_EMAIL_AUTH_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_DELETE_WALLETS"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
  | "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH"
  | "ACTIVITY_TYPE_OTP_AUTH"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
  | "ACTIVITY_TYPE_UPDATE_WALLET"
  | "ACTIVITY_TYPE_UPDATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V3"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
  | "ACTIVITY_TYPE_INIT_OTP"
  | "ACTIVITY_TYPE_VERIFY_OTP"
  | "ACTIVITY_TYPE_OTP_LOGIN"
  | "ACTIVITY_TYPE_STAMP_LOGIN"
  | "ACTIVITY_TYPE_OAUTH_LOGIN"
  | "ACTIVITY_TYPE_UPDATE_USER_NAME"
  | "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
  | "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
  | "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
  | "ACTIVITY_TYPE_ENABLE_USER_INITIATED_AUTH"
  | "ACTIVITY_TYPE_DISABLE_USER_INITIATED_AUTH"
  | "ACTIVITY_TYPE_UPDATE_PROXY_AUTH_CONFIG";

export type v1AddressFormat =
  | "ADDRESS_FORMAT_UNCOMPRESSED"
  | "ADDRESS_FORMAT_COMPRESSED"
  | "ADDRESS_FORMAT_ETHEREUM"
  | "ADDRESS_FORMAT_SOLANA"
  | "ADDRESS_FORMAT_COSMOS"
  | "ADDRESS_FORMAT_TRON"
  | "ADDRESS_FORMAT_SUI"
  | "ADDRESS_FORMAT_APTOS"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
  | "ADDRESS_FORMAT_SEI"
  | "ADDRESS_FORMAT_XLM"
  | "ADDRESS_FORMAT_DOGE_MAINNET"
  | "ADDRESS_FORMAT_DOGE_TESTNET"
  | "ADDRESS_FORMAT_TON_V3R2"
  | "ADDRESS_FORMAT_TON_V4R2"
  | "ADDRESS_FORMAT_TON_V5R1"
  | "ADDRESS_FORMAT_XRP";

export type v1ApiKey = {
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given API Key. */
  apiKeyId: string;
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiKeyCurve =
  | "API_KEY_CURVE_P256"
  | "API_KEY_CURVE_SECP256K1"
  | "API_KEY_CURVE_ED25519";

export type v1ApiKeyParamsV2 = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The curve type to be used for processing API key signatures. */
  curveType: v1ApiKeyCurve;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiOnlyUserParams = {
  /** The name of the new API-only User. */
  userName: string;
  /** The email address for this API-only User (optional). */
  userEmail?: string;
  /** A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
};

export type v1ApproveActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1ApproveActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ApproveActivityIntent;
};

export type v1Attestation = {
  /** The cbor encoded then base64 url encoded id of the credential. */
  credentialId: string;
  /** A base64 url encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
  attestationObject: string;
  /** The type of authenticator transports. */
  transports: v1AuthenticatorTransport[];
};

export type v1Authenticator = {
  /** Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
  transports: v1AuthenticatorTransport[];
  attestationType: string;
  /** Identifier indicating the type of the Security Key. */
  aaguid: string;
  /** Unique identifier for a WebAuthn credential. */
  credentialId: string;
  /** The type of Authenticator device. */
  model: string;
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1AuthenticatorAttestationResponse = {
  clientDataJson: string;
  attestationObject: string;
  transports?: v1AuthenticatorTransport[];
  authenticatorAttachment?: string;
};

export type v1AuthenticatorParams = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Unique identifier for a given User. */
  userId: string;
  attestation: v1PublicKeyCredentialWithAttestation;
  /** Challenge presented for authentication purposes. */
  challenge: string;
};

export type v1AuthenticatorParamsV2 = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Challenge presented for authentication purposes. */
  challenge: string;
  /** The attestation that proves custody of the authenticator and provides metadata about it. */
  attestation: v1Attestation;
};

export type v1AuthenticatorTransport =
  | "AUTHENTICATOR_TRANSPORT_BLE"
  | "AUTHENTICATOR_TRANSPORT_INTERNAL"
  | "AUTHENTICATOR_TRANSPORT_NFC"
  | "AUTHENTICATOR_TRANSPORT_USB"
  | "AUTHENTICATOR_TRANSPORT_HYBRID";

export type v1Config = {
  features?: v1Feature[];
  quorum?: externaldatav1Quorum;
};

export type v1CreateApiKeysIntent = {
  /** A list of API Keys. */
  apiKeys: apiApiKeyParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysIntentV2 = {
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiKeysIntentV2;
};

export type v1CreateApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1CreateApiOnlyUsersIntent = {
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
};

export type v1CreateApiOnlyUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiOnlyUsersIntent;
};

export type v1CreateApiOnlyUsersResult = {
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type v1CreateAuthenticatorsIntent = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsIntentV2 = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateAuthenticatorsIntentV2;
};

export type v1CreateAuthenticatorsResult = {
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1CreateInvitationsIntent = {
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
};

export type v1CreateInvitationsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateInvitationsIntent;
};

export type v1CreateInvitationsResult = {
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type v1CreateOauthProvidersIntent = {
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1CreateOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateOauthProvidersIntent;
};

export type v1CreateOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1CreateOrganizationIntent = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParams;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationIntentV2 = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1CreatePoliciesIntent = {
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
};

export type v1CreatePoliciesRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePoliciesIntent;
};

export type v1CreatePoliciesResult = {
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type v1CreatePolicyIntent = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1Selector[];
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV2 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1SelectorV2[];
  /** Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV3 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type v1CreatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePolicyIntentV3;
};

export type v1CreatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1CreatePrivateKeyTagIntent = {
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeyTagIntent;
};

export type v1CreatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysIntent = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysIntentV2 = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeysIntentV2;
};

export type v1CreatePrivateKeysResult = {
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysResultV2 = {
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type v1CreateReadOnlySessionIntent = {};
export type v1CreateReadOnlySessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadOnlySessionIntent;
};

export type v1CreateReadOnlySessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type v1CreateReadWriteSessionIntent = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Email of the user to create a read write session for */
  email: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
};

export type v1CreateReadWriteSessionIntentV2 = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type v1CreateReadWriteSessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadWriteSessionIntentV2;
};

export type v1CreateReadWriteSessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateReadWriteSessionResultV2 = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateSmartContractInterfaceIntent = {
  /** Corresponding contract address or program ID */
  smartContractAddress: string;
  /** ABI/IDL as a JSON string */
  smartContractInterface: string;
  type: v1SmartContractInterfaceType;
  /** Human-readable name for a Smart Contract Interface. */
  label?: string;
  /** Notes for a Smart Contract Interface. */
  notes?: string;
};

export type v1CreateSmartContractInterfaceRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateSmartContractInterfaceIntent;
};

export type v1CreateSmartContractInterfaceResult = {
  /** The ID of the created Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type v1CreateSubOrganizationIntent = {
  /** Name for this sub-organization */
  name: string;
  /** Root User authenticator for this new sub-organization */
  rootAuthenticator: v1AuthenticatorParamsV2;
};

export type v1CreateSubOrganizationIntentV2 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
};

export type v1CreateSubOrganizationIntentV3 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreateSubOrganizationIntentV4 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV5 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV2[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV6 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV3[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV7 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1CreateSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateSubOrganizationIntentV7;
};

export type v1CreateSubOrganizationResult = {
  subOrganizationId: string;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV3 = {
  subOrganizationId: string;
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV4 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV5 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV6 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV7 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateUserTagIntent = {
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUserTagIntent;
};

export type v1CreateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUsersIntent = {
  /** A list of Users. */
  users: v1UserParams[];
};

export type v1CreateUsersIntentV2 = {
  /** A list of Users. */
  users: v1UserParamsV2[];
};

export type v1CreateUsersIntentV3 = {
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type v1CreateUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUsersIntentV3;
};

export type v1CreateUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateWalletAccountsIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1CreateWalletAccountsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletAccountsIntent;
};

export type v1CreateWalletAccountsResult = {
  /** A list of derived addresses. */
  addresses: string[];
};

export type v1CreateWalletIntent = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1CreateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletIntent;
};

export type v1CreateWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1CredPropsAuthenticationExtensionsClientOutputs = {
  rk: boolean;
};

export type v1CredentialType =
  | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
  | "CREDENTIAL_TYPE_API_KEY_P256"
  | "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_SECP256K1"
  | "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_ED25519"
  | "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
  | "CREDENTIAL_TYPE_OAUTH_KEY_P256"
  | "CREDENTIAL_TYPE_LOGIN";

export type v1Curve = "CURVE_SECP256K1" | "CURVE_ED25519";

export type v1DeleteApiKeysIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteApiKeysIntent;
};

export type v1DeleteApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteAuthenticatorsIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1DeleteAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteAuthenticatorsIntent;
};

export type v1DeleteAuthenticatorsResult = {
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type v1DeleteInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type v1DeleteInvitationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteInvitationIntent;
};

export type v1DeleteInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type v1DeleteOauthProvidersIntent = {
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type v1DeleteOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteOauthProvidersIntent;
};

export type v1DeleteOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1DeleteOrganizationIntent = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeleteOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeletePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePolicyIntent;
};

export type v1DeletePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePrivateKeyTagsIntent = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type v1DeletePrivateKeyTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeyTagsIntent;
};

export type v1DeletePrivateKeyTagsResult = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1DeletePrivateKeysIntent = {
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeletePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeysIntent;
};

export type v1DeletePrivateKeysResult = {
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type v1DeleteSmartContractInterfaceIntent = {
  /** The ID of a Smart Contract Interface intended for deletion. */
  smartContractInterfaceId: string;
};

export type v1DeleteSmartContractInterfaceRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteSmartContractInterfaceIntent;
};

export type v1DeleteSmartContractInterfaceResult = {
  /** The ID of the deleted Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type v1DeleteSubOrganizationIntent = {
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteSubOrganizationIntent;
};

export type v1DeleteSubOrganizationResult = {
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type v1DeleteUserTagsIntent = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type v1DeleteUserTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUserTagsIntent;
};

export type v1DeleteUserTagsResult = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersIntent = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUsersIntent;
};

export type v1DeleteUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteWalletsIntent = {
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteWalletsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteWalletsIntent;
};

export type v1DeleteWalletsResult = {
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type v1DisablePrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1DisablePrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1DisableUserInitiatedAuthIntent = {
  /** Unique identifier for a given User. (representing the turnkey signer user id) */
  userId?: string;
  /** Unique identifier for a given Policy. (representing the turnkey signer associated policy) */
  policyId?: string;
};

export type v1DisableUserInitiatedAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DisableUserInitiatedAuthIntent;
};

export type v1DisableUserInitiatedAuthResult = {};
export type v1Effect = "EFFECT_ALLOW" | "EFFECT_DENY";

export type v1EmailAuthIntent = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthIntentV2 = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1EmailAuthIntentV2;
};

export type v1EmailAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type v1EmailCustomizationParams = {
  /** The name of the application. */
  appName?: string;
  /** A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
  logoUrl?: string;
  /** A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
  magicLinkTemplate?: string;
  /** JSON object containing key/value pairs to be used with custom templates. */
  templateVariables?: string;
  /** Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
  templateId?: string;
};

export type v1EnableUserInitiatedAuthIntent = {};
export type v1EnableUserInitiatedAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1EnableUserInitiatedAuthIntent;
};

export type v1EnableUserInitiatedAuthResult = {
  /** A User ID. */
  userId: string;
  /** A Policy ID. */
  policyId: string;
};

export type v1EwkSettingsParams = {
  /** Enable Sign in with Apple */
  appleEnabled?: boolean;
  /** Enable Sign in with Google */
  googleEnabled?: boolean;
  /** Enable Sign in with Facebook */
  facebookEnabled?: boolean;
  /** Whether to open OAuth providers in-page instead of a popup */
  openOauthInPage?: boolean;
};

export type v1ExportPrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportPrivateKeyIntent;
};

export type v1ExportPrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletAccountIntent = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportWalletAccountRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletAccountIntent;
};

export type v1ExportWalletAccountResult = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
};

export type v1ExportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletIntent;
};

export type v1ExportWalletResult = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1Feature = {
  name?: v1FeatureName;
  value?: string;
};

export type v1FeatureName =
  | "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBAUTHN_ORIGINS"
  | "FEATURE_NAME_EMAIL_AUTH"
  | "FEATURE_NAME_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBHOOK"
  | "FEATURE_NAME_SMS_AUTH"
  | "FEATURE_NAME_OTP_EMAIL_AUTH";

export type v1FiatOnRampBlockchainNetwork =
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE";

export type v1FiatOnRampCryptoCurrency =
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";

export type v1FiatOnRampCurrency =
  | "FIAT_ON_RAMP_CURRENCY_AUD"
  | "FIAT_ON_RAMP_CURRENCY_BGN"
  | "FIAT_ON_RAMP_CURRENCY_BRL"
  | "FIAT_ON_RAMP_CURRENCY_CAD"
  | "FIAT_ON_RAMP_CURRENCY_CHF"
  | "FIAT_ON_RAMP_CURRENCY_COP"
  | "FIAT_ON_RAMP_CURRENCY_CZK"
  | "FIAT_ON_RAMP_CURRENCY_DKK"
  | "FIAT_ON_RAMP_CURRENCY_DOP"
  | "FIAT_ON_RAMP_CURRENCY_EGP"
  | "FIAT_ON_RAMP_CURRENCY_EUR"
  | "FIAT_ON_RAMP_CURRENCY_GBP"
  | "FIAT_ON_RAMP_CURRENCY_HKD"
  | "FIAT_ON_RAMP_CURRENCY_IDR"
  | "FIAT_ON_RAMP_CURRENCY_ILS"
  | "FIAT_ON_RAMP_CURRENCY_JOD"
  | "FIAT_ON_RAMP_CURRENCY_KES"
  | "FIAT_ON_RAMP_CURRENCY_KWD"
  | "FIAT_ON_RAMP_CURRENCY_LKR"
  | "FIAT_ON_RAMP_CURRENCY_MXN"
  | "FIAT_ON_RAMP_CURRENCY_NGN"
  | "FIAT_ON_RAMP_CURRENCY_NOK"
  | "FIAT_ON_RAMP_CURRENCY_NZD"
  | "FIAT_ON_RAMP_CURRENCY_OMR"
  | "FIAT_ON_RAMP_CURRENCY_PEN"
  | "FIAT_ON_RAMP_CURRENCY_PLN"
  | "FIAT_ON_RAMP_CURRENCY_RON"
  | "FIAT_ON_RAMP_CURRENCY_SEK"
  | "FIAT_ON_RAMP_CURRENCY_THB"
  | "FIAT_ON_RAMP_CURRENCY_TRY"
  | "FIAT_ON_RAMP_CURRENCY_TWD"
  | "FIAT_ON_RAMP_CURRENCY_USD"
  | "FIAT_ON_RAMP_CURRENCY_VND"
  | "FIAT_ON_RAMP_CURRENCY_ZAR";

export type v1FiatOnRampPaymentMethod =
  | "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT";

export type v1FiatOnRampProvider =
  | "FIAT_ON_RAMP_PROVIDER_COINBASE"
  | "FIAT_ON_RAMP_PROVIDER_MOONPAY";

export type v1GetActivitiesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Array of Activity Statuses filtering which Activities will be listed in the response. */
  filterByStatus?: v1ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
  /** Array of Activity Types filtering which Activities will be listed in the response. */
  filterByType?: v1ActivityType[];
};

export type v1GetActivitiesResponse = {
  /** A list of Activities. */
  activities: v1Activity[];
};

export type v1GetActivityRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Activity object. */
  activityId: string;
};

export type v1GetApiKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type v1GetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type v1GetApiKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type v1GetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type v1GetAttestationDocumentRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser */
  enclaveType: string;
};

export type v1GetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document */
  attestationDocument: string;
};

export type v1GetAuthenticatorRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
};

export type v1GetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type v1GetAuthenticatorsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1GetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type v1GetOauthProvidersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type v1GetOauthProvidersResponse = {
  /** A list of Oauth Providers */
  oauthProviders: v1OauthProvider[];
};

export type v1GetOrganizationConfigsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features */
  configs: v1Config;
};

export type v1GetOrganizationRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
  organizationData: v1OrganizationData;
};

export type v1GetPoliciesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetPoliciesResponse = {
  /** A list of Policies. */
  policies: v1Policy[];
};

export type v1GetPolicyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1GetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an Organization. */
  policy: v1Policy;
};

export type v1GetPrivateKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1GetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type v1GetPrivateKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetPrivateKeysResponse = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKey[];
};

export type v1GetProxyAuthConfigRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetProxyAuthConfigResponse = {
  /** Proxy authentication configuration (e.g., allowed origins). */
  proxyAuthConfig: v1ProxyAuthConfig;
};

export type v1GetSmartContractInterfaceRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type v1GetSmartContractInterfaceResponse = {
  /** Object to be used in conjunction with Policies to guard transaction signing. */
  smartContractInterface: v1SmartContractInterface;
};

export type v1GetSmartContractInterfacesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetSmartContractInterfacesResponse = {
  /** A list of Smart Contract Interfaces. */
  smartContractInterfaces: v1SmartContractInterface[];
};

export type v1GetSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetUserRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1GetUserResponse = {
  /** Web and/or API user within your Organization. */
  user: v1User;
};

export type v1GetUsersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetUsersResponse = {
  /** A list of Users. */
  users: v1User[];
};

export type v1GetVerifiedSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetWalletAccountRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Address corresponding to a Wallet Account. */
  address?: string;
  /** Path corresponding to a Wallet Account. */
  path?: string;
};

export type v1GetWalletAccountResponse = {
  /** The resulting Wallet Account. */
  account: v1WalletAccount;
};

export type v1GetWalletAccountsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetWalletAccountsResponse = {
  /** A list of Accounts generated from a Wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type v1GetWalletRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
};

export type v1GetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
  wallet: v1Wallet;
};

export type v1GetWalletsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetWalletsResponse = {
  /** A list of Wallets. */
  wallets: v1Wallet[];
};

export type v1GetWhoamiRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
};

export type v1GetWhoamiResponse = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
};

export type v1HashFunction =
  | "HASH_FUNCTION_NO_OP"
  | "HASH_FUNCTION_SHA256"
  | "HASH_FUNCTION_KECCAK256"
  | "HASH_FUNCTION_NOT_APPLICABLE";

export type v1ImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1ImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportPrivateKeyIntent;
};

export type v1ImportPrivateKeyResult = {
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type v1ImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1ImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportWalletIntent;
};

export type v1ImportWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1InitFiatOnRampIntent = {
  /** Enum to specifiy which on-ramp provider to use */
  onrampProvider: v1FiatOnRampProvider;
  /** Destination wallet address for the buy transaction. */
  walletAddress: string;
  /** Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork. */
  network: v1FiatOnRampBlockchainNetwork;
  /** Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset. */
  cryptoCurrencyCode: v1FiatOnRampCryptoCurrency;
  /** Code for the fiat currency to be used in the transaction, e.g., USD, EUR. */
  fiatCurrencyCode?: v1FiatOnRampCurrency;
  /** Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount. */
  fiatCurrencyAmount?: string;
  /** Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider. */
  paymentMethod?: v1FiatOnRampPaymentMethod;
  /** ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB. */
  countryCode?: string;
  /** ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US. */
  countrySubdivisionCode?: string;
};

export type v1InitFiatOnRampRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitFiatOnRampIntent;
};

export type v1InitFiatOnRampResult = {
  /** Unique URL for a given fiat on-ramp flow. */
  onRampUrl: string;
  /** Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow. */
  onRampTransactionId: string;
};

export type v1InitImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type v1InitImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportPrivateKeyIntent;
};

export type v1InitImportPrivateKeyResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type v1InitImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportWalletIntent;
};

export type v1InitImportWalletResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitOtpAuthIntent = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthIntentV2 = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpAuthIntentV2;
};

export type v1InitOtpAuthResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpAuthResultV2 = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpIntent = {
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpIntent;
};

export type v1InitOtpResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitUserEmailRecoveryIntent = {
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
};

export type v1InitUserEmailRecoveryRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitUserEmailRecoveryIntent;
};

export type v1InitUserEmailRecoveryResult = {
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type v1Intent = {
  createOrganizationIntent?: v1CreateOrganizationIntent;
  createAuthenticatorsIntent?: v1CreateAuthenticatorsIntent;
  createUsersIntent?: v1CreateUsersIntent;
  createPrivateKeysIntent?: v1CreatePrivateKeysIntent;
  signRawPayloadIntent?: v1SignRawPayloadIntent;
  createInvitationsIntent?: v1CreateInvitationsIntent;
  acceptInvitationIntent?: v1AcceptInvitationIntent;
  createPolicyIntent?: v1CreatePolicyIntent;
  disablePrivateKeyIntent?: v1DisablePrivateKeyIntent;
  deleteUsersIntent?: v1DeleteUsersIntent;
  deleteAuthenticatorsIntent?: v1DeleteAuthenticatorsIntent;
  deleteInvitationIntent?: v1DeleteInvitationIntent;
  deleteOrganizationIntent?: v1DeleteOrganizationIntent;
  deletePolicyIntent?: v1DeletePolicyIntent;
  createUserTagIntent?: v1CreateUserTagIntent;
  deleteUserTagsIntent?: v1DeleteUserTagsIntent;
  signTransactionIntent?: v1SignTransactionIntent;
  createApiKeysIntent?: v1CreateApiKeysIntent;
  deleteApiKeysIntent?: v1DeleteApiKeysIntent;
  approveActivityIntent?: v1ApproveActivityIntent;
  rejectActivityIntent?: v1RejectActivityIntent;
  createPrivateKeyTagIntent?: v1CreatePrivateKeyTagIntent;
  deletePrivateKeyTagsIntent?: v1DeletePrivateKeyTagsIntent;
  createPolicyIntentV2?: v1CreatePolicyIntentV2;
  setPaymentMethodIntent?: billingSetPaymentMethodIntent;
  activateBillingTierIntent?: billingActivateBillingTierIntent;
  deletePaymentMethodIntent?: billingDeletePaymentMethodIntent;
  createPolicyIntentV3?: v1CreatePolicyIntentV3;
  createApiOnlyUsersIntent?: v1CreateApiOnlyUsersIntent;
  updateRootQuorumIntent?: v1UpdateRootQuorumIntent;
  updateUserTagIntent?: v1UpdateUserTagIntent;
  updatePrivateKeyTagIntent?: v1UpdatePrivateKeyTagIntent;
  createAuthenticatorsIntentV2?: v1CreateAuthenticatorsIntentV2;
  acceptInvitationIntentV2?: v1AcceptInvitationIntentV2;
  createOrganizationIntentV2?: v1CreateOrganizationIntentV2;
  createUsersIntentV2?: v1CreateUsersIntentV2;
  createSubOrganizationIntent?: v1CreateSubOrganizationIntent;
  createSubOrganizationIntentV2?: v1CreateSubOrganizationIntentV2;
  updateAllowedOriginsIntent?: v1UpdateAllowedOriginsIntent;
  createPrivateKeysIntentV2?: v1CreatePrivateKeysIntentV2;
  updateUserIntent?: v1UpdateUserIntent;
  updatePolicyIntent?: v1UpdatePolicyIntent;
  setPaymentMethodIntentV2?: billingSetPaymentMethodIntentV2;
  createSubOrganizationIntentV3?: v1CreateSubOrganizationIntentV3;
  createWalletIntent?: v1CreateWalletIntent;
  createWalletAccountsIntent?: v1CreateWalletAccountsIntent;
  initUserEmailRecoveryIntent?: v1InitUserEmailRecoveryIntent;
  recoverUserIntent?: v1RecoverUserIntent;
  setOrganizationFeatureIntent?: v1SetOrganizationFeatureIntent;
  removeOrganizationFeatureIntent?: v1RemoveOrganizationFeatureIntent;
  signRawPayloadIntentV2?: v1SignRawPayloadIntentV2;
  signTransactionIntentV2?: v1SignTransactionIntentV2;
  exportPrivateKeyIntent?: v1ExportPrivateKeyIntent;
  exportWalletIntent?: v1ExportWalletIntent;
  createSubOrganizationIntentV4?: v1CreateSubOrganizationIntentV4;
  emailAuthIntent?: v1EmailAuthIntent;
  exportWalletAccountIntent?: v1ExportWalletAccountIntent;
  initImportWalletIntent?: v1InitImportWalletIntent;
  importWalletIntent?: v1ImportWalletIntent;
  initImportPrivateKeyIntent?: v1InitImportPrivateKeyIntent;
  importPrivateKeyIntent?: v1ImportPrivateKeyIntent;
  createPoliciesIntent?: v1CreatePoliciesIntent;
  signRawPayloadsIntent?: v1SignRawPayloadsIntent;
  createReadOnlySessionIntent?: v1CreateReadOnlySessionIntent;
  createOauthProvidersIntent?: v1CreateOauthProvidersIntent;
  deleteOauthProvidersIntent?: v1DeleteOauthProvidersIntent;
  createSubOrganizationIntentV5?: v1CreateSubOrganizationIntentV5;
  oauthIntent?: v1OauthIntent;
  createApiKeysIntentV2?: v1CreateApiKeysIntentV2;
  createReadWriteSessionIntent?: v1CreateReadWriteSessionIntent;
  emailAuthIntentV2?: v1EmailAuthIntentV2;
  createSubOrganizationIntentV6?: v1CreateSubOrganizationIntentV6;
  deletePrivateKeysIntent?: v1DeletePrivateKeysIntent;
  deleteWalletsIntent?: v1DeleteWalletsIntent;
  createReadWriteSessionIntentV2?: v1CreateReadWriteSessionIntentV2;
  deleteSubOrganizationIntent?: v1DeleteSubOrganizationIntent;
  initOtpAuthIntent?: v1InitOtpAuthIntent;
  otpAuthIntent?: v1OtpAuthIntent;
  createSubOrganizationIntentV7?: v1CreateSubOrganizationIntentV7;
  updateWalletIntent?: v1UpdateWalletIntent;
  updatePolicyIntentV2?: v1UpdatePolicyIntentV2;
  createUsersIntentV3?: v1CreateUsersIntentV3;
  initOtpAuthIntentV2?: v1InitOtpAuthIntentV2;
  initOtpIntent?: v1InitOtpIntent;
  verifyOtpIntent?: v1VerifyOtpIntent;
  otpLoginIntent?: v1OtpLoginIntent;
  stampLoginIntent?: v1StampLoginIntent;
  oauthLoginIntent?: v1OauthLoginIntent;
  updateUserNameIntent?: v1UpdateUserNameIntent;
  updateUserEmailIntent?: v1UpdateUserEmailIntent;
  updateUserPhoneNumberIntent?: v1UpdateUserPhoneNumberIntent;
  initFiatOnRampIntent?: v1InitFiatOnRampIntent;
  createSmartContractInterfaceIntent?: v1CreateSmartContractInterfaceIntent;
  deleteSmartContractInterfaceIntent?: v1DeleteSmartContractInterfaceIntent;
  enableUserInitiatedAuthIntent?: v1EnableUserInitiatedAuthIntent;
  disableUserInitiatedAuthIntent?: v1DisableUserInitiatedAuthIntent;
  updateProxyAuthConfigIntent?: v1UpdateProxyAuthConfigIntent;
};

export type v1Invitation = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverEmail: string;
  /** A list of tags assigned to the Invitation recipient. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** The current processing status of a specified Invitation. */
  status: v1InvitationStatus;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationParams = {
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverUserEmail: string;
  /** A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationStatus =
  | "INVITATION_STATUS_CREATED"
  | "INVITATION_STATUS_ACCEPTED"
  | "INVITATION_STATUS_REVOKED";

export type v1ListPrivateKeyTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1ListPrivateKeyTagsResponse = {
  /** A list of Private Key Tags */
  privateKeyTags: datav1Tag[];
};

export type v1ListUserTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1ListUserTagsResponse = {
  /** A list of User Tags */
  userTags: datav1Tag[];
};

export type v1MnemonicLanguage =
  | "MNEMONIC_LANGUAGE_ENGLISH"
  | "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
  | "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
  | "MNEMONIC_LANGUAGE_CZECH"
  | "MNEMONIC_LANGUAGE_FRENCH"
  | "MNEMONIC_LANGUAGE_ITALIAN"
  | "MNEMONIC_LANGUAGE_JAPANESE"
  | "MNEMONIC_LANGUAGE_KOREAN"
  | "MNEMONIC_LANGUAGE_SPANISH";

export type v1NOOPCodegenAnchorResponse = {
  stamp: v1WebAuthnStamp;
};

export type v1OauthIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthLoginIntent;
};

export type v1OauthLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1OauthProvider = {
  /** Unique identifier for an OAuth Provider */
  providerId: string;
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
  issuer: string;
  /** Expected audience ('aud' attribute of the signed token) which represents the app ID */
  audience: string;
  /** Expected subject ('sub' attribute of the signed token) which represents the user ID */
  subject: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1OauthProviderParams = {
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
};

export type v1OauthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthIntent;
};

export type v1OauthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1Operator =
  | "OPERATOR_EQUAL"
  | "OPERATOR_MORE_THAN"
  | "OPERATOR_MORE_THAN_OR_EQUAL"
  | "OPERATOR_LESS_THAN"
  | "OPERATOR_LESS_THAN_OR_EQUAL"
  | "OPERATOR_CONTAINS"
  | "OPERATOR_NOT_EQUAL"
  | "OPERATOR_IN"
  | "OPERATOR_NOT_IN"
  | "OPERATOR_CONTAINS_ONE"
  | "OPERATOR_CONTAINS_ALL";

export type v1OrganizationData = {
  organizationId?: string;
  name?: string;
  users?: v1User[];
  policies?: v1Policy[];
  privateKeys?: v1PrivateKey[];
  invitations?: v1Invitation[];
  tags?: datav1Tag[];
  rootQuorum?: externaldatav1Quorum;
  features?: v1Feature[];
  wallets?: v1Wallet[];
};

export type v1OtpAuthIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type v1OtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpAuthIntent;
};

export type v1OtpAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type v1OtpLoginIntent = {
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1OtpLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpLoginIntent;
};

export type v1OtpLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1Pagination = {
  /** A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
  limit?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
  before?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
  after?: string;
};

export type v1PathFormat = "PATH_FORMAT_BIP32";

export type v1PayloadEncoding =
  | "PAYLOAD_ENCODING_HEXADECIMAL"
  | "PAYLOAD_ENCODING_TEXT_UTF8"
  | "PAYLOAD_ENCODING_EIP712";

export type v1Policy = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Human-readable notes added by a User to describe a particular policy. */
  notes: string;
  /** A consensus expression that evalutes to true or false. */
  consensus: string;
  /** A condition expression that evalutes to true or false. */
  condition: string;
};

export type v1PrivateKey = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Derived cryptocurrency addresses for a given Private Key. */
  addresses: externaldatav1Address[];
  /** A list of Private Key Tag IDs. */
  privateKeyTags: string[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Private Key is exported, false otherwise. */
  exported: boolean;
  /** True when a given Private Key is imported, false otherwise. */
  imported: boolean;
};

export type v1PrivateKeyParams = {
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
  privateKeyTags: string[];
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1PrivateKeyResult = {
  privateKeyId?: string;
  addresses?: immutableactivityv1Address[];
};

export type v1ProxyAuthConfig = {
  organizationId?: string;
  allowedOrigins?: string[];
  allowedAuthMethods?: string[];
  encryptedApiKey?: string;
  turnkeySignerUserId?: string;
  sendFromEmailAddress?: string;
  replyToEmailAddress?: string;
  emailAuthTemplateId?: string;
  otpTemplateId?: string;
  emailCustomizationParams?: string;
  smsCustomizationParams?: string;
  otpExpirationSeconds?: number;
  verificationTokenExpirationSeconds?: number;
  otpSessionExpirationSeconds?: number;
  oauthSessionExpirationSeconds?: number;
  passkeySessionExpirationSeconds?: number;
  walletSessionExpirationSeconds?: number;
  createdAt?: string;
  updatedAt?: string;
  otpAlphanumeric?: boolean;
  otpLength?: number;
  socialLinking?: boolean;
  policyId?: string;
  proxyId?: string;
  ewkSettings?: string;
};

export type v1PublicKeyCredentialWithAttestation = {
  id: string;
  type: string;
  rawId: string;
  authenticatorAttachment?: string;
  response: v1AuthenticatorAttestationResponse;
  clientExtensionResults: v1SimpleClientExtensionResults;
};

export type v1RecoverUserIntent = {
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type v1RecoverUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RecoverUserIntent;
};

export type v1RecoverUserResult = {
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type v1RejectActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1RejectActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RejectActivityIntent;
};

export type v1RemoveOrganizationFeatureIntent = {
  /** Name of the feature to remove */
  name: v1FeatureName;
};

export type v1RemoveOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RemoveOrganizationFeatureIntent;
};

export type v1RemoveOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1Result = {
  createOrganizationResult?: v1CreateOrganizationResult;
  createAuthenticatorsResult?: v1CreateAuthenticatorsResult;
  createUsersResult?: v1CreateUsersResult;
  createPrivateKeysResult?: v1CreatePrivateKeysResult;
  createInvitationsResult?: v1CreateInvitationsResult;
  acceptInvitationResult?: v1AcceptInvitationResult;
  signRawPayloadResult?: v1SignRawPayloadResult;
  createPolicyResult?: v1CreatePolicyResult;
  disablePrivateKeyResult?: v1DisablePrivateKeyResult;
  deleteUsersResult?: v1DeleteUsersResult;
  deleteAuthenticatorsResult?: v1DeleteAuthenticatorsResult;
  deleteInvitationResult?: v1DeleteInvitationResult;
  deleteOrganizationResult?: v1DeleteOrganizationResult;
  deletePolicyResult?: v1DeletePolicyResult;
  createUserTagResult?: v1CreateUserTagResult;
  deleteUserTagsResult?: v1DeleteUserTagsResult;
  signTransactionResult?: v1SignTransactionResult;
  deleteApiKeysResult?: v1DeleteApiKeysResult;
  createApiKeysResult?: v1CreateApiKeysResult;
  createPrivateKeyTagResult?: v1CreatePrivateKeyTagResult;
  deletePrivateKeyTagsResult?: v1DeletePrivateKeyTagsResult;
  setPaymentMethodResult?: billingSetPaymentMethodResult;
  activateBillingTierResult?: billingActivateBillingTierResult;
  deletePaymentMethodResult?: billingDeletePaymentMethodResult;
  createApiOnlyUsersResult?: v1CreateApiOnlyUsersResult;
  updateRootQuorumResult?: v1UpdateRootQuorumResult;
  updateUserTagResult?: v1UpdateUserTagResult;
  updatePrivateKeyTagResult?: v1UpdatePrivateKeyTagResult;
  createSubOrganizationResult?: v1CreateSubOrganizationResult;
  updateAllowedOriginsResult?: v1UpdateAllowedOriginsResult;
  createPrivateKeysResultV2?: v1CreatePrivateKeysResultV2;
  updateUserResult?: v1UpdateUserResult;
  updatePolicyResult?: v1UpdatePolicyResult;
  createSubOrganizationResultV3?: v1CreateSubOrganizationResultV3;
  createWalletResult?: v1CreateWalletResult;
  createWalletAccountsResult?: v1CreateWalletAccountsResult;
  initUserEmailRecoveryResult?: v1InitUserEmailRecoveryResult;
  recoverUserResult?: v1RecoverUserResult;
  setOrganizationFeatureResult?: v1SetOrganizationFeatureResult;
  removeOrganizationFeatureResult?: v1RemoveOrganizationFeatureResult;
  exportPrivateKeyResult?: v1ExportPrivateKeyResult;
  exportWalletResult?: v1ExportWalletResult;
  createSubOrganizationResultV4?: v1CreateSubOrganizationResultV4;
  emailAuthResult?: v1EmailAuthResult;
  exportWalletAccountResult?: v1ExportWalletAccountResult;
  initImportWalletResult?: v1InitImportWalletResult;
  importWalletResult?: v1ImportWalletResult;
  initImportPrivateKeyResult?: v1InitImportPrivateKeyResult;
  importPrivateKeyResult?: v1ImportPrivateKeyResult;
  createPoliciesResult?: v1CreatePoliciesResult;
  signRawPayloadsResult?: v1SignRawPayloadsResult;
  createReadOnlySessionResult?: v1CreateReadOnlySessionResult;
  createOauthProvidersResult?: v1CreateOauthProvidersResult;
  deleteOauthProvidersResult?: v1DeleteOauthProvidersResult;
  createSubOrganizationResultV5?: v1CreateSubOrganizationResultV5;
  oauthResult?: v1OauthResult;
  createReadWriteSessionResult?: v1CreateReadWriteSessionResult;
  createSubOrganizationResultV6?: v1CreateSubOrganizationResultV6;
  deletePrivateKeysResult?: v1DeletePrivateKeysResult;
  deleteWalletsResult?: v1DeleteWalletsResult;
  createReadWriteSessionResultV2?: v1CreateReadWriteSessionResultV2;
  deleteSubOrganizationResult?: v1DeleteSubOrganizationResult;
  initOtpAuthResult?: v1InitOtpAuthResult;
  otpAuthResult?: v1OtpAuthResult;
  createSubOrganizationResultV7?: v1CreateSubOrganizationResultV7;
  updateWalletResult?: v1UpdateWalletResult;
  updatePolicyResultV2?: v1UpdatePolicyResultV2;
  initOtpAuthResultV2?: v1InitOtpAuthResultV2;
  initOtpResult?: v1InitOtpResult;
  verifyOtpResult?: v1VerifyOtpResult;
  otpLoginResult?: v1OtpLoginResult;
  stampLoginResult?: v1StampLoginResult;
  oauthLoginResult?: v1OauthLoginResult;
  updateUserNameResult?: v1UpdateUserNameResult;
  updateUserEmailResult?: v1UpdateUserEmailResult;
  updateUserPhoneNumberResult?: v1UpdateUserPhoneNumberResult;
  initFiatOnRampResult?: v1InitFiatOnRampResult;
  createSmartContractInterfaceResult?: v1CreateSmartContractInterfaceResult;
  deleteSmartContractInterfaceResult?: v1DeleteSmartContractInterfaceResult;
  enableUserInitiatedAuthResult?: v1EnableUserInitiatedAuthResult;
  disableUserInitiatedAuthResult?: v1DisableUserInitiatedAuthResult;
  updateProxyAuthConfigResult?: v1UpdateProxyAuthConfigResult;
};

export type v1RootUserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
};

export type v1RootUserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV4 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1Selector = {
  subject?: string;
  operator?: v1Operator;
  target?: string;
};

export type v1SelectorV2 = {
  subject?: string;
  operator?: v1Operator;
  targets?: string[];
};

export type v1SetOrganizationFeatureIntent = {
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type v1SetOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SetOrganizationFeatureIntent;
};

export type v1SetOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1SignRawPayloadIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadIntentV2;
};

export type v1SignRawPayloadResult = {
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type v1SignRawPayloadsIntent = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadsIntent;
};

export type v1SignRawPayloadsResult = {
  signatures?: v1SignRawPayloadResult[];
};

export type v1SignTransactionIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned transaction to be signed by a particular Private Key. */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignTransactionIntentV2;
};

export type v1SignTransactionResult = {
  signedTransaction: string;
};

export type v1SimpleClientExtensionResults = {
  appid?: boolean;
  appidExclude?: boolean;
  credProps?: v1CredPropsAuthenticationExtensionsClientOutputs;
};

export type v1SmartContractInterface = {
  /** The Organization the Smart Contract Interface belongs to. */
  organizationId: string;
  /** Unique identifier for a given Smart Contract Interface (ABI or IDL). */
  smartContractInterfaceId: string;
  /** The address corresponding to the Smart Contract or Program. */
  contractAddress: string;
  /** The JSON corresponding to the Smart Contract Interface. */
  interface: string;
  /** The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  type: string;
  /** The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  label: string;
  /** The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  notes: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1SmartContractInterfaceType =
  | "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM"
  | "SMART_CONTRACT_INTERFACE_TYPE_SOLANA";

export type v1SmsCustomizationParams = {
  /** Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
  template?: string;
};

export type v1StampLoginIntent = {
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1StampLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1StampLoginIntent;
};

export type v1StampLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1TagType = "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";

export type v1TestRateLimitsRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true */
  limit: number;
};

export type v1TestRateLimitsResponse = {};
export type v1TransactionType =
  | "TRANSACTION_TYPE_ETHEREUM"
  | "TRANSACTION_TYPE_SOLANA"
  | "TRANSACTION_TYPE_TRON";

export type v1UpdateAllowedOriginsIntent = {
  /** Additional origins requests are allowed from besides Turnkey origins */
  allowedOrigins: string[];
};

export type v1UpdateAllowedOriginsResult = {};
export type v1UpdatePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyIntentV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePolicyIntentV2;
};

export type v1UpdatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePolicyResultV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePrivateKeyTagIntent = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type v1UpdatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePrivateKeyTagIntent;
};

export type v1UpdatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type v1UpdateProxyAuthConfigIntent = {
  /** Updated list of allowed origins for CORS. */
  allowedOrigins?: string[];
  /** Updated list of allowed origins for CORS. */
  allowedAuthMethods?: string[];
  /** Custom 'from' address for auth-related emails. */
  sendFromEmailAddress?: string;
  /** Custom reply-to address for auth-related emails. */
  replyToEmailAddress?: string;
  /** Template ID for email-auth messages. */
  emailAuthTemplateId?: string;
  /** Template ID for OTP SMS messages. */
  otpTemplateId?: string;
  /** Overrides for auth-related email content. */
  emailCustomizationParams?: v1EmailCustomizationParams;
  /** Overrides for auth-related SMS content. */
  smsCustomizationParams?: v1SmsCustomizationParams;
  /** Overrides for EWK related settings. */
  ewkSettings?: v1EwkSettingsParams;
  /** OTP code lifetime in seconds. */
  otpExpirationSeconds?: number;
  /** Verification-token lifetime in seconds. */
  verificationTokenExpirationSeconds?: number;
  /** OTP session lifetime in seconds. */
  otpSessionExpirationSeconds?: number;
  /** Passkey session lifetime in seconds. */
  passkeySessionExpirationSeconds?: number;
  /** Wallet session lifetime in seconds. */
  walletSessionExpirationSeconds?: number;
  /** OAuth session lifetime in seconds. */
  oauthSessionExpirationSeconds?: number;
  /** Enable alphanumeric OTP codes. */
  otpAlphanumeric?: boolean;
  /** Desired OTP code length (69). */
  otpLength?: number;
  /** Enable social linking (userEmail <-> gmail) */
  socialLinking?: boolean;
};

export type v1UpdateProxyAuthConfigRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateProxyAuthConfigIntent;
};

export type v1UpdateProxyAuthConfigResult = {};
export type v1UpdateRootQuorumIntent = {
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type v1UpdateRootQuorumRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateRootQuorumIntent;
};

export type v1UpdateRootQuorumResult = {};
export type v1UpdateUserEmailIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's email address. Setting this to an empty string will remove the user's email. */
  userEmail: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1UpdateUserEmailRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserEmailIntent;
};

export type v1UpdateUserEmailResult = {
  /** Unique identifier of the User whose email was updated. */
  userId: string;
};

export type v1UpdateUserIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type v1UpdateUserNameIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
};

export type v1UpdateUserNameRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserNameIntent;
};

export type v1UpdateUserNameResult = {
  /** Unique identifier of the User whose name was updated. */
  userId: string;
};

export type v1UpdateUserPhoneNumberIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number. */
  userPhoneNumber: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1UpdateUserPhoneNumberRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserPhoneNumberIntent;
};

export type v1UpdateUserPhoneNumberResult = {
  /** Unique identifier of the User whose phone number was updated. */
  userId: string;
};

export type v1UpdateUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserIntent;
};

export type v1UpdateUserResult = {
  /** A User ID. */
  userId: string;
};

export type v1UpdateUserTagIntent = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type v1UpdateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserTagIntent;
};

export type v1UpdateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type v1UpdateWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type v1UpdateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateWalletIntent;
};

export type v1UpdateWalletResult = {
  /** A Wallet ID. */
  walletId: string;
};

export type v1User = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of Authenticator parameters. */
  authenticators: v1Authenticator[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKey[];
  /** A list of User Tag IDs. */
  userTags: string[];
  /** A list of Oauth Providers. */
  oauthProviders: v1OauthProvider[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1UserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1VerifyOtpIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
};

export type v1VerifyOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1VerifyOtpIntent;
};

export type v1VerifyOtpResult = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type v1Vote = {
  /** Unique identifier for a given Vote object. */
  id: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Web and/or API user within your Organization. */
  user: v1User;
  /** Unique identifier for a given Activity object. */
  activityId: string;
  selection: string;
  /** The raw message being signed within a Vote. */
  message: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The signature applied to a particular vote. */
  signature: string;
  /** Method used to produce a signature. */
  scheme: string;
  createdAt: externaldatav1Timestamp;
};

export type v1Wallet = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Wallet is exported, false otherwise. */
  exported: boolean;
  /** True when a given Wallet is imported, false otherwise. */
  imported: boolean;
};

export type v1WalletAccount = {
  /** Unique identifier for a given Wallet Account. */
  walletAccountId: string;
  /** The Organization the Account belongs to. */
  organizationId: string;
  /** The Wallet the Account was derived from. */
  walletId: string;
  /** Cryptographic curve used to generate the Account. */
  curve: v1Curve;
  /** Path format used to generate the Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate the Account. */
  path: string;
  /** Address format used to generate the Account. */
  addressFormat: v1AddressFormat;
  /** Address generated using the Wallet seed and Account parameters. */
  address: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** The public component of this wallet account's underlying cryptographic key pair. */
  publicKey?: string;
};

export type v1WalletAccountParams = {
  /** Cryptographic curve used to generate a wallet Account. */
  curve: v1Curve;
  /** Path format used to generate a wallet Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate a wallet Account. */
  path: string;
  /** Address format used to generate a wallet Acccount. */
  addressFormat: v1AddressFormat;
};

export type v1WalletParams = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1WalletResult = {
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1WebAuthnStamp = {
  /** A base64 url encoded Unique identifier for a given credential. */
  credentialId: string;
  /** A base64 encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 encoded payload containing metadata about the authenticator. */
  authenticatorData: string;
  /** The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
  signature: string;
};

// --- API Types from Swagger Paths ---
export type TGetActivityResponse = {
  /** An action that can that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type TGetActivityBody = {
  organizationId?: string;
  /** Unique identifier for a given Activity object. */
  activityId: string;
};

export type TGetActivityInput = { body: TGetActivityBody };

export type TGetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type TGetApiKeyBody = {
  organizationId?: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type TGetApiKeyInput = { body: TGetApiKeyBody };

export type TGetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type TGetApiKeysBody = {
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type TGetApiKeysInput = { body: TGetApiKeysBody };

export type TGetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document */
  attestationDocument: string;
};

export type TGetAttestationDocumentBody = {
  organizationId?: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser */
  enclaveType: string;
};

export type TGetAttestationDocumentInput = {
  body: TGetAttestationDocumentBody;
};

export type TGetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type TGetAuthenticatorBody = {
  organizationId?: string;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
};

export type TGetAuthenticatorInput = { body: TGetAuthenticatorBody };

export type TGetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type TGetAuthenticatorsBody = {
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type TGetAuthenticatorsInput = { body: TGetAuthenticatorsBody };

export type TGetOauthProvidersResponse = {
  /** A list of Oauth Providers */
  oauthProviders: v1OauthProvider[];
};

export type TGetOauthProvidersBody = {
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type TGetOauthProvidersInput = { body: TGetOauthProvidersBody };

export type TGetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
  organizationData: v1OrganizationData;
};

export type TGetOrganizationBody = {
  organizationId?: string;
};

export type TGetOrganizationInput = { body: TGetOrganizationBody };

export type TGetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features */
  configs: v1Config;
};

export type TGetOrganizationConfigsBody = {
  organizationId?: string;
};

export type TGetOrganizationConfigsInput = {
  body: TGetOrganizationConfigsBody;
};

export type TGetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an Organization. */
  policy: v1Policy;
};

export type TGetPolicyBody = {
  organizationId?: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TGetPolicyInput = { body: TGetPolicyBody };

export type TGetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type TGetPrivateKeyBody = {
  organizationId?: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type TGetPrivateKeyInput = { body: TGetPrivateKeyBody };

export type TGetProxyAuthConfigResponse = {
  /** Proxy authentication configuration (e.g., allowed origins). */
  proxyAuthConfig: v1ProxyAuthConfig;
};

export type TGetProxyAuthConfigBody = {
  organizationId?: string;
};

export type TGetProxyAuthConfigInput = { body: TGetProxyAuthConfigBody };

export type TGetSmartContractInterfaceResponse = {
  /** Object to be used in conjunction with Policies to guard transaction signing. */
  smartContractInterface: v1SmartContractInterface;
};

export type TGetSmartContractInterfaceBody = {
  organizationId?: string;
  /** Unique identifier for a given Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type TGetSmartContractInterfaceInput = {
  body: TGetSmartContractInterfaceBody;
};

export type TGetUserResponse = {
  /** Web and/or API user within your Organization. */
  user: v1User;
};

export type TGetUserBody = {
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type TGetUserInput = { body: TGetUserBody };

export type TGetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
  wallet: v1Wallet;
};

export type TGetWalletBody = {
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
};

export type TGetWalletInput = { body: TGetWalletBody };

export type TGetWalletAccountResponse = {
  /** The resulting Wallet Account. */
  account: v1WalletAccount;
};

export type TGetWalletAccountBody = {
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Address corresponding to a Wallet Account. */
  address?: string;
  /** Path corresponding to a Wallet Account. */
  path?: string;
};

export type TGetWalletAccountInput = { body: TGetWalletAccountBody };

export type TGetActivitiesResponse = {
  /** A list of Activities. */
  activities: v1Activity[];
};

export type TGetActivitiesBody = {
  organizationId?: string;
  /** Array of Activity Statuses filtering which Activities will be listed in the response. */
  filterByStatus?: v1ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
  /** Array of Activity Types filtering which Activities will be listed in the response. */
  filterByType?: v1ActivityType[];
};

export type TGetActivitiesInput = { body: TGetActivitiesBody };

export type TGetPoliciesResponse = {
  /** A list of Policies. */
  policies: v1Policy[];
};

export type TGetPoliciesBody = {
  organizationId?: string;
};

export type TGetPoliciesInput = { body: TGetPoliciesBody };

export type TListPrivateKeyTagsResponse = {
  /** A list of Private Key Tags */
  privateKeyTags: datav1Tag[];
};

export type TListPrivateKeyTagsBody = {
  organizationId?: string;
};

export type TListPrivateKeyTagsInput = { body: TListPrivateKeyTagsBody };

export type TGetPrivateKeysResponse = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKey[];
};

export type TGetPrivateKeysBody = {
  organizationId?: string;
};

export type TGetPrivateKeysInput = { body: TGetPrivateKeysBody };

export type TGetSmartContractInterfacesResponse = {
  /** A list of Smart Contract Interfaces. */
  smartContractInterfaces: v1SmartContractInterface[];
};

export type TGetSmartContractInterfacesBody = {
  organizationId?: string;
};

export type TGetSmartContractInterfacesInput = {
  body: TGetSmartContractInterfacesBody;
};

export type TGetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type TGetSubOrgIdsBody = {
  organizationId?: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetSubOrgIdsInput = { body: TGetSubOrgIdsBody };

export type TListUserTagsResponse = {
  /** A list of User Tags */
  userTags: datav1Tag[];
};

export type TListUserTagsBody = {
  organizationId?: string;
};

export type TListUserTagsInput = { body: TListUserTagsBody };

export type TGetUsersResponse = {
  /** A list of Users. */
  users: v1User[];
};

export type TGetUsersBody = {
  organizationId?: string;
};

export type TGetUsersInput = { body: TGetUsersBody };

export type TGetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type TGetVerifiedSubOrgIdsBody = {
  organizationId?: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetVerifiedSubOrgIdsInput = { body: TGetVerifiedSubOrgIdsBody };

export type TGetWalletAccountsResponse = {
  /** A list of Accounts generated from a Wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type TGetWalletAccountsBody = {
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetWalletAccountsInput = { body: TGetWalletAccountsBody };

export type TGetWalletsResponse = {
  /** A list of Wallets. */
  wallets: v1Wallet[];
};

export type TGetWalletsBody = {
  organizationId?: string;
};

export type TGetWalletsInput = { body: TGetWalletsBody };

export type TGetWhoamiResponse = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
};

export type TGetWhoamiBody = {
  organizationId?: string;
};

export type TGetWhoamiInput = { body: TGetWhoamiBody };

export type TApproveActivityResponse = {
  activity: v1Activity;
};

export type TApproveActivityBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type TApproveActivityInput = { body: TApproveActivityBody };

export type TCreateApiKeysResponse = {
  activity: v1Activity;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TCreateApiKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type TCreateApiKeysInput = { body: TCreateApiKeysBody };

export type TCreateApiOnlyUsersResponse = {
  activity: v1Activity;
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type TCreateApiOnlyUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
};

export type TCreateApiOnlyUsersInput = { body: TCreateApiOnlyUsersBody };

export type TCreateAuthenticatorsResponse = {
  activity: v1Activity;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type TCreateAuthenticatorsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type TCreateAuthenticatorsInput = { body: TCreateAuthenticatorsBody };

export type TCreateInvitationsResponse = {
  activity: v1Activity;
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type TCreateInvitationsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
};

export type TCreateInvitationsInput = { body: TCreateInvitationsBody };

export type TCreateOauthProvidersResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type TCreateOauthProvidersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
};

export type TCreateOauthProvidersInput = { body: TCreateOauthProvidersBody };

export type TCreatePoliciesResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type TCreatePoliciesBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
};

export type TCreatePoliciesInput = { body: TCreatePoliciesBody };

export type TCreatePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TCreatePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type TCreatePolicyInput = { body: TCreatePolicyBody };

export type TCreatePrivateKeyTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TCreatePrivateKeyTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TCreatePrivateKeyTagInput = { body: TCreatePrivateKeyTagBody };

export type TCreatePrivateKeysResponse = {
  activity: v1Activity;
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type TCreatePrivateKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type TCreatePrivateKeysInput = { body: TCreatePrivateKeysBody };

export type TCreateReadOnlySessionResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type TCreateReadOnlySessionBody = {
  timestampMs?: string;
  organizationId?: string;
};

export type TCreateReadOnlySessionInput = { body: TCreateReadOnlySessionBody };

export type TCreateReadWriteSessionResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type TCreateReadWriteSessionBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type TCreateReadWriteSessionInput = {
  body: TCreateReadWriteSessionBody;
};

export type TCreateSmartContractInterfaceResponse = {
  activity: v1Activity;
  /** The ID of the created Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type TCreateSmartContractInterfaceBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Corresponding contract address or program ID */
  smartContractAddress: string;
  /** ABI/IDL as a JSON string */
  smartContractInterface: string;
  type: v1SmartContractInterfaceType;
  /** Human-readable name for a Smart Contract Interface. */
  label?: string;
  /** Notes for a Smart Contract Interface. */
  notes?: string;
};

export type TCreateSmartContractInterfaceInput = {
  body: TCreateSmartContractInterfaceBody;
};

export type TCreateSubOrganizationResponse = {
  activity: v1Activity;
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type TCreateSubOrganizationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TCreateSubOrganizationInput = { body: TCreateSubOrganizationBody };

export type TCreateUserTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUserTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUserTagInput = { body: TCreateUserTagBody };

export type TCreateUsersResponse = {
  activity: v1Activity;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type TCreateUsersInput = { body: TCreateUsersBody };

export type TCreateWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type TCreateWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type TCreateWalletInput = { body: TCreateWalletBody };

export type TCreateWalletAccountsResponse = {
  activity: v1Activity;
  /** A list of derived addresses. */
  addresses: string[];
};

export type TCreateWalletAccountsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type TCreateWalletAccountsInput = { body: TCreateWalletAccountsBody };

export type TDeleteApiKeysResponse = {
  activity: v1Activity;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TDeleteApiKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TDeleteApiKeysInput = { body: TDeleteApiKeysBody };

export type TDeleteAuthenticatorsResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type TDeleteAuthenticatorsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type TDeleteAuthenticatorsInput = { body: TDeleteAuthenticatorsBody };

export type TDeleteInvitationResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type TDeleteInvitationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type TDeleteInvitationInput = { body: TDeleteInvitationBody };

export type TDeleteOauthProvidersResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type TDeleteOauthProvidersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type TDeleteOauthProvidersInput = { body: TDeleteOauthProvidersBody };

export type TDeletePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TDeletePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TDeletePolicyInput = { body: TDeletePolicyBody };

export type TDeletePrivateKeyTagsResponse = {
  activity: v1Activity;
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TDeletePrivateKeyTagsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type TDeletePrivateKeyTagsInput = { body: TDeletePrivateKeyTagsBody };

export type TDeletePrivateKeysResponse = {
  activity: v1Activity;
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type TDeletePrivateKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type TDeletePrivateKeysInput = { body: TDeletePrivateKeysBody };

export type TDeleteSmartContractInterfaceResponse = {
  activity: v1Activity;
  /** The ID of the deleted Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type TDeleteSmartContractInterfaceBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of a Smart Contract Interface intended for deletion. */
  smartContractInterfaceId: string;
};

export type TDeleteSmartContractInterfaceInput = {
  body: TDeleteSmartContractInterfaceBody;
};

export type TDeleteSubOrganizationResponse = {
  activity: v1Activity;
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type TDeleteSubOrganizationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type TDeleteSubOrganizationInput = { body: TDeleteSubOrganizationBody };

export type TDeleteUserTagsResponse = {
  activity: v1Activity;
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUserTagsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type TDeleteUserTagsInput = { body: TDeleteUserTagsBody };

export type TDeleteUsersResponse = {
  activity: v1Activity;
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUsersInput = { body: TDeleteUsersBody };

export type TDeleteWalletsResponse = {
  activity: v1Activity;
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type TDeleteWalletsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type TDeleteWalletsInput = { body: TDeleteWalletsBody };

export type TDisableUserInitiatedAuthResponse = {
  activity: v1Activity;
};

export type TDisableUserInitiatedAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. (representing the turnkey signer user id) */
  userId?: string;
  /** Unique identifier for a given Policy. (representing the turnkey signer associated policy) */
  policyId?: string;
};

export type TDisableUserInitiatedAuthInput = {
  body: TDisableUserInitiatedAuthBody;
};

export type TEmailAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type TEmailAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TEmailAuthInput = { body: TEmailAuthBody };

export type TEnableUserInitiatedAuthResponse = {
  activity: v1Activity;
  /** A User ID. */
  userId: string;
  /** A Policy ID. */
  policyId: string;
};

export type TEnableUserInitiatedAuthBody = {
  timestampMs?: string;
  organizationId?: string;
};

export type TEnableUserInitiatedAuthInput = {
  body: TEnableUserInitiatedAuthBody;
};

export type TExportPrivateKeyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type TExportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type TExportPrivateKeyInput = { body: TExportPrivateKeyBody };

export type TExportWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type TExportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
};

export type TExportWalletInput = { body: TExportWalletBody };

export type TExportWalletAccountResponse = {
  activity: v1Activity;
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type TExportWalletAccountBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type TExportWalletAccountInput = { body: TExportWalletAccountBody };

export type TImportPrivateKeyResponse = {
  activity: v1Activity;
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type TImportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type TImportPrivateKeyInput = { body: TImportPrivateKeyBody };

export type TImportWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type TImportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type TImportWalletInput = { body: TImportWalletBody };

export type TInitFiatOnRampResponse = {
  activity: v1Activity;
  /** Unique URL for a given fiat on-ramp flow. */
  onRampUrl: string;
  /** Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow. */
  onRampTransactionId: string;
};

export type TInitFiatOnRampBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Enum to specifiy which on-ramp provider to use */
  onrampProvider: v1FiatOnRampProvider;
  /** Destination wallet address for the buy transaction. */
  walletAddress: string;
  /** Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork. */
  network: v1FiatOnRampBlockchainNetwork;
  /** Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset. */
  cryptoCurrencyCode: v1FiatOnRampCryptoCurrency;
  /** Code for the fiat currency to be used in the transaction, e.g., USD, EUR. */
  fiatCurrencyCode?: v1FiatOnRampCurrency;
  /** Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount. */
  fiatCurrencyAmount?: string;
  /** Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider. */
  paymentMethod?: v1FiatOnRampPaymentMethod;
  /** ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB. */
  countryCode?: string;
  /** ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US. */
  countrySubdivisionCode?: string;
};

export type TInitFiatOnRampInput = { body: TInitFiatOnRampBody };

export type TInitImportPrivateKeyResponse = {
  activity: v1Activity;
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type TInitImportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type TInitImportPrivateKeyInput = { body: TInitImportPrivateKeyBody };

export type TInitImportWalletResponse = {
  activity: v1Activity;
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type TInitImportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type TInitImportWalletInput = { body: TInitImportWalletBody };

export type TInitOtpResponse = {
  activity: v1Activity;
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type TInitOtpBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TInitOtpInput = { body: TInitOtpBody };

export type TInitOtpAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type TInitOtpAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TInitOtpAuthInput = { body: TInitOtpAuthBody };

export type TInitUserEmailRecoveryResponse = {
  activity: v1Activity;
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type TInitUserEmailRecoveryBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
};

export type TInitUserEmailRecoveryInput = { body: TInitUserEmailRecoveryBody };

export type TOauthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type TOauthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type TOauthInput = { body: TOauthBody };

export type TOauthLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TOauthLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type TOauthLoginInput = { body: TOauthLoginBody };

export type TOtpAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type TOtpAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type TOtpAuthInput = { body: TOtpAuthBody };

export type TOtpLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TOtpLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type TOtpLoginInput = { body: TOtpLoginBody };

export type TRecoverUserResponse = {
  activity: v1Activity;
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type TRecoverUserBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type TRecoverUserInput = { body: TRecoverUserBody };

export type TRejectActivityResponse = {
  activity: v1Activity;
};

export type TRejectActivityBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type TRejectActivityInput = { body: TRejectActivityBody };

export type TRemoveOrganizationFeatureResponse = {
  activity: v1Activity;
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type TRemoveOrganizationFeatureBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name of the feature to remove */
  name: v1FeatureName;
};

export type TRemoveOrganizationFeatureInput = {
  body: TRemoveOrganizationFeatureBody;
};

export type TSetOrganizationFeatureResponse = {
  activity: v1Activity;
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type TSetOrganizationFeatureBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type TSetOrganizationFeatureInput = {
  body: TSetOrganizationFeatureBody;
};

export type TSignRawPayloadResponse = {
  activity: v1Activity;
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type TSignRawPayloadBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type TSignRawPayloadInput = { body: TSignRawPayloadBody };

export type TSignRawPayloadsResponse = {
  activity: v1Activity;
  signatures?: v1SignRawPayloadResult[];
};

export type TSignRawPayloadsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type TSignRawPayloadsInput = { body: TSignRawPayloadsBody };

export type TSignTransactionResponse = {
  activity: v1Activity;
  signedTransaction: string;
};

export type TSignTransactionBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type TSignTransactionInput = { body: TSignTransactionBody };

export type TStampLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TStampLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type TStampLoginInput = { body: TStampLoginBody };

export type TUpdatePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TUpdatePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type TUpdatePolicyInput = { body: TUpdatePolicyBody };

export type TUpdatePrivateKeyTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type TUpdatePrivateKeyTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type TUpdatePrivateKeyTagInput = { body: TUpdatePrivateKeyTagBody };

export type TUpdateProxyAuthConfigResponse = {
  activity: v1Activity;
};

export type TUpdateProxyAuthConfigBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Updated list of allowed origins for CORS. */
  allowedOrigins?: string[];
  /** Updated list of allowed origins for CORS. */
  allowedAuthMethods?: string[];
  /** Custom 'from' address for auth-related emails. */
  sendFromEmailAddress?: string;
  /** Custom reply-to address for auth-related emails. */
  replyToEmailAddress?: string;
  /** Template ID for email-auth messages. */
  emailAuthTemplateId?: string;
  /** Template ID for OTP SMS messages. */
  otpTemplateId?: string;
  /** Overrides for auth-related email content. */
  emailCustomizationParams?: v1EmailCustomizationParams;
  /** Overrides for auth-related SMS content. */
  smsCustomizationParams?: v1SmsCustomizationParams;
  /** Overrides for EWK related settings. */
  ewkSettings?: v1EwkSettingsParams;
  /** OTP code lifetime in seconds. */
  otpExpirationSeconds?: number;
  /** Verification-token lifetime in seconds. */
  verificationTokenExpirationSeconds?: number;
  /** OTP session lifetime in seconds. */
  otpSessionExpirationSeconds?: number;
  /** Passkey session lifetime in seconds. */
  passkeySessionExpirationSeconds?: number;
  /** Wallet session lifetime in seconds. */
  walletSessionExpirationSeconds?: number;
  /** OAuth session lifetime in seconds. */
  oauthSessionExpirationSeconds?: number;
  /** Enable alphanumeric OTP codes. */
  otpAlphanumeric?: boolean;
  /** Desired OTP code length (69). */
  otpLength?: number;
  /** Enable social linking (userEmail <-> gmail) */
  socialLinking?: boolean;
};

export type TUpdateProxyAuthConfigInput = { body: TUpdateProxyAuthConfigBody };

export type TUpdateRootQuorumResponse = {
  activity: v1Activity;
};

export type TUpdateRootQuorumBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type TUpdateRootQuorumInput = { body: TUpdateRootQuorumBody };

export type TUpdateUserResponse = {
  activity: v1Activity;
  /** A User ID. */
  userId: string;
};

export type TUpdateUserBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type TUpdateUserInput = { body: TUpdateUserBody };

export type TUpdateUserEmailResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose email was updated. */
  userId: string;
};

export type TUpdateUserEmailBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's email address. Setting this to an empty string will remove the user's email. */
  userEmail: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TUpdateUserEmailInput = { body: TUpdateUserEmailBody };

export type TUpdateUserNameResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose name was updated. */
  userId: string;
};

export type TUpdateUserNameBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
};

export type TUpdateUserNameInput = { body: TUpdateUserNameBody };

export type TUpdateUserPhoneNumberResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose phone number was updated. */
  userId: string;
};

export type TUpdateUserPhoneNumberBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number. */
  userPhoneNumber: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TUpdateUserPhoneNumberInput = { body: TUpdateUserPhoneNumberBody };

export type TUpdateUserTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type TUpdateUserTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type TUpdateUserTagInput = { body: TUpdateUserTagBody };

export type TUpdateWalletResponse = {
  activity: v1Activity;
  /** A Wallet ID. */
  walletId: string;
};

export type TUpdateWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type TUpdateWalletInput = { body: TUpdateWalletBody };

export type TVerifyOtpResponse = {
  activity: v1Activity;
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type TVerifyOtpBody = {
  timestampMs?: string;
  organizationId?: string;
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
};

export type TVerifyOtpInput = { body: TVerifyOtpBody };

export type TNOOPCodegenAnchorResponse = {
  activity: v1Activity;
};

export type TTestRateLimitsResponse = {};

export type TTestRateLimitsBody = {
  organizationId?: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true */
  limit: number;
};

export type TTestRateLimitsInput = { body: TTestRateLimitsBody };
