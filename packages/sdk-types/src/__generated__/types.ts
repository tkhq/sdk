/* @generated by codegen. DO NOT EDIT BY HAND */

// --- Base Types from Swagger Definitions ---
export type apiApiKeyParams = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type billingActivateBillingTierIntent = {
  /** The product that the customer wants to subscribe to. */
  productId: string;
};

export type billingActivateBillingTierResult = {
  /** The id of the product being subscribed to. */
  productId: string;
};

export type billingDeletePaymentMethodIntent = {
  /** The payment method that the customer wants to remove. */
  paymentMethodId: string;
};

export type billingDeletePaymentMethodResult = {
  /** The payment method that was removed. */
  paymentMethodId: string;
};

export type billingSetPaymentMethodIntent = {
  /** The account number of the customer's credit card. */
  number: string;
  /** The verification digits of the customer's credit card. */
  cvv: string;
  /** The month that the credit card expires. */
  expiryMonth: string;
  /** The year that the credit card expires. */
  expiryYear: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodIntentV2 = {
  /** The id of the payment method that was created clientside. */
  paymentMethodId: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodResult = {
  /** The last four digits of the credit card added. */
  lastFour: string;
  /** The name associated with the payment method. */
  cardHolderName: string;
  /** The email address associated with the payment method. */
  cardHolderEmail: string;
};

export type datav1Tag = {
  /** Unique identifier for a given Tag. */
  tagId: string;
  /** Human-readable name for a Tag. */
  tagName: string;
  tagType: v1TagType;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type externaldatav1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type externaldatav1Credential = {
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  type: v1CredentialType;
};

export type externaldatav1Quorum = {
  /** Count of unique approvals required to meet quorum. */
  threshold: number;
  /** Unique identifiers of quorum set members. */
  userIds: string[];
};

export type externaldatav1Timestamp = {
  seconds: string;
  nanos: string;
};

export type immutableactivityv1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type protobufAny = {
  "@type"?: string;
  [key: string]: any;
};

export type rpcStatus = {
  code?: number;
  message?: string;
  details?: protobufAny[];
};

export type v1AcceptInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParams;
};

export type v1AcceptInvitationIntentV2 = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParamsV2;
};

export type v1AcceptInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1AccessType =
  "ACCESS_TYPE_WEB" |
  "ACCESS_TYPE_API" |
  "ACCESS_TYPE_ALL";

export type v1Activity = {
  /** Unique identifier for a given Activity object. */
  id: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The current processing status of a specified Activity. */
  status: v1ActivityStatus;
  /** Type of Activity, such as Add User, or Sign Transaction. */
  type: v1ActivityType;
  /** Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  intent: v1Intent;
  /** Result of the intended action. */
  result: v1Result;
  /** A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  votes: v1Vote[];
  /** An artifact verifying a User's action. */
  fingerprint: string;
  canApprove: boolean;
  canReject: boolean;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Failure reason of the intended action. */
  failure?: rpcStatus;
};

export type v1ActivityResponse = {
  /** An action that can that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type v1ActivityStatus =
  "ACTIVITY_STATUS_CREATED" |
  "ACTIVITY_STATUS_PENDING" |
  "ACTIVITY_STATUS_COMPLETED" |
  "ACTIVITY_STATUS_FAILED" |
  "ACTIVITY_STATUS_CONSENSUS_NEEDED" |
  "ACTIVITY_STATUS_REJECTED";

export type v1ActivityType =
  "ACTIVITY_TYPE_CREATE_API_KEYS" |
  "ACTIVITY_TYPE_CREATE_USERS" |
  "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS" |
  "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD" |
  "ACTIVITY_TYPE_CREATE_INVITATIONS" |
  "ACTIVITY_TYPE_ACCEPT_INVITATION" |
  "ACTIVITY_TYPE_CREATE_POLICY" |
  "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY" |
  "ACTIVITY_TYPE_DELETE_USERS" |
  "ACTIVITY_TYPE_DELETE_API_KEYS" |
  "ACTIVITY_TYPE_DELETE_INVITATION" |
  "ACTIVITY_TYPE_DELETE_ORGANIZATION" |
  "ACTIVITY_TYPE_DELETE_POLICY" |
  "ACTIVITY_TYPE_CREATE_USER_TAG" |
  "ACTIVITY_TYPE_DELETE_USER_TAGS" |
  "ACTIVITY_TYPE_CREATE_ORGANIZATION" |
  "ACTIVITY_TYPE_SIGN_TRANSACTION" |
  "ACTIVITY_TYPE_APPROVE_ACTIVITY" |
  "ACTIVITY_TYPE_REJECT_ACTIVITY" |
  "ACTIVITY_TYPE_DELETE_AUTHENTICATORS" |
  "ACTIVITY_TYPE_CREATE_AUTHENTICATORS" |
  "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG" |
  "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS" |
  "ACTIVITY_TYPE_SET_PAYMENT_METHOD" |
  "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER" |
  "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD" |
  "ACTIVITY_TYPE_CREATE_POLICY_V2" |
  "ACTIVITY_TYPE_CREATE_POLICY_V3" |
  "ACTIVITY_TYPE_CREATE_API_ONLY_USERS" |
  "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM" |
  "ACTIVITY_TYPE_UPDATE_USER_TAG" |
  "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG" |
  "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2" |
  "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2" |
  "ACTIVITY_TYPE_CREATE_USERS_V2" |
  "ACTIVITY_TYPE_ACCEPT_INVITATION_V2" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2" |
  "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS" |
  "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2" |
  "ACTIVITY_TYPE_UPDATE_USER" |
  "ACTIVITY_TYPE_UPDATE_POLICY" |
  "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3" |
  "ACTIVITY_TYPE_CREATE_WALLET" |
  "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS" |
  "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY" |
  "ACTIVITY_TYPE_RECOVER_USER" |
  "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE" |
  "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE" |
  "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2" |
  "ACTIVITY_TYPE_SIGN_TRANSACTION_V2" |
  "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY" |
  "ACTIVITY_TYPE_EXPORT_WALLET" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4" |
  "ACTIVITY_TYPE_EMAIL_AUTH" |
  "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT" |
  "ACTIVITY_TYPE_INIT_IMPORT_WALLET" |
  "ACTIVITY_TYPE_IMPORT_WALLET" |
  "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY" |
  "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY" |
  "ACTIVITY_TYPE_CREATE_POLICIES" |
  "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS" |
  "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION" |
  "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS" |
  "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5" |
  "ACTIVITY_TYPE_OAUTH" |
  "ACTIVITY_TYPE_CREATE_API_KEYS_V2" |
  "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION" |
  "ACTIVITY_TYPE_EMAIL_AUTH_V2" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6" |
  "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS" |
  "ACTIVITY_TYPE_DELETE_WALLETS" |
  "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2" |
  "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION" |
  "ACTIVITY_TYPE_INIT_OTP_AUTH" |
  "ACTIVITY_TYPE_OTP_AUTH" |
  "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7" |
  "ACTIVITY_TYPE_UPDATE_WALLET" |
  "ACTIVITY_TYPE_UPDATE_POLICY_V2" |
  "ACTIVITY_TYPE_CREATE_USERS_V3" |
  "ACTIVITY_TYPE_INIT_OTP_AUTH_V2" |
  "ACTIVITY_TYPE_INIT_OTP" |
  "ACTIVITY_TYPE_VERIFY_OTP" |
  "ACTIVITY_TYPE_OTP_LOGIN" |
  "ACTIVITY_TYPE_STAMP_LOGIN" |
  "ACTIVITY_TYPE_OAUTH_LOGIN";

export type v1AddressFormat =
  "ADDRESS_FORMAT_UNCOMPRESSED" |
  "ADDRESS_FORMAT_COMPRESSED" |
  "ADDRESS_FORMAT_ETHEREUM" |
  "ADDRESS_FORMAT_SOLANA" |
  "ADDRESS_FORMAT_COSMOS" |
  "ADDRESS_FORMAT_TRON" |
  "ADDRESS_FORMAT_SUI" |
  "ADDRESS_FORMAT_APTOS" |
  "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH" |
  "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH" |
  "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH" |
  "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH" |
  "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR" |
  "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH" |
  "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH" |
  "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH" |
  "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH" |
  "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR" |
  "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH" |
  "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH" |
  "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH" |
  "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH" |
  "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR" |
  "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH" |
  "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH" |
  "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH" |
  "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH" |
  "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR" |
  "ADDRESS_FORMAT_SEI" |
  "ADDRESS_FORMAT_XLM" |
  "ADDRESS_FORMAT_DOGE_MAINNET" |
  "ADDRESS_FORMAT_DOGE_TESTNET" |
  "ADDRESS_FORMAT_TON_V3R2" |
  "ADDRESS_FORMAT_TON_V4R2" |
  "ADDRESS_FORMAT_TON_V5R1" |
  "ADDRESS_FORMAT_XRP";

export type v1ApiKey = {
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given API Key. */
  apiKeyId: string;
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiKeyCurve =
  "API_KEY_CURVE_P256" |
  "API_KEY_CURVE_SECP256K1" |
  "API_KEY_CURVE_ED25519";

export type v1ApiKeyParamsV2 = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The curve type to be used for processing API key signatures. */
  curveType: v1ApiKeyCurve;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiOnlyUserParams = {
  /** The name of the new API-only User. */
  userName: string;
  /** The email address for this API-only User (optional). */
  userEmail?: string;
  /** A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
};

export type v1ApproveActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1ApproveActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ApproveActivityIntent;
};

export type v1Attestation = {
  /** The cbor encoded then base64 url encoded id of the credential. */
  credentialId: string;
  /** A base64 url encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
  attestationObject: string;
  /** The type of authenticator transports. */
  transports: v1AuthenticatorTransport[];
};

export type v1Authenticator = {
  /** Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
  transports: v1AuthenticatorTransport[];
  attestationType: string;
  /** Identifier indicating the type of the Security Key. */
  aaguid: string;
  /** Unique identifier for a WebAuthn credential. */
  credentialId: string;
  /** The type of Authenticator device. */
  model: string;
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1AuthenticatorAttestationResponse = {
  clientDataJson: string;
  attestationObject: string;
  transports?: v1AuthenticatorTransport[];
  authenticatorAttachment?: string;
};

export type v1AuthenticatorParams = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Unique identifier for a given User. */
  userId: string;
  attestation: v1PublicKeyCredentialWithAttestation;
  /** Challenge presented for authentication purposes. */
  challenge: string;
};

export type v1AuthenticatorParamsV2 = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Challenge presented for authentication purposes. */
  challenge: string;
  /** The attestation that proves custody of the authenticator and provides metadata about it. */
  attestation: v1Attestation;
};

export type v1AuthenticatorTransport =
  "AUTHENTICATOR_TRANSPORT_BLE" |
  "AUTHENTICATOR_TRANSPORT_INTERNAL" |
  "AUTHENTICATOR_TRANSPORT_NFC" |
  "AUTHENTICATOR_TRANSPORT_USB" |
  "AUTHENTICATOR_TRANSPORT_HYBRID";

export type v1Config = {
  features?: v1Feature[];
  quorum?: externaldatav1Quorum;
};

export type v1CreateApiKeysIntent = {
  /** A list of API Keys. */
  apiKeys: apiApiKeyParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysIntentV2 = {
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiKeysIntentV2;
};

export type v1CreateApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1CreateApiOnlyUsersIntent = {
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
};

export type v1CreateApiOnlyUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiOnlyUsersIntent;
};

export type v1CreateApiOnlyUsersResult = {
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type v1CreateAuthenticatorsIntent = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsIntentV2 = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateAuthenticatorsIntentV2;
};

export type v1CreateAuthenticatorsResult = {
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1CreateInvitationsIntent = {
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
};

export type v1CreateInvitationsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateInvitationsIntent;
};

export type v1CreateInvitationsResult = {
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type v1CreateOauthProvidersIntent = {
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1CreateOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateOauthProvidersIntent;
};

export type v1CreateOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1CreateOrganizationIntent = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParams;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationIntentV2 = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1CreatePoliciesIntent = {
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
};

export type v1CreatePoliciesRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePoliciesIntent;
};

export type v1CreatePoliciesResult = {
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type v1CreatePolicyIntent = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1Selector[];
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV2 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1SelectorV2[];
  /** Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV3 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type v1CreatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePolicyIntentV3;
};

export type v1CreatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1CreatePrivateKeyTagIntent = {
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeyTagIntent;
};

export type v1CreatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysIntent = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysIntentV2 = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeysIntentV2;
};

export type v1CreatePrivateKeysResult = {
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysResultV2 = {
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type v1CreateReadOnlySessionIntent = any;
export type v1CreateReadOnlySessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadOnlySessionIntent;
};

export type v1CreateReadOnlySessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type v1CreateReadWriteSessionIntent = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Email of the user to create a read write session for */
  email: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
};

export type v1CreateReadWriteSessionIntentV2 = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type v1CreateReadWriteSessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadWriteSessionIntentV2;
};

export type v1CreateReadWriteSessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateReadWriteSessionResultV2 = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateSubOrganizationIntent = {
  /** Name for this sub-organization */
  name: string;
  /** Root User authenticator for this new sub-organization */
  rootAuthenticator: v1AuthenticatorParamsV2;
};

export type v1CreateSubOrganizationIntentV2 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
};

export type v1CreateSubOrganizationIntentV3 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreateSubOrganizationIntentV4 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV5 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV2[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV6 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV3[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV7 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
};

export type v1CreateSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateSubOrganizationIntentV7;
};

export type v1CreateSubOrganizationResult = {
  subOrganizationId: string;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV3 = {
  subOrganizationId: string;
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV4 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV5 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV6 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV7 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateUserTagIntent = {
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUserTagIntent;
};

export type v1CreateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUsersIntent = {
  /** A list of Users. */
  users: v1UserParams[];
};

export type v1CreateUsersIntentV2 = {
  /** A list of Users. */
  users: v1UserParamsV2[];
};

export type v1CreateUsersIntentV3 = {
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type v1CreateUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUsersIntentV3;
};

export type v1CreateUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateWalletAccountsIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1CreateWalletAccountsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletAccountsIntent;
};

export type v1CreateWalletAccountsResult = {
  /** A list of derived addresses. */
  addresses: string[];
};

export type v1CreateWalletIntent = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1CreateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletIntent;
};

export type v1CreateWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1CredPropsAuthenticationExtensionsClientOutputs = {
  rk: boolean;
};

export type v1CredentialType =
  "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR" |
  "CREDENTIAL_TYPE_API_KEY_P256" |
  "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256" |
  "CREDENTIAL_TYPE_API_KEY_SECP256K1" |
  "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256" |
  "CREDENTIAL_TYPE_API_KEY_ED25519" |
  "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256" |
  "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256" |
  "CREDENTIAL_TYPE_OAUTH_KEY_P256" |
  "CREDENTIAL_TYPE_LOGIN";

export type v1Curve =
  "CURVE_SECP256K1" |
  "CURVE_ED25519";

export type v1DeleteApiKeysIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteApiKeysIntent;
};

export type v1DeleteApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteAuthenticatorsIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1DeleteAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteAuthenticatorsIntent;
};

export type v1DeleteAuthenticatorsResult = {
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type v1DeleteInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type v1DeleteInvitationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteInvitationIntent;
};

export type v1DeleteInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type v1DeleteOauthProvidersIntent = {
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type v1DeleteOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteOauthProvidersIntent;
};

export type v1DeleteOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1DeleteOrganizationIntent = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeleteOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeletePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePolicyIntent;
};

export type v1DeletePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePrivateKeyTagsIntent = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type v1DeletePrivateKeyTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeyTagsIntent;
};

export type v1DeletePrivateKeyTagsResult = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1DeletePrivateKeysIntent = {
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeletePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeysIntent;
};

export type v1DeletePrivateKeysResult = {
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type v1DeleteSubOrganizationIntent = {
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteSubOrganizationIntent;
};

export type v1DeleteSubOrganizationResult = {
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type v1DeleteUserTagsIntent = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type v1DeleteUserTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUserTagsIntent;
};

export type v1DeleteUserTagsResult = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersIntent = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUsersIntent;
};

export type v1DeleteUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteWalletsIntent = {
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteWalletsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteWalletsIntent;
};

export type v1DeleteWalletsResult = {
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type v1DisablePrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1DisablePrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1Effect =
  "EFFECT_ALLOW" |
  "EFFECT_DENY";

export type v1EmailAuthIntent = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthIntentV2 = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1EmailAuthIntentV2;
};

export type v1EmailAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type v1EmailCustomizationParams = {
  /** The name of the application. */
  appName?: string;
  /** A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
  logoUrl?: string;
  /** A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
  magicLinkTemplate?: string;
  /** JSON object containing key/value pairs to be used with custom templates. */
  templateVariables?: string;
  /** Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
  templateId?: string;
};

export type v1ExportPrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportPrivateKeyIntent;
};

export type v1ExportPrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletAccountIntent = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportWalletAccountRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletAccountIntent;
};

export type v1ExportWalletAccountResult = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
};

export type v1ExportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletIntent;
};

export type v1ExportWalletResult = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1Feature = {
  name?: v1FeatureName;
  value?: string;
};

export type v1FeatureName =
  "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY" |
  "FEATURE_NAME_WEBAUTHN_ORIGINS" |
  "FEATURE_NAME_EMAIL_AUTH" |
  "FEATURE_NAME_EMAIL_RECOVERY" |
  "FEATURE_NAME_WEBHOOK" |
  "FEATURE_NAME_SMS_AUTH" |
  "FEATURE_NAME_OTP_EMAIL_AUTH";

export type v1GetActivitiesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Array of Activity Statuses filtering which Activities will be listed in the response. */
  filterByStatus?: v1ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
  /** Array of Activity Types filtering which Activities will be listed in the response. */
  filterByType?: v1ActivityType[];
};

export type v1GetActivitiesResponse = {
  /** A list of Activities. */
  activities: v1Activity[];
};

export type v1GetActivityRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Activity object. */
  activityId: string;
};

export type v1GetApiKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type v1GetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type v1GetApiKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type v1GetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type v1GetAttestationDocumentRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser */
  enclaveType: string;
};

export type v1GetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document */
  attestationDocument: string;
};

export type v1GetAuthenticatorRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
};

export type v1GetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type v1GetAuthenticatorsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1GetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type v1GetOauthProvidersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId?: string;
};

export type v1GetOauthProvidersResponse = {
  /** A list of Oauth Providers */
  oauthProviders: v1OauthProvider[];
};

export type v1GetOrganizationConfigsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features */
  configs: v1Config;
};

export type v1GetOrganizationRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
  organizationData: v1OrganizationData;
};

export type v1GetPoliciesRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetPoliciesResponse = {
  /** A list of Policies. */
  policies: v1Policy[];
};

export type v1GetPolicyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1GetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an Organization. */
  policy: v1Policy;
};

export type v1GetPrivateKeyRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1GetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type v1GetPrivateKeysRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetPrivateKeysResponse = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKey[];
};

export type v1GetSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetUserRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1GetUserResponse = {
  /** Web and/or API user within your Organization. */
  user: v1User;
};

export type v1GetUsersRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetUsersResponse = {
  /** A list of Users. */
  users: v1User[];
};

export type v1GetVerifiedSubOrgIdsRequest = {
  /** Unique identifier for the parent Organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetWalletAccountRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Address corresponding to a Wallet Account. */
  address?: string;
  /** Path corresponding to a Wallet Account. */
  path?: string;
};

export type v1GetWalletAccountResponse = {
  /** The resulting Wallet Account. */
  account: v1WalletAccount;
};

export type v1GetWalletAccountsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetWalletAccountsResponse = {
  /** A list of Accounts generated from a Wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type v1GetWalletRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
};

export type v1GetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
  wallet: v1Wallet;
};

export type v1GetWalletsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1GetWalletsResponse = {
  /** A list of Wallets. */
  wallets: v1Wallet[];
};

export type v1GetWhoamiRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
};

export type v1GetWhoamiResponse = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
};

export type v1HashFunction =
  "HASH_FUNCTION_NO_OP" |
  "HASH_FUNCTION_SHA256" |
  "HASH_FUNCTION_KECCAK256" |
  "HASH_FUNCTION_NOT_APPLICABLE";

export type v1ImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1ImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportPrivateKeyIntent;
};

export type v1ImportPrivateKeyResult = {
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type v1ImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1ImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportWalletIntent;
};

export type v1ImportWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1InitImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type v1InitImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportPrivateKeyIntent;
};

export type v1InitImportPrivateKeyResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type v1InitImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportWalletIntent;
};

export type v1InitImportWalletResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitOtpAuthIntent = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthIntentV2 = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpAuthIntentV2;
};

export type v1InitOtpAuthResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpAuthResultV2 = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpIntent = {
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpIntent;
};

export type v1InitOtpResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitUserEmailRecoveryIntent = {
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
};

export type v1InitUserEmailRecoveryRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitUserEmailRecoveryIntent;
};

export type v1InitUserEmailRecoveryResult = {
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type v1Intent = {
  createOrganizationIntent?: v1CreateOrganizationIntent;
  createAuthenticatorsIntent?: v1CreateAuthenticatorsIntent;
  createUsersIntent?: v1CreateUsersIntent;
  createPrivateKeysIntent?: v1CreatePrivateKeysIntent;
  signRawPayloadIntent?: v1SignRawPayloadIntent;
  createInvitationsIntent?: v1CreateInvitationsIntent;
  acceptInvitationIntent?: v1AcceptInvitationIntent;
  createPolicyIntent?: v1CreatePolicyIntent;
  disablePrivateKeyIntent?: v1DisablePrivateKeyIntent;
  deleteUsersIntent?: v1DeleteUsersIntent;
  deleteAuthenticatorsIntent?: v1DeleteAuthenticatorsIntent;
  deleteInvitationIntent?: v1DeleteInvitationIntent;
  deleteOrganizationIntent?: v1DeleteOrganizationIntent;
  deletePolicyIntent?: v1DeletePolicyIntent;
  createUserTagIntent?: v1CreateUserTagIntent;
  deleteUserTagsIntent?: v1DeleteUserTagsIntent;
  signTransactionIntent?: v1SignTransactionIntent;
  createApiKeysIntent?: v1CreateApiKeysIntent;
  deleteApiKeysIntent?: v1DeleteApiKeysIntent;
  approveActivityIntent?: v1ApproveActivityIntent;
  rejectActivityIntent?: v1RejectActivityIntent;
  createPrivateKeyTagIntent?: v1CreatePrivateKeyTagIntent;
  deletePrivateKeyTagsIntent?: v1DeletePrivateKeyTagsIntent;
  createPolicyIntentV2?: v1CreatePolicyIntentV2;
  setPaymentMethodIntent?: billingSetPaymentMethodIntent;
  activateBillingTierIntent?: billingActivateBillingTierIntent;
  deletePaymentMethodIntent?: billingDeletePaymentMethodIntent;
  createPolicyIntentV3?: v1CreatePolicyIntentV3;
  createApiOnlyUsersIntent?: v1CreateApiOnlyUsersIntent;
  updateRootQuorumIntent?: v1UpdateRootQuorumIntent;
  updateUserTagIntent?: v1UpdateUserTagIntent;
  updatePrivateKeyTagIntent?: v1UpdatePrivateKeyTagIntent;
  createAuthenticatorsIntentV2?: v1CreateAuthenticatorsIntentV2;
  acceptInvitationIntentV2?: v1AcceptInvitationIntentV2;
  createOrganizationIntentV2?: v1CreateOrganizationIntentV2;
  createUsersIntentV2?: v1CreateUsersIntentV2;
  createSubOrganizationIntent?: v1CreateSubOrganizationIntent;
  createSubOrganizationIntentV2?: v1CreateSubOrganizationIntentV2;
  updateAllowedOriginsIntent?: v1UpdateAllowedOriginsIntent;
  createPrivateKeysIntentV2?: v1CreatePrivateKeysIntentV2;
  updateUserIntent?: v1UpdateUserIntent;
  updatePolicyIntent?: v1UpdatePolicyIntent;
  setPaymentMethodIntentV2?: billingSetPaymentMethodIntentV2;
  createSubOrganizationIntentV3?: v1CreateSubOrganizationIntentV3;
  createWalletIntent?: v1CreateWalletIntent;
  createWalletAccountsIntent?: v1CreateWalletAccountsIntent;
  initUserEmailRecoveryIntent?: v1InitUserEmailRecoveryIntent;
  recoverUserIntent?: v1RecoverUserIntent;
  setOrganizationFeatureIntent?: v1SetOrganizationFeatureIntent;
  removeOrganizationFeatureIntent?: v1RemoveOrganizationFeatureIntent;
  signRawPayloadIntentV2?: v1SignRawPayloadIntentV2;
  signTransactionIntentV2?: v1SignTransactionIntentV2;
  exportPrivateKeyIntent?: v1ExportPrivateKeyIntent;
  exportWalletIntent?: v1ExportWalletIntent;
  createSubOrganizationIntentV4?: v1CreateSubOrganizationIntentV4;
  emailAuthIntent?: v1EmailAuthIntent;
  exportWalletAccountIntent?: v1ExportWalletAccountIntent;
  initImportWalletIntent?: v1InitImportWalletIntent;
  importWalletIntent?: v1ImportWalletIntent;
  initImportPrivateKeyIntent?: v1InitImportPrivateKeyIntent;
  importPrivateKeyIntent?: v1ImportPrivateKeyIntent;
  createPoliciesIntent?: v1CreatePoliciesIntent;
  signRawPayloadsIntent?: v1SignRawPayloadsIntent;
  createReadOnlySessionIntent?: v1CreateReadOnlySessionIntent;
  createOauthProvidersIntent?: v1CreateOauthProvidersIntent;
  deleteOauthProvidersIntent?: v1DeleteOauthProvidersIntent;
  createSubOrganizationIntentV5?: v1CreateSubOrganizationIntentV5;
  oauthIntent?: v1OauthIntent;
  createApiKeysIntentV2?: v1CreateApiKeysIntentV2;
  createReadWriteSessionIntent?: v1CreateReadWriteSessionIntent;
  emailAuthIntentV2?: v1EmailAuthIntentV2;
  createSubOrganizationIntentV6?: v1CreateSubOrganizationIntentV6;
  deletePrivateKeysIntent?: v1DeletePrivateKeysIntent;
  deleteWalletsIntent?: v1DeleteWalletsIntent;
  createReadWriteSessionIntentV2?: v1CreateReadWriteSessionIntentV2;
  deleteSubOrganizationIntent?: v1DeleteSubOrganizationIntent;
  initOtpAuthIntent?: v1InitOtpAuthIntent;
  otpAuthIntent?: v1OtpAuthIntent;
  createSubOrganizationIntentV7?: v1CreateSubOrganizationIntentV7;
  updateWalletIntent?: v1UpdateWalletIntent;
  updatePolicyIntentV2?: v1UpdatePolicyIntentV2;
  createUsersIntentV3?: v1CreateUsersIntentV3;
  initOtpAuthIntentV2?: v1InitOtpAuthIntentV2;
  initOtpIntent?: v1InitOtpIntent;
  verifyOtpIntent?: v1VerifyOtpIntent;
  otpLoginIntent?: v1OtpLoginIntent;
  stampLoginIntent?: v1StampLoginIntent;
  oauthLoginIntent?: v1OauthLoginIntent;
};

export type v1Invitation = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverEmail: string;
  /** A list of tags assigned to the Invitation recipient. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** The current processing status of a specified Invitation. */
  status: v1InvitationStatus;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationParams = {
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverUserEmail: string;
  /** A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationStatus =
  "INVITATION_STATUS_CREATED" |
  "INVITATION_STATUS_ACCEPTED" |
  "INVITATION_STATUS_REVOKED";

export type v1ListPrivateKeyTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1ListPrivateKeyTagsResponse = {
  /** A list of Private Key Tags */
  privateKeyTags: datav1Tag[];
};

export type v1ListUserTagsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1ListUserTagsResponse = {
  /** A list of User Tags */
  userTags: datav1Tag[];
};

export type v1MnemonicLanguage =
  "MNEMONIC_LANGUAGE_ENGLISH" |
  "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE" |
  "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE" |
  "MNEMONIC_LANGUAGE_CZECH" |
  "MNEMONIC_LANGUAGE_FRENCH" |
  "MNEMONIC_LANGUAGE_ITALIAN" |
  "MNEMONIC_LANGUAGE_JAPANESE" |
  "MNEMONIC_LANGUAGE_KOREAN" |
  "MNEMONIC_LANGUAGE_SPANISH";

export type v1NOOPCodegenAnchorResponse = {
  stamp: v1WebAuthnStamp;
};

export type v1OauthIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthLoginIntent;
};

export type v1OauthLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1OauthProvider = {
  /** Unique identifier for an OAuth Provider */
  providerId: string;
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
  issuer: string;
  /** Expected audience ('aud' attribute of the signed token) which represents the app ID */
  audience: string;
  /** Expected subject ('sub' attribute of the signed token) which represents the user ID */
  subject: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1OauthProviderParams = {
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
};

export type v1OauthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthIntent;
};

export type v1OauthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1Operator =
  "OPERATOR_EQUAL" |
  "OPERATOR_MORE_THAN" |
  "OPERATOR_MORE_THAN_OR_EQUAL" |
  "OPERATOR_LESS_THAN" |
  "OPERATOR_LESS_THAN_OR_EQUAL" |
  "OPERATOR_CONTAINS" |
  "OPERATOR_NOT_EQUAL" |
  "OPERATOR_IN" |
  "OPERATOR_NOT_IN" |
  "OPERATOR_CONTAINS_ONE" |
  "OPERATOR_CONTAINS_ALL";

export type v1OrganizationData = {
  organizationId?: string;
  name?: string;
  users?: v1User[];
  policies?: v1Policy[];
  privateKeys?: v1PrivateKey[];
  invitations?: v1Invitation[];
  tags?: datav1Tag[];
  rootQuorum?: externaldatav1Quorum;
  features?: v1Feature[];
  wallets?: v1Wallet[];
};

export type v1OtpAuthIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type v1OtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpAuthIntent;
};

export type v1OtpAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type v1OtpLoginIntent = {
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1OtpLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpLoginIntent;
};

export type v1OtpLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1Pagination = {
  /** A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
  limit?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
  before?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
  after?: string;
};

export type v1PathFormat =
  "PATH_FORMAT_BIP32";

export type v1PayloadEncoding =
  "PAYLOAD_ENCODING_HEXADECIMAL" |
  "PAYLOAD_ENCODING_TEXT_UTF8";

export type v1Policy = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Human-readable notes added by a User to describe a particular policy. */
  notes: string;
  /** A consensus expression that evalutes to true or false. */
  consensus: string;
  /** A condition expression that evalutes to true or false. */
  condition: string;
};

export type v1PrivateKey = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Derived cryptocurrency addresses for a given Private Key. */
  addresses: externaldatav1Address[];
  /** A list of Private Key Tag IDs. */
  privateKeyTags: string[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Private Key is exported, false otherwise. */
  exported: boolean;
  /** True when a given Private Key is imported, false otherwise. */
  imported: boolean;
};

export type v1PrivateKeyParams = {
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
  privateKeyTags: string[];
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1PrivateKeyResult = {
  privateKeyId?: string;
  addresses?: immutableactivityv1Address[];
};

export type v1PublicKeyCredentialWithAttestation = {
  id: string;
  type: string;
  rawId: string;
  authenticatorAttachment?: string;
  response: v1AuthenticatorAttestationResponse;
  clientExtensionResults: v1SimpleClientExtensionResults;
};

export type v1RecoverUserIntent = {
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type v1RecoverUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RecoverUserIntent;
};

export type v1RecoverUserResult = {
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type v1RejectActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1RejectActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RejectActivityIntent;
};

export type v1RemoveOrganizationFeatureIntent = {
  /** Name of the feature to remove */
  name: v1FeatureName;
};

export type v1RemoveOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RemoveOrganizationFeatureIntent;
};

export type v1RemoveOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1Result = {
  createOrganizationResult?: v1CreateOrganizationResult;
  createAuthenticatorsResult?: v1CreateAuthenticatorsResult;
  createUsersResult?: v1CreateUsersResult;
  createPrivateKeysResult?: v1CreatePrivateKeysResult;
  createInvitationsResult?: v1CreateInvitationsResult;
  acceptInvitationResult?: v1AcceptInvitationResult;
  signRawPayloadResult?: v1SignRawPayloadResult;
  createPolicyResult?: v1CreatePolicyResult;
  disablePrivateKeyResult?: v1DisablePrivateKeyResult;
  deleteUsersResult?: v1DeleteUsersResult;
  deleteAuthenticatorsResult?: v1DeleteAuthenticatorsResult;
  deleteInvitationResult?: v1DeleteInvitationResult;
  deleteOrganizationResult?: v1DeleteOrganizationResult;
  deletePolicyResult?: v1DeletePolicyResult;
  createUserTagResult?: v1CreateUserTagResult;
  deleteUserTagsResult?: v1DeleteUserTagsResult;
  signTransactionResult?: v1SignTransactionResult;
  deleteApiKeysResult?: v1DeleteApiKeysResult;
  createApiKeysResult?: v1CreateApiKeysResult;
  createPrivateKeyTagResult?: v1CreatePrivateKeyTagResult;
  deletePrivateKeyTagsResult?: v1DeletePrivateKeyTagsResult;
  setPaymentMethodResult?: billingSetPaymentMethodResult;
  activateBillingTierResult?: billingActivateBillingTierResult;
  deletePaymentMethodResult?: billingDeletePaymentMethodResult;
  createApiOnlyUsersResult?: v1CreateApiOnlyUsersResult;
  updateRootQuorumResult?: v1UpdateRootQuorumResult;
  updateUserTagResult?: v1UpdateUserTagResult;
  updatePrivateKeyTagResult?: v1UpdatePrivateKeyTagResult;
  createSubOrganizationResult?: v1CreateSubOrganizationResult;
  updateAllowedOriginsResult?: v1UpdateAllowedOriginsResult;
  createPrivateKeysResultV2?: v1CreatePrivateKeysResultV2;
  updateUserResult?: v1UpdateUserResult;
  updatePolicyResult?: v1UpdatePolicyResult;
  createSubOrganizationResultV3?: v1CreateSubOrganizationResultV3;
  createWalletResult?: v1CreateWalletResult;
  createWalletAccountsResult?: v1CreateWalletAccountsResult;
  initUserEmailRecoveryResult?: v1InitUserEmailRecoveryResult;
  recoverUserResult?: v1RecoverUserResult;
  setOrganizationFeatureResult?: v1SetOrganizationFeatureResult;
  removeOrganizationFeatureResult?: v1RemoveOrganizationFeatureResult;
  exportPrivateKeyResult?: v1ExportPrivateKeyResult;
  exportWalletResult?: v1ExportWalletResult;
  createSubOrganizationResultV4?: v1CreateSubOrganizationResultV4;
  emailAuthResult?: v1EmailAuthResult;
  exportWalletAccountResult?: v1ExportWalletAccountResult;
  initImportWalletResult?: v1InitImportWalletResult;
  importWalletResult?: v1ImportWalletResult;
  initImportPrivateKeyResult?: v1InitImportPrivateKeyResult;
  importPrivateKeyResult?: v1ImportPrivateKeyResult;
  createPoliciesResult?: v1CreatePoliciesResult;
  signRawPayloadsResult?: v1SignRawPayloadsResult;
  createReadOnlySessionResult?: v1CreateReadOnlySessionResult;
  createOauthProvidersResult?: v1CreateOauthProvidersResult;
  deleteOauthProvidersResult?: v1DeleteOauthProvidersResult;
  createSubOrganizationResultV5?: v1CreateSubOrganizationResultV5;
  oauthResult?: v1OauthResult;
  createReadWriteSessionResult?: v1CreateReadWriteSessionResult;
  createSubOrganizationResultV6?: v1CreateSubOrganizationResultV6;
  deletePrivateKeysResult?: v1DeletePrivateKeysResult;
  deleteWalletsResult?: v1DeleteWalletsResult;
  createReadWriteSessionResultV2?: v1CreateReadWriteSessionResultV2;
  deleteSubOrganizationResult?: v1DeleteSubOrganizationResult;
  initOtpAuthResult?: v1InitOtpAuthResult;
  otpAuthResult?: v1OtpAuthResult;
  createSubOrganizationResultV7?: v1CreateSubOrganizationResultV7;
  updateWalletResult?: v1UpdateWalletResult;
  updatePolicyResultV2?: v1UpdatePolicyResultV2;
  initOtpAuthResultV2?: v1InitOtpAuthResultV2;
  initOtpResult?: v1InitOtpResult;
  verifyOtpResult?: v1VerifyOtpResult;
  otpLoginResult?: v1OtpLoginResult;
  stampLoginResult?: v1StampLoginResult;
  oauthLoginResult?: v1OauthLoginResult;
};

export type v1RootUserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
};

export type v1RootUserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV4 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1Selector = {
  subject?: string;
  operator?: v1Operator;
  target?: string;
};

export type v1SelectorV2 = {
  subject?: string;
  operator?: v1Operator;
  targets?: string[];
};

export type v1SetOrganizationFeatureIntent = {
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type v1SetOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SetOrganizationFeatureIntent;
};

export type v1SetOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1SignRawPayloadIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadIntentV2;
};

export type v1SignRawPayloadResult = {
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type v1SignRawPayloadsIntent = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadsIntent;
};

export type v1SignRawPayloadsResult = {
  signatures?: v1SignRawPayloadResult[];
};

export type v1SignTransactionIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned transaction to be signed by a particular Private Key. */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignTransactionIntentV2;
};

export type v1SignTransactionResult = {
  signedTransaction: string;
};

export type v1SimpleClientExtensionResults = {
  appid?: boolean;
  appidExclude?: boolean;
  credProps?: v1CredPropsAuthenticationExtensionsClientOutputs;
};

export type v1SmsCustomizationParams = {
  /** Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
  template?: string;
};

export type v1StampLoginIntent = {
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1StampLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1StampLoginIntent;
};

export type v1StampLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1TagType =
  "TAG_TYPE_USER" |
  "TAG_TYPE_PRIVATE_KEY";

export type v1TestRateLimitsRequest = {
  /** Unique identifier for a given Organization. If the request is being made by a WebAuthN user and their Sub-Organization ID is unknown, this can be the Parent Organization ID; using the Sub-Organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true */
  limit: number;
};

export type v1TestRateLimitsResponse = any;
export type v1TransactionType =
  "TRANSACTION_TYPE_ETHEREUM" |
  "TRANSACTION_TYPE_SOLANA" |
  "TRANSACTION_TYPE_TRON";

export type v1UpdateAllowedOriginsIntent = {
  /** Additional origins requests are allowed from besides Turnkey origins */
  allowedOrigins: string[];
};

export type v1UpdateAllowedOriginsResult = any;
export type v1UpdatePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyIntentV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePolicyIntentV2;
};

export type v1UpdatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePolicyResultV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePrivateKeyTagIntent = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type v1UpdatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePrivateKeyTagIntent;
};

export type v1UpdatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type v1UpdateRootQuorumIntent = {
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type v1UpdateRootQuorumRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateRootQuorumIntent;
};

export type v1UpdateRootQuorumResult = any;
export type v1UpdateUserIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type v1UpdateUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserIntent;
};

export type v1UpdateUserResult = {
  /** A User ID. */
  userId: string;
};

export type v1UpdateUserTagIntent = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type v1UpdateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserTagIntent;
};

export type v1UpdateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type v1UpdateWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type v1UpdateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateWalletIntent;
};

export type v1UpdateWalletResult = {
  /** A Wallet ID. */
  walletId: string;
};

export type v1User = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of Authenticator parameters. */
  authenticators: v1Authenticator[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKey[];
  /** A list of User Tag IDs. */
  userTags: string[];
  /** A list of Oauth Providers. */
  oauthProviders: v1OauthProvider[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1UserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1VerifyOtpIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
};

export type v1VerifyOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1VerifyOtpIntent;
};

export type v1VerifyOtpResult = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type v1Vote = {
  /** Unique identifier for a given Vote object. */
  id: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Web and/or API user within your Organization. */
  user: v1User;
  /** Unique identifier for a given Activity object. */
  activityId: string;
  selection: string;
  /** The raw message being signed within a Vote. */
  message: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The signature applied to a particular vote. */
  signature: string;
  /** Method used to produce a signature. */
  scheme: string;
  createdAt: externaldatav1Timestamp;
};

export type v1Wallet = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Wallet is exported, false otherwise. */
  exported: boolean;
  /** True when a given Wallet is imported, false otherwise. */
  imported: boolean;
};

export type v1WalletAccount = {
  /** Unique identifier for a given Wallet Account. */
  walletAccountId: string;
  /** The Organization the Account belongs to. */
  organizationId: string;
  /** The Wallet the Account was derived from. */
  walletId: string;
  /** Cryptographic curve used to generate the Account. */
  curve: v1Curve;
  /** Path format used to generate the Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate the Account. */
  path: string;
  /** Address format used to generate the Account. */
  addressFormat: v1AddressFormat;
  /** Address generated using the Wallet seed and Account parameters. */
  address: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** The public component of this wallet account's underlying cryptographic key pair. */
  publicKey?: string;
};

export type v1WalletAccountParams = {
  /** Cryptographic curve used to generate a wallet Account. */
  curve: v1Curve;
  /** Path format used to generate a wallet Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate a wallet Account. */
  path: string;
  /** Address format used to generate a wallet Acccount. */
  addressFormat: v1AddressFormat;
};

export type v1WalletParams = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1WalletResult = {
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1WebAuthnStamp = {
  /** A base64 url encoded Unique identifier for a given credential. */
  credentialId: string;
  /** A base64 encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 encoded payload containing metadata about the authenticator. */
  authenticatorData: string;
  /** The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
  signature: string;
};


// --- Latest Version Type Aliases ---
export type AcceptInvitationRequest = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParamsV2;
};

export type AcceptInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type AccessType = v1AccessType;
export type Activity = {
  /** Unique identifier for a given Activity object. */
  id: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The current processing status of a specified Activity. */
  status: v1ActivityStatus;
  /** Type of Activity, such as Add User, or Sign Transaction. */
  type: v1ActivityType;
  /** Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  intent: v1Intent;
  /** Result of the intended action. */
  result: v1Result;
  /** A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  votes: v1Vote[];
  /** An artifact verifying a User's action. */
  fingerprint: string;
  canApprove: boolean;
  canReject: boolean;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Failure reason of the intended action. */
  failure?: rpcStatus;
};

export type ActivityResponse = {
  /** An action that can that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type ActivityStatus = v1ActivityStatus;
export type ActivityType = v1ActivityType;
export type AddressFormat = v1AddressFormat;
export type ApiKey = {
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given API Key. */
  apiKeyId: string;
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type ApiKeyCurve = v1ApiKeyCurve;
export type ApiKeyParams = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The curve type to be used for processing API key signatures. */
  curveType: v1ApiKeyCurve;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type ApiOnlyUserParams = {
  /** The name of the new API-only User. */
  userName: string;
  /** The email address for this API-only User (optional). */
  userEmail?: string;
  /** A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
};

export type ApproveActivityRequest = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type Attestation = {
  /** The cbor encoded then base64 url encoded id of the credential. */
  credentialId: string;
  /** A base64 url encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
  attestationObject: string;
  /** The type of authenticator transports. */
  transports: v1AuthenticatorTransport[];
};

export type Authenticator = {
  /** Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
  transports: v1AuthenticatorTransport[];
  attestationType: string;
  /** Identifier indicating the type of the Security Key. */
  aaguid: string;
  /** Unique identifier for a WebAuthn credential. */
  credentialId: string;
  /** The type of Authenticator device. */
  model: string;
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type AuthenticatorAttestationResponse = {
  clientDataJson: string;
  attestationObject: string;
  transports?: v1AuthenticatorTransport[];
  authenticatorAttachment?: string;
};

export type AuthenticatorParams = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Challenge presented for authentication purposes. */
  challenge: string;
  /** The attestation that proves custody of the authenticator and provides metadata about it. */
  attestation: v1Attestation;
};

export type AuthenticatorTransport = v1AuthenticatorTransport;
export type Config = {
  features?: v1Feature[];
  quorum?: externaldatav1Quorum;
};

export type CreateApiKeysRequest = {
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type CreateApiOnlyUsersRequest = {
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateApiOnlyUsersResult = {
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type CreateAuthenticatorsRequest = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type CreateAuthenticatorsResult = {
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type CreateInvitationsRequest = {
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateInvitationsResult = {
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type CreateOauthProvidersRequest = {
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type CreateOrganizationRequest = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type CreateOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type CreatePoliciesRequest = {
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreatePoliciesResult = {
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type CreatePolicyRequest = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type CreatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type CreatePrivateKeyTagRequest = {
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type CreatePrivateKeysRequest = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type CreatePrivateKeysResult = {
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type CreateReadOnlySessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type CreateReadWriteSessionRequest = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type CreateReadWriteSessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type CreateSubOrganizationRequest = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
};

export type CreateSubOrganizationResult = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type CreateUserTagRequest = {
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type CreateUsersRequest = {
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type CreateUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type CreateWalletAccountsRequest = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateWalletAccountsResult = {
  /** A list of derived addresses. */
  addresses: string[];
};

export type CreateWalletRequest = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type CreateWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type CredPropsAuthenticationExtensionsClientOutputs = {
  rk: boolean;
};

export type CredentialType = v1CredentialType;
export type Curve = v1Curve;
export type DeleteApiKeysRequest = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type DeleteAuthenticatorsRequest = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteAuthenticatorsResult = {
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type DeleteInvitationRequest = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type DeleteOauthProvidersRequest = {
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type DeleteOrganizationRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type DeleteOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type DeletePolicyRequest = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeletePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type DeletePrivateKeyTagsRequest = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeletePrivateKeyTagsResult = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type DeletePrivateKeysRequest = {
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeletePrivateKeysResult = {
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type DeleteSubOrganizationRequest = {
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteSubOrganizationResult = {
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type DeleteUserTagsRequest = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteUserTagsResult = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type DeleteUsersRequest = {
  /** A list of User IDs. */
  userIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type DeleteWalletsRequest = {
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type DeleteWalletsResult = {
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type DisablePrivateKeyRequest = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type DisablePrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type Effect = v1Effect;
export type EmailAuthRequest = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type EmailAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type EmailCustomizationParams = {
  /** The name of the application. */
  appName?: string;
  /** A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
  logoUrl?: string;
  /** A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
  magicLinkTemplate?: string;
  /** JSON object containing key/value pairs to be used with custom templates. */
  templateVariables?: string;
  /** Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
  templateId?: string;
};

export type ExportPrivateKeyRequest = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type ExportPrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type ExportWalletAccountRequest = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type ExportWalletAccountResult = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type ExportWalletRequest = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type ExportWalletResult = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type Feature = {
  name?: v1FeatureName;
  value?: string;
};

export type FeatureName = v1FeatureName;
export type GetActivitiesResponse = {
  /** A list of Activities. */
  activities: v1Activity[];
};

export type GetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type GetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type GetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document */
  attestationDocument: string;
};

export type GetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type GetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type GetOauthProvidersResponse = {
  /** A list of Oauth Providers */
  oauthProviders: v1OauthProvider[];
};

export type GetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features */
  configs: v1Config;
};

export type GetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of Users, Policies, Private Keys, and Invitations attributable to a particular Organization. */
  organizationData: v1OrganizationData;
};

export type GetPoliciesResponse = {
  /** A list of Policies. */
  policies: v1Policy[];
};

export type GetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an Organization. */
  policy: v1Policy;
};

export type GetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type GetPrivateKeysResponse = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKey[];
};

export type GetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type GetUserResponse = {
  /** Web and/or API user within your Organization. */
  user: v1User;
};

export type GetUsersResponse = {
  /** A list of Users. */
  users: v1User[];
};

export type GetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type GetWalletAccountResponse = {
  /** The resulting Wallet Account. */
  account: v1WalletAccount;
};

export type GetWalletAccountsResponse = {
  /** A list of Accounts generated from a Wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type GetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed */
  wallet: v1Wallet;
};

export type GetWalletsResponse = {
  /** A list of Wallets. */
  wallets: v1Wallet[];
};

export type GetWhoamiResponse = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
};

export type HashFunction = v1HashFunction;
export type ImportPrivateKeyRequest = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type ImportPrivateKeyResult = {
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type ImportWalletRequest = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type ImportWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type InitImportPrivateKeyRequest = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type InitImportPrivateKeyResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type InitImportWalletRequest = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type InitImportWalletResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type InitOtpAuthRequest = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type InitOtpAuthResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type InitOtpRequest = {
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type InitOtpResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type InitUserEmailRecoveryRequest = {
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type InitUserEmailRecoveryResult = {
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type Intent = {
  createOrganizationIntent?: v1CreateOrganizationIntent;
  createAuthenticatorsIntent?: v1CreateAuthenticatorsIntent;
  createUsersIntent?: v1CreateUsersIntent;
  createPrivateKeysIntent?: v1CreatePrivateKeysIntent;
  signRawPayloadIntent?: v1SignRawPayloadIntent;
  createInvitationsIntent?: v1CreateInvitationsIntent;
  acceptInvitationIntent?: v1AcceptInvitationIntent;
  createPolicyIntent?: v1CreatePolicyIntent;
  disablePrivateKeyIntent?: v1DisablePrivateKeyIntent;
  deleteUsersIntent?: v1DeleteUsersIntent;
  deleteAuthenticatorsIntent?: v1DeleteAuthenticatorsIntent;
  deleteInvitationIntent?: v1DeleteInvitationIntent;
  deleteOrganizationIntent?: v1DeleteOrganizationIntent;
  deletePolicyIntent?: v1DeletePolicyIntent;
  createUserTagIntent?: v1CreateUserTagIntent;
  deleteUserTagsIntent?: v1DeleteUserTagsIntent;
  signTransactionIntent?: v1SignTransactionIntent;
  createApiKeysIntent?: v1CreateApiKeysIntent;
  deleteApiKeysIntent?: v1DeleteApiKeysIntent;
  approveActivityIntent?: v1ApproveActivityIntent;
  rejectActivityIntent?: v1RejectActivityIntent;
  createPrivateKeyTagIntent?: v1CreatePrivateKeyTagIntent;
  deletePrivateKeyTagsIntent?: v1DeletePrivateKeyTagsIntent;
  createPolicyIntentV2?: v1CreatePolicyIntentV2;
  setPaymentMethodIntent?: billingSetPaymentMethodIntent;
  activateBillingTierIntent?: billingActivateBillingTierIntent;
  deletePaymentMethodIntent?: billingDeletePaymentMethodIntent;
  createPolicyIntentV3?: v1CreatePolicyIntentV3;
  createApiOnlyUsersIntent?: v1CreateApiOnlyUsersIntent;
  updateRootQuorumIntent?: v1UpdateRootQuorumIntent;
  updateUserTagIntent?: v1UpdateUserTagIntent;
  updatePrivateKeyTagIntent?: v1UpdatePrivateKeyTagIntent;
  createAuthenticatorsIntentV2?: v1CreateAuthenticatorsIntentV2;
  acceptInvitationIntentV2?: v1AcceptInvitationIntentV2;
  createOrganizationIntentV2?: v1CreateOrganizationIntentV2;
  createUsersIntentV2?: v1CreateUsersIntentV2;
  createSubOrganizationIntent?: v1CreateSubOrganizationIntent;
  createSubOrganizationIntentV2?: v1CreateSubOrganizationIntentV2;
  updateAllowedOriginsIntent?: v1UpdateAllowedOriginsIntent;
  createPrivateKeysIntentV2?: v1CreatePrivateKeysIntentV2;
  updateUserIntent?: v1UpdateUserIntent;
  updatePolicyIntent?: v1UpdatePolicyIntent;
  setPaymentMethodIntentV2?: billingSetPaymentMethodIntentV2;
  createSubOrganizationIntentV3?: v1CreateSubOrganizationIntentV3;
  createWalletIntent?: v1CreateWalletIntent;
  createWalletAccountsIntent?: v1CreateWalletAccountsIntent;
  initUserEmailRecoveryIntent?: v1InitUserEmailRecoveryIntent;
  recoverUserIntent?: v1RecoverUserIntent;
  setOrganizationFeatureIntent?: v1SetOrganizationFeatureIntent;
  removeOrganizationFeatureIntent?: v1RemoveOrganizationFeatureIntent;
  signRawPayloadIntentV2?: v1SignRawPayloadIntentV2;
  signTransactionIntentV2?: v1SignTransactionIntentV2;
  exportPrivateKeyIntent?: v1ExportPrivateKeyIntent;
  exportWalletIntent?: v1ExportWalletIntent;
  createSubOrganizationIntentV4?: v1CreateSubOrganizationIntentV4;
  emailAuthIntent?: v1EmailAuthIntent;
  exportWalletAccountIntent?: v1ExportWalletAccountIntent;
  initImportWalletIntent?: v1InitImportWalletIntent;
  importWalletIntent?: v1ImportWalletIntent;
  initImportPrivateKeyIntent?: v1InitImportPrivateKeyIntent;
  importPrivateKeyIntent?: v1ImportPrivateKeyIntent;
  createPoliciesIntent?: v1CreatePoliciesIntent;
  signRawPayloadsIntent?: v1SignRawPayloadsIntent;
  createReadOnlySessionIntent?: v1CreateReadOnlySessionIntent;
  createOauthProvidersIntent?: v1CreateOauthProvidersIntent;
  deleteOauthProvidersIntent?: v1DeleteOauthProvidersIntent;
  createSubOrganizationIntentV5?: v1CreateSubOrganizationIntentV5;
  oauthIntent?: v1OauthIntent;
  createApiKeysIntentV2?: v1CreateApiKeysIntentV2;
  createReadWriteSessionIntent?: v1CreateReadWriteSessionIntent;
  emailAuthIntentV2?: v1EmailAuthIntentV2;
  createSubOrganizationIntentV6?: v1CreateSubOrganizationIntentV6;
  deletePrivateKeysIntent?: v1DeletePrivateKeysIntent;
  deleteWalletsIntent?: v1DeleteWalletsIntent;
  createReadWriteSessionIntentV2?: v1CreateReadWriteSessionIntentV2;
  deleteSubOrganizationIntent?: v1DeleteSubOrganizationIntent;
  initOtpAuthIntent?: v1InitOtpAuthIntent;
  otpAuthIntent?: v1OtpAuthIntent;
  createSubOrganizationIntentV7?: v1CreateSubOrganizationIntentV7;
  updateWalletIntent?: v1UpdateWalletIntent;
  updatePolicyIntentV2?: v1UpdatePolicyIntentV2;
  createUsersIntentV3?: v1CreateUsersIntentV3;
  initOtpAuthIntentV2?: v1InitOtpAuthIntentV2;
  initOtpIntent?: v1InitOtpIntent;
  verifyOtpIntent?: v1VerifyOtpIntent;
  otpLoginIntent?: v1OtpLoginIntent;
  stampLoginIntent?: v1StampLoginIntent;
  oauthLoginIntent?: v1OauthLoginIntent;
};

export type Invitation = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverEmail: string;
  /** A list of tags assigned to the Invitation recipient. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** The current processing status of a specified Invitation. */
  status: v1InvitationStatus;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type InvitationParams = {
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverUserEmail: string;
  /** A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type InvitationStatus = v1InvitationStatus;
export type ListPrivateKeyTagsResponse = {
  /** A list of Private Key Tags */
  privateKeyTags: datav1Tag[];
};

export type ListUserTagsResponse = {
  /** A list of User Tags */
  userTags: datav1Tag[];
};

export type MnemonicLanguage = v1MnemonicLanguage;
export type NOOPCodegenAnchorResponse = {
  stamp: v1WebAuthnStamp;
};

export type OauthRequest = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type OauthLoginRequest = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type OauthLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type OauthProvider = {
  /** Unique identifier for an OAuth Provider */
  providerId: string;
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
  issuer: string;
  /** Expected audience ('aud' attribute of the signed token) which represents the app ID */
  audience: string;
  /** Expected subject ('sub' attribute of the signed token) which represents the user ID */
  subject: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type OauthProviderParams = {
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
};

export type OauthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type Operator = v1Operator;
export type OrganizationData = {
  organizationId?: string;
  name?: string;
  users?: v1User[];
  policies?: v1Policy[];
  privateKeys?: v1PrivateKey[];
  invitations?: v1Invitation[];
  tags?: datav1Tag[];
  rootQuorum?: externaldatav1Quorum;
  features?: v1Feature[];
  wallets?: v1Wallet[];
};

export type OtpAuthRequest = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type OtpAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type OtpLoginRequest = {
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type OtpLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type Pagination = {
  /** A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
  limit?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
  before?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
  after?: string;
};

export type PathFormat = v1PathFormat;
export type PayloadEncoding = v1PayloadEncoding;
export type Policy = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Human-readable notes added by a User to describe a particular policy. */
  notes: string;
  /** A consensus expression that evalutes to true or false. */
  consensus: string;
  /** A condition expression that evalutes to true or false. */
  condition: string;
};

export type PrivateKey = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Derived cryptocurrency addresses for a given Private Key. */
  addresses: externaldatav1Address[];
  /** A list of Private Key Tag IDs. */
  privateKeyTags: string[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Private Key is exported, false otherwise. */
  exported: boolean;
  /** True when a given Private Key is imported, false otherwise. */
  imported: boolean;
};

export type PrivateKeyParams = {
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
  privateKeyTags: string[];
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type PrivateKeyResult = {
  privateKeyId?: string;
  addresses?: immutableactivityv1Address[];
};

export type PublicKeyCredentialWithAttestation = {
  id: string;
  type: string;
  rawId: string;
  authenticatorAttachment?: string;
  response: v1AuthenticatorAttestationResponse;
  clientExtensionResults: v1SimpleClientExtensionResults;
};

export type RecoverUserRequest = {
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type RecoverUserResult = {
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type RejectActivityRequest = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type RemoveOrganizationFeatureRequest = {
  /** Name of the feature to remove */
  name: v1FeatureName;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type RemoveOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type Result = {
  createOrganizationResult?: v1CreateOrganizationResult;
  createAuthenticatorsResult?: v1CreateAuthenticatorsResult;
  createUsersResult?: v1CreateUsersResult;
  createPrivateKeysResult?: v1CreatePrivateKeysResult;
  createInvitationsResult?: v1CreateInvitationsResult;
  acceptInvitationResult?: v1AcceptInvitationResult;
  signRawPayloadResult?: v1SignRawPayloadResult;
  createPolicyResult?: v1CreatePolicyResult;
  disablePrivateKeyResult?: v1DisablePrivateKeyResult;
  deleteUsersResult?: v1DeleteUsersResult;
  deleteAuthenticatorsResult?: v1DeleteAuthenticatorsResult;
  deleteInvitationResult?: v1DeleteInvitationResult;
  deleteOrganizationResult?: v1DeleteOrganizationResult;
  deletePolicyResult?: v1DeletePolicyResult;
  createUserTagResult?: v1CreateUserTagResult;
  deleteUserTagsResult?: v1DeleteUserTagsResult;
  signTransactionResult?: v1SignTransactionResult;
  deleteApiKeysResult?: v1DeleteApiKeysResult;
  createApiKeysResult?: v1CreateApiKeysResult;
  createPrivateKeyTagResult?: v1CreatePrivateKeyTagResult;
  deletePrivateKeyTagsResult?: v1DeletePrivateKeyTagsResult;
  setPaymentMethodResult?: billingSetPaymentMethodResult;
  activateBillingTierResult?: billingActivateBillingTierResult;
  deletePaymentMethodResult?: billingDeletePaymentMethodResult;
  createApiOnlyUsersResult?: v1CreateApiOnlyUsersResult;
  updateRootQuorumResult?: v1UpdateRootQuorumResult;
  updateUserTagResult?: v1UpdateUserTagResult;
  updatePrivateKeyTagResult?: v1UpdatePrivateKeyTagResult;
  createSubOrganizationResult?: v1CreateSubOrganizationResult;
  updateAllowedOriginsResult?: v1UpdateAllowedOriginsResult;
  createPrivateKeysResultV2?: v1CreatePrivateKeysResultV2;
  updateUserResult?: v1UpdateUserResult;
  updatePolicyResult?: v1UpdatePolicyResult;
  createSubOrganizationResultV3?: v1CreateSubOrganizationResultV3;
  createWalletResult?: v1CreateWalletResult;
  createWalletAccountsResult?: v1CreateWalletAccountsResult;
  initUserEmailRecoveryResult?: v1InitUserEmailRecoveryResult;
  recoverUserResult?: v1RecoverUserResult;
  setOrganizationFeatureResult?: v1SetOrganizationFeatureResult;
  removeOrganizationFeatureResult?: v1RemoveOrganizationFeatureResult;
  exportPrivateKeyResult?: v1ExportPrivateKeyResult;
  exportWalletResult?: v1ExportWalletResult;
  createSubOrganizationResultV4?: v1CreateSubOrganizationResultV4;
  emailAuthResult?: v1EmailAuthResult;
  exportWalletAccountResult?: v1ExportWalletAccountResult;
  initImportWalletResult?: v1InitImportWalletResult;
  importWalletResult?: v1ImportWalletResult;
  initImportPrivateKeyResult?: v1InitImportPrivateKeyResult;
  importPrivateKeyResult?: v1ImportPrivateKeyResult;
  createPoliciesResult?: v1CreatePoliciesResult;
  signRawPayloadsResult?: v1SignRawPayloadsResult;
  createReadOnlySessionResult?: v1CreateReadOnlySessionResult;
  createOauthProvidersResult?: v1CreateOauthProvidersResult;
  deleteOauthProvidersResult?: v1DeleteOauthProvidersResult;
  createSubOrganizationResultV5?: v1CreateSubOrganizationResultV5;
  oauthResult?: v1OauthResult;
  createReadWriteSessionResult?: v1CreateReadWriteSessionResult;
  createSubOrganizationResultV6?: v1CreateSubOrganizationResultV6;
  deletePrivateKeysResult?: v1DeletePrivateKeysResult;
  deleteWalletsResult?: v1DeleteWalletsResult;
  createReadWriteSessionResultV2?: v1CreateReadWriteSessionResultV2;
  deleteSubOrganizationResult?: v1DeleteSubOrganizationResult;
  initOtpAuthResult?: v1InitOtpAuthResult;
  otpAuthResult?: v1OtpAuthResult;
  createSubOrganizationResultV7?: v1CreateSubOrganizationResultV7;
  updateWalletResult?: v1UpdateWalletResult;
  updatePolicyResultV2?: v1UpdatePolicyResultV2;
  initOtpAuthResultV2?: v1InitOtpAuthResultV2;
  initOtpResult?: v1InitOtpResult;
  verifyOtpResult?: v1VerifyOtpResult;
  otpLoginResult?: v1OtpLoginResult;
  stampLoginResult?: v1StampLoginResult;
  oauthLoginResult?: v1OauthLoginResult;
};

export type RootUserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type Selector = {
  subject?: string;
  operator?: v1Operator;
  targets?: string[];
};

export type SetOrganizationFeatureRequest = {
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type SetOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type SignRawPayloadRequest = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type SignRawPayloadResult = {
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type SignRawPayloadsRequest = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type SignRawPayloadsResult = {
  signatures?: v1SignRawPayloadResult[];
};

export type SignTransactionRequest = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type SignTransactionResult = {
  signedTransaction: string;
};

export type SimpleClientExtensionResults = {
  appid?: boolean;
  appidExclude?: boolean;
  credProps?: v1CredPropsAuthenticationExtensionsClientOutputs;
};

export type SmsCustomizationParams = {
  /** Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
  template?: string;
};

export type StampLoginRequest = {
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type StampLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TagType = v1TagType;
export type TestRateLimitsResponse = v1TestRateLimitsResponse;
export type TransactionType = v1TransactionType;
export type UpdateAllowedOriginsRequest = {
  /** Additional origins requests are allowed from besides Turnkey origins */
  allowedOrigins: string[];
};

export type UpdateAllowedOriginsResult = v1UpdateAllowedOriginsResult;
export type UpdatePolicyRequest = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type UpdatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type UpdatePrivateKeyTagRequest = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type UpdatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type UpdateRootQuorumRequest = {
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type UpdateRootQuorumResult = v1UpdateRootQuorumResult;
export type UpdateUserRequest = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type UpdateUserResult = {
  /** A User ID. */
  userId: string;
};

export type UpdateUserTagRequest = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type UpdateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type UpdateWalletRequest = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type UpdateWalletResult = {
  /** A Wallet ID. */
  walletId: string;
};

export type User = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of Authenticator parameters. */
  authenticators: v1Authenticator[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKey[];
  /** A list of User Tag IDs. */
  userTags: string[];
  /** A list of Oauth Providers. */
  oauthProviders: v1OauthProvider[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type UserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type VerifyOtpRequest = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
  /** Unique identifier for a given Organization. */
  organizationId?: string;
};

export type VerifyOtpResult = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type Vote = {
  /** Unique identifier for a given Vote object. */
  id: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Web and/or API user within your Organization. */
  user: v1User;
  /** Unique identifier for a given Activity object. */
  activityId: string;
  selection: string;
  /** The raw message being signed within a Vote. */
  message: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The signature applied to a particular vote. */
  signature: string;
  /** Method used to produce a signature. */
  scheme: string;
  createdAt: externaldatav1Timestamp;
};

export type Wallet = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Wallet is exported, false otherwise. */
  exported: boolean;
  /** True when a given Wallet is imported, false otherwise. */
  imported: boolean;
};

export type WalletAccount = {
  /** Unique identifier for a given Wallet Account. */
  walletAccountId: string;
  /** The Organization the Account belongs to. */
  organizationId: string;
  /** The Wallet the Account was derived from. */
  walletId: string;
  /** Cryptographic curve used to generate the Account. */
  curve: v1Curve;
  /** Path format used to generate the Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate the Account. */
  path: string;
  /** Address format used to generate the Account. */
  addressFormat: v1AddressFormat;
  /** Address generated using the Wallet seed and Account parameters. */
  address: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** The public component of this wallet account's underlying cryptographic key pair. */
  publicKey?: string;
};

export type WalletAccountParams = {
  /** Cryptographic curve used to generate a wallet Account. */
  curve: v1Curve;
  /** Path format used to generate a wallet Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate a wallet Account. */
  path: string;
  /** Address format used to generate a wallet Acccount. */
  addressFormat: v1AddressFormat;
};

export type WalletParams = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type WalletResult = {
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type WebAuthnStamp = {
  /** A base64 url encoded Unique identifier for a given credential. */
  credentialId: string;
  /** A base64 encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 encoded payload containing metadata about the authenticator. */
  authenticatorData: string;
  /** The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
  signature: string;
};

