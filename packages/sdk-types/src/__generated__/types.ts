/* @generated by codegen. DO NOT EDIT BY HAND */

// --- Base Types from Swagger Definitions ---
export type apiApiKeyParams = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type billingActivateBillingTierIntent = {
  /** The product that the customer wants to subscribe to. */
  productId: string;
};

export type billingActivateBillingTierResult = {
  /** The id of the product being subscribed to. */
  productId: string;
};

export type billingDeletePaymentMethodIntent = {
  /** The payment method that the customer wants to remove. */
  paymentMethodId: string;
};

export type billingDeletePaymentMethodResult = {
  /** The payment method that was removed. */
  paymentMethodId: string;
};

export type billingSetPaymentMethodIntent = {
  /** The account number of the customer's credit card. */
  number: string;
  /** The verification digits of the customer's credit card. */
  cvv: string;
  /** The month that the credit card expires. */
  expiryMonth: string;
  /** The year that the credit card expires. */
  expiryYear: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodIntentV2 = {
  /** The id of the payment method that was created clientside. */
  paymentMethodId: string;
  /** The email that will receive invoices for the credit card. */
  cardHolderEmail: string;
  /** The name associated with the credit card. */
  cardHolderName: string;
};

export type billingSetPaymentMethodResult = {
  /** The last four digits of the credit card added. */
  lastFour: string;
  /** The name associated with the payment method. */
  cardHolderName: string;
  /** The email address associated with the payment method. */
  cardHolderEmail: string;
};

export type datav1Tag = {
  /** Unique identifier for a given Tag. */
  tagId: string;
  /** Human-readable name for a Tag. */
  tagName: string;
  tagType: v1TagType;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type externalactivityv1PolicyEvaluation = {
  /** Unique identifier for a given policy evaluation. */
  id: string;
  /** Unique identifier for a given Activity. */
  activityId: string;
  /** Unique identifier for the Organization the Activity belongs to. */
  organizationId: string;
  /** Unique identifier for the Vote associated with this policy evaluation. */
  voteId: string;
  /** Detailed evaluation result for each Policy that was run. */
  policyEvaluations: immutablecommonv1PolicyEvaluation[];
  createdAt: externaldatav1Timestamp;
};

export type externaldatav1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type externaldatav1Credential = {
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  type: v1CredentialType;
};

export type externaldatav1Quorum = {
  /** Count of unique approvals required to meet quorum. */
  threshold: number;
  /** Unique identifiers of quorum set members. */
  userIds: string[];
};

export type externaldatav1Timestamp = {
  seconds: string;
  nanos: string;
};

export type immutableactivityv1Address = {
  format?: v1AddressFormat;
  address?: string;
};

export type immutablecommonv1PolicyEvaluation = {
  policyId?: string;
  outcome?: v1Outcome;
};

export type protobufAny = {
  "@type"?: string;
  [key: string]: any;
};

export type rpcStatus = {
  code?: number;
  message?: string;
  details?: protobufAny[];
};

export type v1AcceptInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParams;
};

export type v1AcceptInvitationIntentV2 = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** WebAuthN hardware devices that can be used to log in to the Turnkey web app. */
  authenticator: v1AuthenticatorParamsV2;
};

export type v1AcceptInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1AccessType =
  | "ACCESS_TYPE_WEB"
  | "ACCESS_TYPE_API"
  | "ACCESS_TYPE_ALL";

export type v1Activity = {
  /** Unique identifier for a given Activity object. */
  id: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** The current processing status of a specified Activity. */
  status: v1ActivityStatus;
  /** Type of Activity, such as Add User, or Sign Transaction. */
  type: v1ActivityType;
  /** Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  intent: v1Intent;
  /** Result of the intended action. */
  result: v1Result;
  /** A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  votes: v1Vote[];
  /** A list of app proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations. */
  appProofs?: v1AppProof[];
  /** An artifact verifying a User's action. */
  fingerprint: string;
  canApprove: boolean;
  canReject: boolean;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Failure reason of the intended action. */
  failure?: rpcStatus;
};

export type v1ActivityResponse = {
  /** An action that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type v1ActivityStatus =
  | "ACTIVITY_STATUS_CREATED"
  | "ACTIVITY_STATUS_PENDING"
  | "ACTIVITY_STATUS_COMPLETED"
  | "ACTIVITY_STATUS_FAILED"
  | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
  | "ACTIVITY_STATUS_REJECTED";

export type v1ActivityType =
  | "ACTIVITY_TYPE_CREATE_API_KEYS"
  | "ACTIVITY_TYPE_CREATE_USERS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
  | "ACTIVITY_TYPE_CREATE_INVITATIONS"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION"
  | "ACTIVITY_TYPE_CREATE_POLICY"
  | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
  | "ACTIVITY_TYPE_DELETE_USERS"
  | "ACTIVITY_TYPE_DELETE_API_KEYS"
  | "ACTIVITY_TYPE_DELETE_INVITATION"
  | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
  | "ACTIVITY_TYPE_DELETE_POLICY"
  | "ACTIVITY_TYPE_CREATE_USER_TAG"
  | "ACTIVITY_TYPE_DELETE_USER_TAGS"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION"
  | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
  | "ACTIVITY_TYPE_REJECT_ACTIVITY"
  | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
  | "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
  | "ACTIVITY_TYPE_CREATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_POLICY_V3"
  | "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
  | "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
  | "ACTIVITY_TYPE_UPDATE_USER_TAG"
  | "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
  | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
  | "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V2"
  | "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
  | "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
  | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
  | "ACTIVITY_TYPE_UPDATE_USER"
  | "ACTIVITY_TYPE_UPDATE_POLICY"
  | "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
  | "ACTIVITY_TYPE_CREATE_WALLET"
  | "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
  | "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
  | "ACTIVITY_TYPE_RECOVER_USER"
  | "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
  | "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
  | "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_EXPORT_WALLET"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
  | "ACTIVITY_TYPE_EMAIL_AUTH"
  | "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
  | "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
  | "ACTIVITY_TYPE_IMPORT_WALLET"
  | "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
  | "ACTIVITY_TYPE_CREATE_POLICIES"
  | "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
  | "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
  | "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
  | "ACTIVITY_TYPE_OAUTH"
  | "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
  | "ACTIVITY_TYPE_EMAIL_AUTH_V2"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
  | "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
  | "ACTIVITY_TYPE_DELETE_WALLETS"
  | "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
  | "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH"
  | "ACTIVITY_TYPE_OTP_AUTH"
  | "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
  | "ACTIVITY_TYPE_UPDATE_WALLET"
  | "ACTIVITY_TYPE_UPDATE_POLICY_V2"
  | "ACTIVITY_TYPE_CREATE_USERS_V3"
  | "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
  | "ACTIVITY_TYPE_INIT_OTP"
  | "ACTIVITY_TYPE_VERIFY_OTP"
  | "ACTIVITY_TYPE_OTP_LOGIN"
  | "ACTIVITY_TYPE_STAMP_LOGIN"
  | "ACTIVITY_TYPE_OAUTH_LOGIN"
  | "ACTIVITY_TYPE_UPDATE_USER_NAME"
  | "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
  | "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
  | "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
  | "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
  | "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
  | "ACTIVITY_TYPE_ENABLE_AUTH_PROXY"
  | "ACTIVITY_TYPE_DISABLE_AUTH_PROXY"
  | "ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG"
  | "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL"
  | "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL"
  | "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL"
  | "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE";

export type v1AddressFormat =
  | "ADDRESS_FORMAT_UNCOMPRESSED"
  | "ADDRESS_FORMAT_COMPRESSED"
  | "ADDRESS_FORMAT_ETHEREUM"
  | "ADDRESS_FORMAT_SOLANA"
  | "ADDRESS_FORMAT_COSMOS"
  | "ADDRESS_FORMAT_TRON"
  | "ADDRESS_FORMAT_SUI"
  | "ADDRESS_FORMAT_APTOS"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
  | "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
  | "ADDRESS_FORMAT_SEI"
  | "ADDRESS_FORMAT_XLM"
  | "ADDRESS_FORMAT_DOGE_MAINNET"
  | "ADDRESS_FORMAT_DOGE_TESTNET"
  | "ADDRESS_FORMAT_TON_V3R2"
  | "ADDRESS_FORMAT_TON_V4R2"
  | "ADDRESS_FORMAT_TON_V5R1"
  | "ADDRESS_FORMAT_XRP";

export type v1ApiKey = {
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given API Key. */
  apiKeyId: string;
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiKeyCurve =
  | "API_KEY_CURVE_P256"
  | "API_KEY_CURVE_SECP256K1"
  | "API_KEY_CURVE_ED25519";

export type v1ApiKeyParamsV2 = {
  /** Human-readable name for an API Key. */
  apiKeyName: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The curve type to be used for processing API key signatures. */
  curveType: v1ApiKeyCurve;
  /** Optional window (in seconds) indicating how long the API Key should last. */
  expirationSeconds?: string;
};

export type v1ApiOnlyUserParams = {
  /** The name of the new API-only User. */
  userName: string;
  /** The email address for this API-only User (optional). */
  userEmail?: string;
  /** A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
};

export type v1AppProof = {
  /** Scheme of signing key. */
  scheme: v1SignatureScheme;
  /** Ephemeral public key. */
  publicKey: string;
  /** JSON serialized AppProofPayload. */
  proofPayload: string;
  /** Signature over hashed proof_payload. */
  signature: string;
};

export type v1ApproveActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1ApproveActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ApproveActivityIntent;
};

export type v1Attestation = {
  /** The cbor encoded then base64 url encoded id of the credential. */
  credentialId: string;
  /** A base64 url encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses. */
  attestationObject: string;
  /** The type of authenticator transports. */
  transports: v1AuthenticatorTransport[];
};

export type v1Authenticator = {
  /** Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
  transports: v1AuthenticatorTransport[];
  attestationType: string;
  /** Identifier indicating the type of the Security Key. */
  aaguid: string;
  /** Unique identifier for a WebAuthn credential. */
  credentialId: string;
  /** The type of Authenticator device. */
  model: string;
  /** A User credential that can be used to authenticate to Turnkey. */
  credential: externaldatav1Credential;
  /** Unique identifier for a given Authenticator. */
  authenticatorId: string;
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1AuthenticatorAttestationResponse = {
  clientDataJson: string;
  attestationObject: string;
  transports?: v1AuthenticatorTransport[];
  authenticatorAttachment?: string;
};

export type v1AuthenticatorParams = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Unique identifier for a given User. */
  userId: string;
  attestation: v1PublicKeyCredentialWithAttestation;
  /** Challenge presented for authentication purposes. */
  challenge: string;
};

export type v1AuthenticatorParamsV2 = {
  /** Human-readable name for an Authenticator. */
  authenticatorName: string;
  /** Challenge presented for authentication purposes. */
  challenge: string;
  /** The attestation that proves custody of the authenticator and provides metadata about it. */
  attestation: v1Attestation;
};

export type v1AuthenticatorTransport =
  | "AUTHENTICATOR_TRANSPORT_BLE"
  | "AUTHENTICATOR_TRANSPORT_INTERNAL"
  | "AUTHENTICATOR_TRANSPORT_NFC"
  | "AUTHENTICATOR_TRANSPORT_USB"
  | "AUTHENTICATOR_TRANSPORT_HYBRID";

export type v1BootProof = {
  /** The hex encoded Ephemeral Public Key. */
  ephemeralPublicKeyHex: string;
  /** The DER encoded COSE Sign1 struct Attestation doc. */
  awsAttestationDocB64: string;
  /** The borsch serialized base64 encoded Manifest. */
  qosManifestB64: string;
  /** The borsch serialized base64 encoded Manifest Envelope. */
  qosManifestEnvelopeB64: string;
  /** The label under which the enclave app was deployed. */
  deploymentLabel: string;
  /** Name of the enclave app */
  enclaveApp: string;
  /** Owner of the app i.e. 'tkhq' */
  owner: string;
  createdAt: externaldatav1Timestamp;
};

export type v1BootProofResponse = {
  bootProof: v1BootProof;
};

export type v1Config = {
  features?: v1Feature[];
  quorum?: externaldatav1Quorum;
};

export type v1CreateApiKeysIntent = {
  /** A list of API Keys. */
  apiKeys: apiApiKeyParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysIntentV2 = {
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiKeysIntentV2;
};

export type v1CreateApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1CreateApiOnlyUsersIntent = {
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
};

export type v1CreateApiOnlyUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateApiOnlyUsersIntent;
};

export type v1CreateApiOnlyUsersResult = {
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type v1CreateAuthenticatorsIntent = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParams[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsIntentV2 = {
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type v1CreateAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateAuthenticatorsIntentV2;
};

export type v1CreateAuthenticatorsResult = {
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1CreateInvitationsIntent = {
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
};

export type v1CreateInvitationsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateInvitationsIntent;
};

export type v1CreateInvitationsResult = {
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type v1CreateOauth2CredentialIntent = {
  /** The OAuth 2.0 provider */
  provider: v1Oauth2Provider;
  /** The Client ID issued by the OAuth 2.0 provider */
  clientId: string;
  /** The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key */
  encryptedClientSecret: string;
};

export type v1CreateOauth2CredentialRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateOauth2CredentialIntent;
};

export type v1CreateOauth2CredentialResult = {
  /** Unique identifier of the OAuth 2.0 credential that was created */
  oauth2CredentialId: string;
};

export type v1CreateOauthProvidersIntent = {
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1CreateOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateOauthProvidersIntent;
};

export type v1CreateOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1CreateOrganizationIntent = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParams;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationIntentV2 = {
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** The root user's email address. */
  rootEmail: string;
  /** The root user's Authenticator. */
  rootAuthenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the root user object. */
  rootUserId?: string;
};

export type v1CreateOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1CreatePoliciesIntent = {
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
};

export type v1CreatePoliciesRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePoliciesIntent;
};

export type v1CreatePoliciesResult = {
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type v1CreatePolicyIntent = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1Selector[];
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV2 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
  selectors: v1SelectorV2[];
  /** Whether to ALLOW or DENY requests that match the condition and consensus requirements. */
  effect: v1Effect;
  notes?: string;
};

export type v1CreatePolicyIntentV3 = {
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type v1CreatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePolicyIntentV3;
};

export type v1CreatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1CreatePrivateKeyTagIntent = {
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeyTagIntent;
};

export type v1CreatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysIntent = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysIntentV2 = {
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreatePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreatePrivateKeysIntentV2;
};

export type v1CreatePrivateKeysResult = {
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1CreatePrivateKeysResultV2 = {
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type v1CreateReadOnlySessionIntent = {};
export type v1CreateReadOnlySessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadOnlySessionIntent;
};

export type v1CreateReadOnlySessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type v1CreateReadWriteSessionIntent = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Email of the user to create a read write session for */
  email: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
};

export type v1CreateReadWriteSessionIntentV2 = {
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type v1CreateReadWriteSessionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateReadWriteSessionIntentV2;
};

export type v1CreateReadWriteSessionResult = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateReadWriteSessionResultV2 = {
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1CreateSmartContractInterfaceIntent = {
  /** Corresponding contract address or program ID */
  smartContractAddress: string;
  /** ABI/IDL as a JSON string */
  smartContractInterface: string;
  type: v1SmartContractInterfaceType;
  /** Human-readable name for a Smart Contract Interface. */
  label: string;
  /** Notes for a Smart Contract Interface. */
  notes?: string;
};

export type v1CreateSmartContractInterfaceRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateSmartContractInterfaceIntent;
};

export type v1CreateSmartContractInterfaceResult = {
  /** The ID of the created Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type v1CreateSubOrganizationIntent = {
  /** Name for this sub-organization */
  name: string;
  /** Root User authenticator for this new sub-organization */
  rootAuthenticator: v1AuthenticatorParamsV2;
};

export type v1CreateSubOrganizationIntentV2 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
};

export type v1CreateSubOrganizationIntentV3 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type v1CreateSubOrganizationIntentV4 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParams[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV5 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV2[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV6 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV3[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
};

export type v1CreateSubOrganizationIntentV7 = {
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1CreateSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateSubOrganizationIntentV7;
};

export type v1CreateSubOrganizationResult = {
  subOrganizationId: string;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV3 = {
  subOrganizationId: string;
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV4 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV5 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV6 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateSubOrganizationResultV7 = {
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type v1CreateUserTagIntent = {
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUserTagIntent;
};

export type v1CreateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateUsersIntent = {
  /** A list of Users. */
  users: v1UserParams[];
};

export type v1CreateUsersIntentV2 = {
  /** A list of Users. */
  users: v1UserParamsV2[];
};

export type v1CreateUsersIntentV3 = {
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type v1CreateUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateUsersIntentV3;
};

export type v1CreateUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1CreateWalletAccountsIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1CreateWalletAccountsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletAccountsIntent;
};

export type v1CreateWalletAccountsResult = {
  /** A list of derived addresses. */
  addresses: string[];
};

export type v1CreateWalletIntent = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1CreateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1CreateWalletIntent;
};

export type v1CreateWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1CredPropsAuthenticationExtensionsClientOutputs = {
  rk: boolean;
};

export type v1CredentialType =
  | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
  | "CREDENTIAL_TYPE_API_KEY_P256"
  | "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_SECP256K1"
  | "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_API_KEY_ED25519"
  | "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
  | "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
  | "CREDENTIAL_TYPE_OAUTH_KEY_P256"
  | "CREDENTIAL_TYPE_LOGIN";

export type v1Curve = "CURVE_SECP256K1" | "CURVE_ED25519";

export type v1DeleteApiKeysIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteApiKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteApiKeysIntent;
};

export type v1DeleteApiKeysResult = {
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type v1DeleteAuthenticatorsIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type v1DeleteAuthenticatorsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteAuthenticatorsIntent;
};

export type v1DeleteAuthenticatorsResult = {
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type v1DeleteInvitationIntent = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type v1DeleteInvitationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteInvitationIntent;
};

export type v1DeleteInvitationResult = {
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type v1DeleteOauth2CredentialIntent = {
  /** The ID of the OAuth 2.0 credential to delete */
  oauth2CredentialId: string;
};

export type v1DeleteOauth2CredentialRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteOauth2CredentialIntent;
};

export type v1DeleteOauth2CredentialResult = {
  /** Unique identifier of the OAuth 2.0 credential that was deleted */
  oauth2CredentialId: string;
};

export type v1DeleteOauthProvidersIntent = {
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type v1DeleteOauthProvidersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteOauthProvidersIntent;
};

export type v1DeleteOauthProvidersResult = {
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type v1DeleteOrganizationIntent = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeleteOrganizationResult = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1DeletePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePolicyIntent;
};

export type v1DeletePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1DeletePrivateKeyTagsIntent = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type v1DeletePrivateKeyTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeyTagsIntent;
};

export type v1DeletePrivateKeyTagsResult = {
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type v1DeletePrivateKeysIntent = {
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeletePrivateKeysRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeletePrivateKeysIntent;
};

export type v1DeletePrivateKeysResult = {
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type v1DeleteSmartContractInterfaceIntent = {
  /** The ID of a Smart Contract Interface intended for deletion. */
  smartContractInterfaceId: string;
};

export type v1DeleteSmartContractInterfaceRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteSmartContractInterfaceIntent;
};

export type v1DeleteSmartContractInterfaceResult = {
  /** The ID of the deleted Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type v1DeleteSubOrganizationIntent = {
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteSubOrganizationRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteSubOrganizationIntent;
};

export type v1DeleteSubOrganizationResult = {
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type v1DeleteUserTagsIntent = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type v1DeleteUserTagsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUserTagsIntent;
};

export type v1DeleteUserTagsResult = {
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersIntent = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteUsersRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteUsersIntent;
};

export type v1DeleteUsersResult = {
  /** A list of User IDs. */
  userIds: string[];
};

export type v1DeleteWalletsIntent = {
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type v1DeleteWalletsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1DeleteWalletsIntent;
};

export type v1DeleteWalletsResult = {
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type v1DisableAuthProxyIntent = {};
export type v1DisableAuthProxyResult = {};
export type v1DisablePrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1DisablePrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
};

export type v1Effect = "EFFECT_ALLOW" | "EFFECT_DENY";

export type v1EmailAuthIntent = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthIntentV2 = {
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1EmailAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1EmailAuthIntentV2;
};

export type v1EmailAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type v1EmailCustomizationParams = {
  /** The name of the application. */
  appName?: string;
  /** A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px. */
  logoUrl?: string;
  /** A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`. */
  magicLinkTemplate?: string;
  /** JSON object containing key/value pairs to be used with custom templates. */
  templateVariables?: string;
  /** Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template. */
  templateId?: string;
};

export type v1EnableAuthProxyIntent = {};
export type v1EnableAuthProxyResult = {
  /** A User ID with permission to initiate authentication. */
  userId: string;
};

export type v1ExportPrivateKeyIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportPrivateKeyIntent;
};

export type v1ExportPrivateKeyResult = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletAccountIntent = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type v1ExportWalletAccountRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletAccountIntent;
};

export type v1ExportWalletAccountResult = {
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1ExportWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
};

export type v1ExportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ExportWalletIntent;
};

export type v1ExportWalletResult = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type v1Feature = {
  name?: v1FeatureName;
  value?: string;
};

export type v1FeatureName =
  | "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBAUTHN_ORIGINS"
  | "FEATURE_NAME_EMAIL_AUTH"
  | "FEATURE_NAME_EMAIL_RECOVERY"
  | "FEATURE_NAME_WEBHOOK"
  | "FEATURE_NAME_SMS_AUTH"
  | "FEATURE_NAME_OTP_EMAIL_AUTH"
  | "FEATURE_NAME_AUTH_PROXY";

export type v1FiatOnRampBlockchainNetwork =
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA"
  | "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE";

export type v1FiatOnRampCryptoCurrency =
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL"
  | "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";

export type v1FiatOnRampCurrency =
  | "FIAT_ON_RAMP_CURRENCY_AUD"
  | "FIAT_ON_RAMP_CURRENCY_BGN"
  | "FIAT_ON_RAMP_CURRENCY_BRL"
  | "FIAT_ON_RAMP_CURRENCY_CAD"
  | "FIAT_ON_RAMP_CURRENCY_CHF"
  | "FIAT_ON_RAMP_CURRENCY_COP"
  | "FIAT_ON_RAMP_CURRENCY_CZK"
  | "FIAT_ON_RAMP_CURRENCY_DKK"
  | "FIAT_ON_RAMP_CURRENCY_DOP"
  | "FIAT_ON_RAMP_CURRENCY_EGP"
  | "FIAT_ON_RAMP_CURRENCY_EUR"
  | "FIAT_ON_RAMP_CURRENCY_GBP"
  | "FIAT_ON_RAMP_CURRENCY_HKD"
  | "FIAT_ON_RAMP_CURRENCY_IDR"
  | "FIAT_ON_RAMP_CURRENCY_ILS"
  | "FIAT_ON_RAMP_CURRENCY_JOD"
  | "FIAT_ON_RAMP_CURRENCY_KES"
  | "FIAT_ON_RAMP_CURRENCY_KWD"
  | "FIAT_ON_RAMP_CURRENCY_LKR"
  | "FIAT_ON_RAMP_CURRENCY_MXN"
  | "FIAT_ON_RAMP_CURRENCY_NGN"
  | "FIAT_ON_RAMP_CURRENCY_NOK"
  | "FIAT_ON_RAMP_CURRENCY_NZD"
  | "FIAT_ON_RAMP_CURRENCY_OMR"
  | "FIAT_ON_RAMP_CURRENCY_PEN"
  | "FIAT_ON_RAMP_CURRENCY_PLN"
  | "FIAT_ON_RAMP_CURRENCY_RON"
  | "FIAT_ON_RAMP_CURRENCY_SEK"
  | "FIAT_ON_RAMP_CURRENCY_THB"
  | "FIAT_ON_RAMP_CURRENCY_TRY"
  | "FIAT_ON_RAMP_CURRENCY_TWD"
  | "FIAT_ON_RAMP_CURRENCY_USD"
  | "FIAT_ON_RAMP_CURRENCY_VND"
  | "FIAT_ON_RAMP_CURRENCY_ZAR";

export type v1FiatOnRampPaymentMethod =
  | "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET"
  | "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT";

export type v1FiatOnRampProvider =
  | "FIAT_ON_RAMP_PROVIDER_COINBASE"
  | "FIAT_ON_RAMP_PROVIDER_MOONPAY";

export type v1GetActivitiesRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Array of activity statuses filtering which activities will be listed in the response. */
  filterByStatus?: v1ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
  /** Array of activity types filtering which activities will be listed in the response. */
  filterByType?: v1ActivityType[];
};

export type v1GetActivitiesResponse = {
  /** A list of activities. */
  activities: v1Activity[];
};

export type v1GetActivityRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given activity object. */
  activityId: string;
};

export type v1GetApiKeyRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type v1GetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type v1GetApiKeysRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given user. */
  userId?: string;
};

export type v1GetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type v1GetAppProofsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given activity. */
  activityId: string;
};

export type v1GetAppProofsResponse = {
  appProofs: v1AppProof[];
};

export type v1GetAttestationDocumentRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser. */
  enclaveType: string;
};

export type v1GetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document. */
  attestationDocument: string;
};

export type v1GetAuthenticatorRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given authenticator. */
  authenticatorId: string;
};

export type v1GetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type v1GetAuthenticatorsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given user. */
  userId: string;
};

export type v1GetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type v1GetBootProofRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Hex encoded ephemeral public key. */
  ephemeralKey: string;
};

export type v1GetLatestBootProofRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Name of enclave app. */
  appName: string;
};

export type v1GetOauth2CredentialRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
  /** Unique identifier for a given OAuth 2.0 Credential. */
  oauth2CredentialId: string;
};

export type v1GetOauth2CredentialResponse = {
  oauth2Credential: v1Oauth2Credential;
};

export type v1GetOauthProvidersRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given user. */
  userId?: string;
};

export type v1GetOauthProvidersResponse = {
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProvider[];
};

export type v1GetOrganizationConfigsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features. */
  configs: v1Config;
};

export type v1GetOrganizationRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization. */
  organizationData: v1OrganizationData;
};

export type v1GetPoliciesRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetPoliciesResponse = {
  /** A list of policies. */
  policies: v1Policy[];
};

export type v1GetPolicyEvaluationsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given activity. */
  activityId: string;
};

export type v1GetPolicyEvaluationsResponse = {
  policyEvaluations: externalactivityv1PolicyEvaluation[];
};

export type v1GetPolicyRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given policy. */
  policyId: string;
};

export type v1GetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an organization. */
  policy: v1Policy;
};

export type v1GetPrivateKeyRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given private key. */
  privateKeyId: string;
};

export type v1GetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type v1GetPrivateKeysRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetPrivateKeysResponse = {
  /** A list of private keys. */
  privateKeys: v1PrivateKey[];
};

export type v1GetSmartContractInterfaceRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given smart contract interface. */
  smartContractInterfaceId: string;
};

export type v1GetSmartContractInterfaceResponse = {
  /** Object to be used in conjunction with policies to guard transaction signing. */
  smartContractInterface: v1SmartContractInterface;
};

export type v1GetSmartContractInterfacesRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetSmartContractInterfacesResponse = {
  /** A list of smart contract interfaces. */
  smartContractInterfaces: v1SmartContractInterface[];
};

export type v1GetSubOrgIdsRequest = {
  /** Unique identifier for the parent organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetUserRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given user. */
  userId: string;
};

export type v1GetUserResponse = {
  /** Web and/or API user within your organization. */
  user: v1User;
};

export type v1GetUsersRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetUsersResponse = {
  /** A list of users. */
  users: v1User[];
};

export type v1GetVerifiedSubOrgIdsRequest = {
  /** Unique identifier for the parent organization. This is used to find sub-organizations within it. */
  organizationId: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'. */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type v1GetWalletAccountRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given wallet. */
  walletId: string;
  /** Address corresponding to a wallet account. */
  address?: string;
  /** Path corresponding to a wallet account. */
  path?: string;
};

export type v1GetWalletAccountResponse = {
  /** The resulting wallet account. */
  account: v1WalletAccount;
};

export type v1GetWalletAccountsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned. */
  walletId?: string;
  /** Optional flag to specify if the wallet details should be included in the response. Default = false. */
  includeWalletDetails?: boolean;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type v1GetWalletAccountsResponse = {
  /** A list of accounts generated from a wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type v1GetWalletRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Unique identifier for a given wallet. */
  walletId: string;
};

export type v1GetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed. */
  wallet: v1Wallet;
};

export type v1GetWalletsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1GetWalletsResponse = {
  /** A list of wallets. */
  wallets: v1Wallet[];
};

export type v1GetWhoamiRequest = {
  /** Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
};

export type v1GetWhoamiResponse = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Human-readable name for an organization. */
  organizationName: string;
  /** Unique identifier for a given user. */
  userId: string;
  /** Human-readable name for a user. */
  username: string;
};

export type v1HashFunction =
  | "HASH_FUNCTION_NO_OP"
  | "HASH_FUNCTION_SHA256"
  | "HASH_FUNCTION_KECCAK256"
  | "HASH_FUNCTION_NOT_APPLICABLE";

export type v1ImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1ImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportPrivateKeyIntent;
};

export type v1ImportPrivateKeyResult = {
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type v1ImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type v1ImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1ImportWalletIntent;
};

export type v1ImportWalletResult = {
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1InitFiatOnRampIntent = {
  /** Enum to specifiy which on-ramp provider to use */
  onrampProvider: v1FiatOnRampProvider;
  /** Destination wallet address for the buy transaction. */
  walletAddress: string;
  /** Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork. */
  network: v1FiatOnRampBlockchainNetwork;
  /** Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset. */
  cryptoCurrencyCode: v1FiatOnRampCryptoCurrency;
  /** Code for the fiat currency to be used in the transaction, e.g., USD, EUR. */
  fiatCurrencyCode?: v1FiatOnRampCurrency;
  /** Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount. */
  fiatCurrencyAmount?: string;
  /** Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider. */
  paymentMethod?: v1FiatOnRampPaymentMethod;
  /** ISO 3166-1 two-digit country code for Coinbase representing the purchasing user’s country of residence, e.g., US, GB. */
  countryCode?: string;
  /** ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing user’s subdivision of residence within their country, e.g. NY. Required if country_code=US. */
  countrySubdivisionCode?: string;
  /** Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false. */
  sandboxMode?: boolean;
  /** Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled. */
  urlForSignature?: string;
};

export type v1InitFiatOnRampRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitFiatOnRampIntent;
};

export type v1InitFiatOnRampResult = {
  /** Unique URL for a given fiat on-ramp flow. */
  onRampUrl: string;
  /** Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow. */
  onRampTransactionId: string;
  /** Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project. */
  onRampUrlSignature?: string;
};

export type v1InitImportPrivateKeyIntent = {
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type v1InitImportPrivateKeyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportPrivateKeyIntent;
};

export type v1InitImportPrivateKeyResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitImportWalletIntent = {
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type v1InitImportWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitImportWalletIntent;
};

export type v1InitImportWalletResult = {
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type v1InitOtpAuthIntent = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthIntentV2 = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpAuthIntentV2;
};

export type v1InitOtpAuthResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpAuthResultV2 = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitOtpIntent = {
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type v1InitOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitOtpIntent;
};

export type v1InitOtpResult = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type v1InitUserEmailRecoveryIntent = {
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
};

export type v1InitUserEmailRecoveryRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1InitUserEmailRecoveryIntent;
};

export type v1InitUserEmailRecoveryResult = {
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type v1Intent = {
  createOrganizationIntent?: v1CreateOrganizationIntent;
  createAuthenticatorsIntent?: v1CreateAuthenticatorsIntent;
  createUsersIntent?: v1CreateUsersIntent;
  createPrivateKeysIntent?: v1CreatePrivateKeysIntent;
  signRawPayloadIntent?: v1SignRawPayloadIntent;
  createInvitationsIntent?: v1CreateInvitationsIntent;
  acceptInvitationIntent?: v1AcceptInvitationIntent;
  createPolicyIntent?: v1CreatePolicyIntent;
  disablePrivateKeyIntent?: v1DisablePrivateKeyIntent;
  deleteUsersIntent?: v1DeleteUsersIntent;
  deleteAuthenticatorsIntent?: v1DeleteAuthenticatorsIntent;
  deleteInvitationIntent?: v1DeleteInvitationIntent;
  deleteOrganizationIntent?: v1DeleteOrganizationIntent;
  deletePolicyIntent?: v1DeletePolicyIntent;
  createUserTagIntent?: v1CreateUserTagIntent;
  deleteUserTagsIntent?: v1DeleteUserTagsIntent;
  signTransactionIntent?: v1SignTransactionIntent;
  createApiKeysIntent?: v1CreateApiKeysIntent;
  deleteApiKeysIntent?: v1DeleteApiKeysIntent;
  approveActivityIntent?: v1ApproveActivityIntent;
  rejectActivityIntent?: v1RejectActivityIntent;
  createPrivateKeyTagIntent?: v1CreatePrivateKeyTagIntent;
  deletePrivateKeyTagsIntent?: v1DeletePrivateKeyTagsIntent;
  createPolicyIntentV2?: v1CreatePolicyIntentV2;
  setPaymentMethodIntent?: billingSetPaymentMethodIntent;
  activateBillingTierIntent?: billingActivateBillingTierIntent;
  deletePaymentMethodIntent?: billingDeletePaymentMethodIntent;
  createPolicyIntentV3?: v1CreatePolicyIntentV3;
  createApiOnlyUsersIntent?: v1CreateApiOnlyUsersIntent;
  updateRootQuorumIntent?: v1UpdateRootQuorumIntent;
  updateUserTagIntent?: v1UpdateUserTagIntent;
  updatePrivateKeyTagIntent?: v1UpdatePrivateKeyTagIntent;
  createAuthenticatorsIntentV2?: v1CreateAuthenticatorsIntentV2;
  acceptInvitationIntentV2?: v1AcceptInvitationIntentV2;
  createOrganizationIntentV2?: v1CreateOrganizationIntentV2;
  createUsersIntentV2?: v1CreateUsersIntentV2;
  createSubOrganizationIntent?: v1CreateSubOrganizationIntent;
  createSubOrganizationIntentV2?: v1CreateSubOrganizationIntentV2;
  updateAllowedOriginsIntent?: v1UpdateAllowedOriginsIntent;
  createPrivateKeysIntentV2?: v1CreatePrivateKeysIntentV2;
  updateUserIntent?: v1UpdateUserIntent;
  updatePolicyIntent?: v1UpdatePolicyIntent;
  setPaymentMethodIntentV2?: billingSetPaymentMethodIntentV2;
  createSubOrganizationIntentV3?: v1CreateSubOrganizationIntentV3;
  createWalletIntent?: v1CreateWalletIntent;
  createWalletAccountsIntent?: v1CreateWalletAccountsIntent;
  initUserEmailRecoveryIntent?: v1InitUserEmailRecoveryIntent;
  recoverUserIntent?: v1RecoverUserIntent;
  setOrganizationFeatureIntent?: v1SetOrganizationFeatureIntent;
  removeOrganizationFeatureIntent?: v1RemoveOrganizationFeatureIntent;
  signRawPayloadIntentV2?: v1SignRawPayloadIntentV2;
  signTransactionIntentV2?: v1SignTransactionIntentV2;
  exportPrivateKeyIntent?: v1ExportPrivateKeyIntent;
  exportWalletIntent?: v1ExportWalletIntent;
  createSubOrganizationIntentV4?: v1CreateSubOrganizationIntentV4;
  emailAuthIntent?: v1EmailAuthIntent;
  exportWalletAccountIntent?: v1ExportWalletAccountIntent;
  initImportWalletIntent?: v1InitImportWalletIntent;
  importWalletIntent?: v1ImportWalletIntent;
  initImportPrivateKeyIntent?: v1InitImportPrivateKeyIntent;
  importPrivateKeyIntent?: v1ImportPrivateKeyIntent;
  createPoliciesIntent?: v1CreatePoliciesIntent;
  signRawPayloadsIntent?: v1SignRawPayloadsIntent;
  createReadOnlySessionIntent?: v1CreateReadOnlySessionIntent;
  createOauthProvidersIntent?: v1CreateOauthProvidersIntent;
  deleteOauthProvidersIntent?: v1DeleteOauthProvidersIntent;
  createSubOrganizationIntentV5?: v1CreateSubOrganizationIntentV5;
  oauthIntent?: v1OauthIntent;
  createApiKeysIntentV2?: v1CreateApiKeysIntentV2;
  createReadWriteSessionIntent?: v1CreateReadWriteSessionIntent;
  emailAuthIntentV2?: v1EmailAuthIntentV2;
  createSubOrganizationIntentV6?: v1CreateSubOrganizationIntentV6;
  deletePrivateKeysIntent?: v1DeletePrivateKeysIntent;
  deleteWalletsIntent?: v1DeleteWalletsIntent;
  createReadWriteSessionIntentV2?: v1CreateReadWriteSessionIntentV2;
  deleteSubOrganizationIntent?: v1DeleteSubOrganizationIntent;
  initOtpAuthIntent?: v1InitOtpAuthIntent;
  otpAuthIntent?: v1OtpAuthIntent;
  createSubOrganizationIntentV7?: v1CreateSubOrganizationIntentV7;
  updateWalletIntent?: v1UpdateWalletIntent;
  updatePolicyIntentV2?: v1UpdatePolicyIntentV2;
  createUsersIntentV3?: v1CreateUsersIntentV3;
  initOtpAuthIntentV2?: v1InitOtpAuthIntentV2;
  initOtpIntent?: v1InitOtpIntent;
  verifyOtpIntent?: v1VerifyOtpIntent;
  otpLoginIntent?: v1OtpLoginIntent;
  stampLoginIntent?: v1StampLoginIntent;
  oauthLoginIntent?: v1OauthLoginIntent;
  updateUserNameIntent?: v1UpdateUserNameIntent;
  updateUserEmailIntent?: v1UpdateUserEmailIntent;
  updateUserPhoneNumberIntent?: v1UpdateUserPhoneNumberIntent;
  initFiatOnRampIntent?: v1InitFiatOnRampIntent;
  createSmartContractInterfaceIntent?: v1CreateSmartContractInterfaceIntent;
  deleteSmartContractInterfaceIntent?: v1DeleteSmartContractInterfaceIntent;
  enableAuthProxyIntent?: v1EnableAuthProxyIntent;
  disableAuthProxyIntent?: v1DisableAuthProxyIntent;
  updateAuthProxyConfigIntent?: v1UpdateAuthProxyConfigIntent;
  createOauth2CredentialIntent?: v1CreateOauth2CredentialIntent;
  updateOauth2CredentialIntent?: v1UpdateOauth2CredentialIntent;
  deleteOauth2CredentialIntent?: v1DeleteOauth2CredentialIntent;
  oauth2AuthenticateIntent?: v1Oauth2AuthenticateIntent;
};

export type v1Invitation = {
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverEmail: string;
  /** A list of tags assigned to the Invitation recipient. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** The current processing status of a specified Invitation. */
  status: v1InvitationStatus;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationParams = {
  /** The name of the intended Invitation recipient. */
  receiverUserName: string;
  /** The email address of the intended Invitation recipient. */
  receiverUserEmail: string;
  /** A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body. */
  receiverUserTags: string[];
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** Unique identifier for the Sender of an Invitation. */
  senderUserId: string;
};

export type v1InvitationStatus =
  | "INVITATION_STATUS_CREATED"
  | "INVITATION_STATUS_ACCEPTED"
  | "INVITATION_STATUS_REVOKED";

export type v1ListOauth2CredentialsRequest = {
  /** Unique identifier for a given Organization. */
  organizationId: string;
};

export type v1ListOauth2CredentialsResponse = {
  oauth2Credentials: v1Oauth2Credential[];
};

export type v1ListPrivateKeyTagsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1ListPrivateKeyTagsResponse = {
  /** A list of private key tags. */
  privateKeyTags: datav1Tag[];
};

export type v1ListUserTagsRequest = {
  /** Unique identifier for a given organization. */
  organizationId: string;
};

export type v1ListUserTagsResponse = {
  /** A list of user tags. */
  userTags: datav1Tag[];
};

export type v1MnemonicLanguage =
  | "MNEMONIC_LANGUAGE_ENGLISH"
  | "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
  | "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
  | "MNEMONIC_LANGUAGE_CZECH"
  | "MNEMONIC_LANGUAGE_FRENCH"
  | "MNEMONIC_LANGUAGE_ITALIAN"
  | "MNEMONIC_LANGUAGE_JAPANESE"
  | "MNEMONIC_LANGUAGE_KOREAN"
  | "MNEMONIC_LANGUAGE_SPANISH";

export type v1NOOPCodegenAnchorResponse = {
  stamp: v1WebAuthnStamp;
};

export type v1Oauth2AuthenticateIntent = {
  /** The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow */
  oauth2CredentialId: string;
  /** The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow */
  authCode: string;
  /** The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider */
  redirectUri: string;
  /** The code verifier used by OAuth 2.0 PKCE providers */
  codeVerifier: string;
  /** An optional nonce used by the client to prevent replay/substitution of an ID token */
  nonce?: string;
  /** An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token */
  bearerTokenTargetPublicKey?: string;
};

export type v1Oauth2AuthenticateRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1Oauth2AuthenticateIntent;
};

export type v1Oauth2AuthenticateResult = {
  /** Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity */
  oidcToken: string;
};

export type v1Oauth2Credential = {
  /** Unique identifier for a given OAuth 2.0 Credential. */
  oauth2CredentialId: string;
  /** Unique identifier for an Organization. */
  organizationId: string;
  /** The provider for a given OAuth 2.0 Credential. */
  provider: v1Oauth2Provider;
  /** The client id for a given OAuth 2.0 Credential. */
  clientId: string;
  /** The encrypted client secret for a given OAuth 2.0 Credential encrypted to the TLS Fetcher quorum key. */
  encryptedClientSecret: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1Oauth2Provider = "OAUTH2_PROVIDER_X" | "OAUTH2_PROVIDER_DISCORD";

export type v1OauthIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginIntent = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1OauthLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthLoginIntent;
};

export type v1OauthLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1OauthProvider = {
  /** Unique identifier for an OAuth Provider */
  providerId: string;
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com */
  issuer: string;
  /** Expected audience ('aud' attribute of the signed token) which represents the app ID */
  audience: string;
  /** Expected subject ('sub' attribute of the signed token) which represents the user ID */
  subject: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1OauthProviderParams = {
  /** Human-readable name to identify a Provider. */
  providerName: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
};

export type v1OauthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OauthIntent;
};

export type v1OauthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type v1Operator =
  | "OPERATOR_EQUAL"
  | "OPERATOR_MORE_THAN"
  | "OPERATOR_MORE_THAN_OR_EQUAL"
  | "OPERATOR_LESS_THAN"
  | "OPERATOR_LESS_THAN_OR_EQUAL"
  | "OPERATOR_CONTAINS"
  | "OPERATOR_NOT_EQUAL"
  | "OPERATOR_IN"
  | "OPERATOR_NOT_IN"
  | "OPERATOR_CONTAINS_ONE"
  | "OPERATOR_CONTAINS_ALL";

export type v1OrganizationData = {
  organizationId?: string;
  name?: string;
  users?: v1User[];
  policies?: v1Policy[];
  privateKeys?: v1PrivateKey[];
  invitations?: v1Invitation[];
  tags?: datav1Tag[];
  rootQuorum?: externaldatav1Quorum;
  features?: v1Feature[];
  wallets?: v1Wallet[];
  smartContractInterfaceReferences?: v1SmartContractInterfaceReference[];
};

export type v1OtpAuthIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type v1OtpAuthRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpAuthIntent;
};

export type v1OtpAuthResult = {
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type v1OtpLoginIntent = {
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Optional signature associated with the public key passed into the verification step. This must be a hex-encoded ECDSA signature over the verification token. Only required if a public key was provided during the verification step. */
  clientSignature?: string;
};

export type v1OtpLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1OtpLoginIntent;
};

export type v1OtpLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1Outcome =
  | "OUTCOME_ALLOW"
  | "OUTCOME_DENY_EXPLICIT"
  | "OUTCOME_DENY_IMPLICIT"
  | "OUTCOME_REQUIRES_CONSENSUS"
  | "OUTCOME_REJECTED"
  | "OUTCOME_ERROR";

export type v1Pagination = {
  /** A limit of the number of object to be returned, between 1 and 100. Defaults to 10. */
  limit?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects before this ID. */
  before?: string;
  /** A pagination cursor. This is an object ID that enables you to fetch all objects after this ID. */
  after?: string;
};

export type v1PathFormat = "PATH_FORMAT_BIP32";

export type v1PayloadEncoding =
  | "PAYLOAD_ENCODING_HEXADECIMAL"
  | "PAYLOAD_ENCODING_TEXT_UTF8"
  | "PAYLOAD_ENCODING_EIP712"
  | "PAYLOAD_ENCODING_EIP7702_AUTHORIZATION";

export type v1Policy = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW a particular activity following policy selector(s). */
  effect: v1Effect;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** Human-readable notes added by a User to describe a particular policy. */
  notes: string;
  /** A consensus expression that evalutes to true or false. */
  consensus: string;
  /** A condition expression that evalutes to true or false. */
  condition: string;
};

export type v1PrivateKey = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Derived cryptocurrency addresses for a given Private Key. */
  addresses: externaldatav1Address[];
  /** A list of Private Key Tag IDs. */
  privateKeyTags: string[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Private Key is exported, false otherwise. */
  exported: boolean;
  /** True when a given Private Key is imported, false otherwise. */
  imported: boolean;
};

export type v1PrivateKeyParams = {
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body. */
  privateKeyTags: string[];
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type v1PrivateKeyResult = {
  privateKeyId?: string;
  addresses?: immutableactivityv1Address[];
};

export type v1PublicKeyCredentialWithAttestation = {
  id: string;
  type: string;
  rawId: string;
  authenticatorAttachment?: string;
  response: v1AuthenticatorAttestationResponse;
  clientExtensionResults: v1SimpleClientExtensionResults;
};

export type v1RecoverUserIntent = {
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type v1RecoverUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RecoverUserIntent;
};

export type v1RecoverUserResult = {
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type v1RejectActivityIntent = {
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type v1RejectActivityRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RejectActivityIntent;
};

export type v1RemoveOrganizationFeatureIntent = {
  /** Name of the feature to remove */
  name: v1FeatureName;
};

export type v1RemoveOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1RemoveOrganizationFeatureIntent;
};

export type v1RemoveOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1Result = {
  createOrganizationResult?: v1CreateOrganizationResult;
  createAuthenticatorsResult?: v1CreateAuthenticatorsResult;
  createUsersResult?: v1CreateUsersResult;
  createPrivateKeysResult?: v1CreatePrivateKeysResult;
  createInvitationsResult?: v1CreateInvitationsResult;
  acceptInvitationResult?: v1AcceptInvitationResult;
  signRawPayloadResult?: v1SignRawPayloadResult;
  createPolicyResult?: v1CreatePolicyResult;
  disablePrivateKeyResult?: v1DisablePrivateKeyResult;
  deleteUsersResult?: v1DeleteUsersResult;
  deleteAuthenticatorsResult?: v1DeleteAuthenticatorsResult;
  deleteInvitationResult?: v1DeleteInvitationResult;
  deleteOrganizationResult?: v1DeleteOrganizationResult;
  deletePolicyResult?: v1DeletePolicyResult;
  createUserTagResult?: v1CreateUserTagResult;
  deleteUserTagsResult?: v1DeleteUserTagsResult;
  signTransactionResult?: v1SignTransactionResult;
  deleteApiKeysResult?: v1DeleteApiKeysResult;
  createApiKeysResult?: v1CreateApiKeysResult;
  createPrivateKeyTagResult?: v1CreatePrivateKeyTagResult;
  deletePrivateKeyTagsResult?: v1DeletePrivateKeyTagsResult;
  setPaymentMethodResult?: billingSetPaymentMethodResult;
  activateBillingTierResult?: billingActivateBillingTierResult;
  deletePaymentMethodResult?: billingDeletePaymentMethodResult;
  createApiOnlyUsersResult?: v1CreateApiOnlyUsersResult;
  updateRootQuorumResult?: v1UpdateRootQuorumResult;
  updateUserTagResult?: v1UpdateUserTagResult;
  updatePrivateKeyTagResult?: v1UpdatePrivateKeyTagResult;
  createSubOrganizationResult?: v1CreateSubOrganizationResult;
  updateAllowedOriginsResult?: v1UpdateAllowedOriginsResult;
  createPrivateKeysResultV2?: v1CreatePrivateKeysResultV2;
  updateUserResult?: v1UpdateUserResult;
  updatePolicyResult?: v1UpdatePolicyResult;
  createSubOrganizationResultV3?: v1CreateSubOrganizationResultV3;
  createWalletResult?: v1CreateWalletResult;
  createWalletAccountsResult?: v1CreateWalletAccountsResult;
  initUserEmailRecoveryResult?: v1InitUserEmailRecoveryResult;
  recoverUserResult?: v1RecoverUserResult;
  setOrganizationFeatureResult?: v1SetOrganizationFeatureResult;
  removeOrganizationFeatureResult?: v1RemoveOrganizationFeatureResult;
  exportPrivateKeyResult?: v1ExportPrivateKeyResult;
  exportWalletResult?: v1ExportWalletResult;
  createSubOrganizationResultV4?: v1CreateSubOrganizationResultV4;
  emailAuthResult?: v1EmailAuthResult;
  exportWalletAccountResult?: v1ExportWalletAccountResult;
  initImportWalletResult?: v1InitImportWalletResult;
  importWalletResult?: v1ImportWalletResult;
  initImportPrivateKeyResult?: v1InitImportPrivateKeyResult;
  importPrivateKeyResult?: v1ImportPrivateKeyResult;
  createPoliciesResult?: v1CreatePoliciesResult;
  signRawPayloadsResult?: v1SignRawPayloadsResult;
  createReadOnlySessionResult?: v1CreateReadOnlySessionResult;
  createOauthProvidersResult?: v1CreateOauthProvidersResult;
  deleteOauthProvidersResult?: v1DeleteOauthProvidersResult;
  createSubOrganizationResultV5?: v1CreateSubOrganizationResultV5;
  oauthResult?: v1OauthResult;
  createReadWriteSessionResult?: v1CreateReadWriteSessionResult;
  createSubOrganizationResultV6?: v1CreateSubOrganizationResultV6;
  deletePrivateKeysResult?: v1DeletePrivateKeysResult;
  deleteWalletsResult?: v1DeleteWalletsResult;
  createReadWriteSessionResultV2?: v1CreateReadWriteSessionResultV2;
  deleteSubOrganizationResult?: v1DeleteSubOrganizationResult;
  initOtpAuthResult?: v1InitOtpAuthResult;
  otpAuthResult?: v1OtpAuthResult;
  createSubOrganizationResultV7?: v1CreateSubOrganizationResultV7;
  updateWalletResult?: v1UpdateWalletResult;
  updatePolicyResultV2?: v1UpdatePolicyResultV2;
  initOtpAuthResultV2?: v1InitOtpAuthResultV2;
  initOtpResult?: v1InitOtpResult;
  verifyOtpResult?: v1VerifyOtpResult;
  otpLoginResult?: v1OtpLoginResult;
  stampLoginResult?: v1StampLoginResult;
  oauthLoginResult?: v1OauthLoginResult;
  updateUserNameResult?: v1UpdateUserNameResult;
  updateUserEmailResult?: v1UpdateUserEmailResult;
  updateUserPhoneNumberResult?: v1UpdateUserPhoneNumberResult;
  initFiatOnRampResult?: v1InitFiatOnRampResult;
  createSmartContractInterfaceResult?: v1CreateSmartContractInterfaceResult;
  deleteSmartContractInterfaceResult?: v1DeleteSmartContractInterfaceResult;
  enableAuthProxyResult?: v1EnableAuthProxyResult;
  disableAuthProxyResult?: v1DisableAuthProxyResult;
  updateAuthProxyConfigResult?: v1UpdateAuthProxyConfigResult;
  createOauth2CredentialResult?: v1CreateOauth2CredentialResult;
  updateOauth2CredentialResult?: v1UpdateOauth2CredentialResult;
  deleteOauth2CredentialResult?: v1DeleteOauth2CredentialResult;
  oauth2AuthenticateResult?: v1Oauth2AuthenticateResult;
};

export type v1RootUserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
};

export type v1RootUserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1RootUserParamsV4 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
};

export type v1Selector = {
  subject?: string;
  operator?: v1Operator;
  target?: string;
};

export type v1SelectorV2 = {
  subject?: string;
  operator?: v1Operator;
  targets?: string[];
};

export type v1SetOrganizationFeatureIntent = {
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type v1SetOrganizationFeatureRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SetOrganizationFeatureIntent;
};

export type v1SetOrganizationFeatureResult = {
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type v1SignRawPayloadIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadIntentV2;
};

export type v1SignRawPayloadResult = {
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type v1SignRawPayloadsIntent = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type v1SignRawPayloadsRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignRawPayloadsIntent;
};

export type v1SignRawPayloadsResult = {
  signatures?: v1SignRawPayloadResult[];
};

export type v1SignTransactionIntent = {
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Raw unsigned transaction to be signed by a particular Private Key. */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionIntentV2 = {
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type v1SignTransactionRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1SignTransactionIntentV2;
};

export type v1SignTransactionResult = {
  signedTransaction: string;
};

export type v1SignatureScheme = "SIGNATURE_SCHEME_EPHEMERAL_KEY_P256";

export type v1SimpleClientExtensionResults = {
  appid?: boolean;
  appidExclude?: boolean;
  credProps?: v1CredPropsAuthenticationExtensionsClientOutputs;
};

export type v1SmartContractInterface = {
  /** The Organization the Smart Contract Interface belongs to. */
  organizationId: string;
  /** Unique identifier for a given Smart Contract Interface (ABI or IDL). */
  smartContractInterfaceId: string;
  /** The address corresponding to the Smart Contract or Program. */
  smartContractAddress: string;
  /** The JSON corresponding to the Smart Contract Interface (ABI or IDL). */
  smartContractInterface: string;
  /** The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  type: string;
  /** The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  label: string;
  /** The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA). */
  notes: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1SmartContractInterfaceReference = {
  smartContractInterfaceId?: string;
  smartContractAddress?: string;
  digest?: string;
};

export type v1SmartContractInterfaceType =
  | "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM"
  | "SMART_CONTRACT_INTERFACE_TYPE_SOLANA";

export type v1SmsCustomizationParams = {
  /** Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}} */
  template?: string;
};

export type v1StampLoginIntent = {
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type v1StampLoginRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1StampLoginIntent;
};

export type v1StampLoginResult = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type v1TagType = "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";

export type v1TestRateLimitsRequest = {
  /** Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons. */
  organizationId: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true. */
  limit: number;
};

export type v1TestRateLimitsResponse = {};
export type v1TransactionType =
  | "TRANSACTION_TYPE_ETHEREUM"
  | "TRANSACTION_TYPE_SOLANA"
  | "TRANSACTION_TYPE_TRON";

export type v1UpdateAllowedOriginsIntent = {
  /** Additional origins requests are allowed from besides Turnkey origins */
  allowedOrigins: string[];
};

export type v1UpdateAllowedOriginsResult = {};
export type v1UpdateAuthProxyConfigIntent = {
  /** Updated list of allowed origins for CORS. */
  allowedOrigins?: string[];
  /** Updated list of allowed proxy authentication methods. */
  allowedAuthMethods?: string[];
  /** Custom 'from' address for auth-related emails. */
  sendFromEmailAddress?: string;
  /** Custom reply-to address for auth-related emails. */
  replyToEmailAddress?: string;
  /** Template ID for email-auth messages. */
  emailAuthTemplateId?: string;
  /** Template ID for OTP SMS messages. */
  otpTemplateId?: string;
  /** Overrides for auth-related email content. */
  emailCustomizationParams?: v1EmailCustomizationParams;
  /** Overrides for auth-related SMS content. */
  smsCustomizationParams?: v1SmsCustomizationParams;
  /** Overrides for react wallet kit related settings. */
  walletKitSettings?: v1WalletKitSettingsParams;
  /** OTP code lifetime in seconds. */
  otpExpirationSeconds?: number;
  /** Verification-token lifetime in seconds. */
  verificationTokenExpirationSeconds?: number;
  /** Session lifetime in seconds. */
  sessionExpirationSeconds?: number;
  /** Enable alphanumeric OTP codes. */
  otpAlphanumeric?: boolean;
  /** Desired OTP code length (6–9). */
  otpLength?: number;
};

export type v1UpdateAuthProxyConfigResult = {
  /** Unique identifier for a given User. (representing the turnkey signer user id) */
  configId?: string;
};

export type v1UpdateOauth2CredentialIntent = {
  /** The ID of the OAuth 2.0 credential to update */
  oauth2CredentialId: string;
  /** The OAuth 2.0 provider */
  provider: v1Oauth2Provider;
  /** The Client ID issued by the OAuth 2.0 provider */
  clientId: string;
  /** The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key */
  encryptedClientSecret: string;
};

export type v1UpdateOauth2CredentialRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateOauth2CredentialIntent;
};

export type v1UpdateOauth2CredentialResult = {
  /** Unique identifier of the OAuth 2.0 credential that was updated */
  oauth2CredentialId: string;
};

export type v1UpdatePolicyIntent = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyIntentV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type v1UpdatePolicyRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePolicyIntentV2;
};

export type v1UpdatePolicyResult = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePolicyResultV2 = {
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type v1UpdatePrivateKeyTagIntent = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type v1UpdatePrivateKeyTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdatePrivateKeyTagIntent;
};

export type v1UpdatePrivateKeyTagResult = {
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type v1UpdateRootQuorumIntent = {
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type v1UpdateRootQuorumRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateRootQuorumIntent;
};

export type v1UpdateRootQuorumResult = {};
export type v1UpdateUserEmailIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's email address. Setting this to an empty string will remove the user's email. */
  userEmail: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1UpdateUserEmailRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserEmailIntent;
};

export type v1UpdateUserEmailResult = {
  /** Unique identifier of the User whose email was updated. */
  userId: string;
};

export type v1UpdateUserIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type v1UpdateUserNameIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
};

export type v1UpdateUserNameRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserNameIntent;
};

export type v1UpdateUserNameResult = {
  /** Unique identifier of the User whose name was updated. */
  userId: string;
};

export type v1UpdateUserPhoneNumberIntent = {
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number. */
  userPhoneNumber: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type v1UpdateUserPhoneNumberRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserPhoneNumberIntent;
};

export type v1UpdateUserPhoneNumberResult = {
  /** Unique identifier of the User whose phone number was updated. */
  userId: string;
};

export type v1UpdateUserRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserIntent;
};

export type v1UpdateUserResult = {
  /** A User ID. */
  userId: string;
};

export type v1UpdateUserTagIntent = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type v1UpdateUserTagRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateUserTagIntent;
};

export type v1UpdateUserTagResult = {
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type v1UpdateWalletIntent = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type v1UpdateWalletRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1UpdateWalletIntent;
};

export type v1UpdateWalletResult = {
  /** A Wallet ID. */
  walletId: string;
};

export type v1User = {
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of Authenticator parameters. */
  authenticators: v1Authenticator[];
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKey[];
  /** A list of User Tag IDs. */
  userTags: string[];
  /** A list of Oauth Providers. */
  oauthProviders: v1OauthProvider[];
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
};

export type v1UserParams = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The User's permissible access method(s). */
  accessType: v1AccessType;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV2 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: apiApiKeyParams[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1UserParamsV3 = {
  /** Human-readable name for a User. */
  userName: string;
  /** The user's email address. */
  userEmail?: string;
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
  /** A list of User Tag IDs. This field, if not needed, should be an empty array in your request body. */
  userTags: string[];
};

export type v1VerifyOtpIntent = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
  /** Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature */
  publicKey?: string;
};

export type v1VerifyOtpRequest = {
  type: string;
  /** Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
  timestampMs: string;
  /** Unique identifier for a given Organization. */
  organizationId: string;
  parameters: v1VerifyOtpIntent;
};

export type v1VerifyOtpResult = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type v1Vote = {
  /** Unique identifier for a given Vote object. */
  id: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Web and/or API user within your Organization. */
  user: v1User;
  /** Unique identifier for a given Activity object. */
  activityId: string;
  selection: string;
  /** The raw message being signed within a Vote. */
  message: string;
  /** The public component of a cryptographic key pair used to sign messages and transactions. */
  publicKey: string;
  /** The signature applied to a particular vote. */
  signature: string;
  /** Method used to produce a signature. */
  scheme: string;
  createdAt: externaldatav1Timestamp;
};

export type v1Wallet = {
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** True when a given Wallet is exported, false otherwise. */
  exported: boolean;
  /** True when a given Wallet is imported, false otherwise. */
  imported: boolean;
};

export type v1WalletAccount = {
  /** Unique identifier for a given Wallet Account. */
  walletAccountId: string;
  /** The Organization the Account belongs to. */
  organizationId: string;
  /** The Wallet the Account was derived from. */
  walletId: string;
  /** Cryptographic curve used to generate the Account. */
  curve: v1Curve;
  /** Path format used to generate the Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate the Account. */
  path: string;
  /** Address format used to generate the Account. */
  addressFormat: v1AddressFormat;
  /** Address generated using the Wallet seed and Account parameters. */
  address: string;
  createdAt: externaldatav1Timestamp;
  updatedAt: externaldatav1Timestamp;
  /** The public component of this wallet account's underlying cryptographic key pair. */
  publicKey?: string;
  /** Wallet details for this account. This is only present when include_wallet_details=true. */
  walletDetails?: v1Wallet;
};

export type v1WalletAccountParams = {
  /** Cryptographic curve used to generate a wallet Account. */
  curve: v1Curve;
  /** Path format used to generate a wallet Account. */
  pathFormat: v1PathFormat;
  /** Path used to generate a wallet Account. */
  path: string;
  /** Address format used to generate a wallet Acccount. */
  addressFormat: v1AddressFormat;
};

export type v1WalletKitSettingsParams = {
  /** List of enabled social login providers (e.g., 'apple', 'google', 'facebook') */
  enabledSocialProviders?: string[];
  /** Mapping of social login providers to their Oauth client IDs. */
  oauthClientIds?: Record<string, any>;
  /** Oauth redirect URL to be used for social login flows. */
  oauthRedirectUrl?: string;
};

export type v1WalletParams = {
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type v1WalletResult = {
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type v1WebAuthnStamp = {
  /** A base64 url encoded Unique identifier for a given credential. */
  credentialId: string;
  /** A base64 encoded payload containing metadata about the signing context and the challenge. */
  clientDataJson: string;
  /** A base64 encoded payload containing metadata about the authenticator. */
  authenticatorData: string;
  /** The base64 url encoded signature bytes contained within the WebAuthn assertion response. */
  signature: string;
};

// --- API Types from Swagger Paths ---
export type TGetActivityResponse = {
  /** An action that can be taken within the Turnkey infrastructure. */
  activity: v1Activity;
};

export type TGetActivityBody = {
  organizationId?: string;
  /** Unique identifier for a given activity object. */
  activityId: string;
};

export type TGetActivityInput = { body: TGetActivityBody };

export type TGetApiKeyResponse = {
  /** An API key. */
  apiKey: v1ApiKey;
};

export type TGetApiKeyBody = {
  organizationId?: string;
  /** Unique identifier for a given API key. */
  apiKeyId: string;
};

export type TGetApiKeyInput = { body: TGetApiKeyBody };

export type TGetApiKeysResponse = {
  /** A list of API keys. */
  apiKeys: v1ApiKey[];
};

export type TGetApiKeysBody = {
  organizationId?: string;
  /** Unique identifier for a given user. */
  userId?: string;
};

export type TGetApiKeysInput = { body: TGetApiKeysBody };

export type TGetAttestationDocumentResponse = {
  /** Raw (CBOR-encoded) attestation document. */
  attestationDocument: string;
};

export type TGetAttestationDocumentBody = {
  organizationId?: string;
  /** The enclave type, one of: ump, notarizer, signer, evm-parser. */
  enclaveType: string;
};

export type TGetAttestationDocumentInput = {
  body: TGetAttestationDocumentBody;
};

export type TGetAuthenticatorResponse = {
  /** An authenticator. */
  authenticator: v1Authenticator;
};

export type TGetAuthenticatorBody = {
  organizationId?: string;
  /** Unique identifier for a given authenticator. */
  authenticatorId: string;
};

export type TGetAuthenticatorInput = { body: TGetAuthenticatorBody };

export type TGetAuthenticatorsResponse = {
  /** A list of authenticators. */
  authenticators: v1Authenticator[];
};

export type TGetAuthenticatorsBody = {
  organizationId?: string;
  /** Unique identifier for a given user. */
  userId: string;
};

export type TGetAuthenticatorsInput = { body: TGetAuthenticatorsBody };

export type TGetBootProofResponse = {
  bootProof: v1BootProof;
};

export type TGetBootProofBody = {
  organizationId?: string;
  /** Hex encoded ephemeral public key. */
  ephemeralKey: string;
};

export type TGetBootProofInput = { body: TGetBootProofBody };

export type TGetLatestBootProofResponse = {
  bootProof: v1BootProof;
};

export type TGetLatestBootProofBody = {
  organizationId?: string;
  /** Name of enclave app. */
  appName: string;
};

export type TGetLatestBootProofInput = { body: TGetLatestBootProofBody };

export type TGetOauth2CredentialResponse = {
  oauth2Credential: v1Oauth2Credential;
};

export type TGetOauth2CredentialBody = {
  organizationId?: string;
  /** Unique identifier for a given OAuth 2.0 Credential. */
  oauth2CredentialId: string;
};

export type TGetOauth2CredentialInput = { body: TGetOauth2CredentialBody };

export type TGetOauthProvidersResponse = {
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProvider[];
};

export type TGetOauthProvidersBody = {
  organizationId?: string;
  /** Unique identifier for a given user. */
  userId?: string;
};

export type TGetOauthProvidersInput = { body: TGetOauthProvidersBody };

export type TGetOrganizationResponse = {
  /** Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization. */
  organizationData: v1OrganizationData;
};

export type TGetOrganizationBody = {
  organizationId?: string;
};

export type TGetOrganizationInput = { body: TGetOrganizationBody };

export type TGetOrganizationConfigsResponse = {
  /** Organization configs including quorum settings and organization features. */
  configs: v1Config;
};

export type TGetOrganizationConfigsBody = {
  organizationId?: string;
};

export type TGetOrganizationConfigsInput = {
  body: TGetOrganizationConfigsBody;
};

export type TGetPolicyResponse = {
  /** Object that codifies rules defining the actions that are permissible within an organization. */
  policy: v1Policy;
};

export type TGetPolicyBody = {
  organizationId?: string;
  /** Unique identifier for a given policy. */
  policyId: string;
};

export type TGetPolicyInput = { body: TGetPolicyBody };

export type TGetPolicyEvaluationsResponse = {
  policyEvaluations: externalactivityv1PolicyEvaluation[];
};

export type TGetPolicyEvaluationsBody = {
  organizationId?: string;
  /** Unique identifier for a given activity. */
  activityId: string;
};

export type TGetPolicyEvaluationsInput = { body: TGetPolicyEvaluationsBody };

export type TGetPrivateKeyResponse = {
  /** Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption. */
  privateKey: v1PrivateKey;
};

export type TGetPrivateKeyBody = {
  organizationId?: string;
  /** Unique identifier for a given private key. */
  privateKeyId: string;
};

export type TGetPrivateKeyInput = { body: TGetPrivateKeyBody };

export type TGetSmartContractInterfaceResponse = {
  /** Object to be used in conjunction with policies to guard transaction signing. */
  smartContractInterface: v1SmartContractInterface;
};

export type TGetSmartContractInterfaceBody = {
  organizationId?: string;
  /** Unique identifier for a given smart contract interface. */
  smartContractInterfaceId: string;
};

export type TGetSmartContractInterfaceInput = {
  body: TGetSmartContractInterfaceBody;
};

export type TGetUserResponse = {
  /** Web and/or API user within your organization. */
  user: v1User;
};

export type TGetUserBody = {
  organizationId?: string;
  /** Unique identifier for a given user. */
  userId: string;
};

export type TGetUserInput = { body: TGetUserBody };

export type TGetWalletResponse = {
  /** A collection of deterministically generated cryptographic public / private key pairs that share a common seed. */
  wallet: v1Wallet;
};

export type TGetWalletBody = {
  organizationId?: string;
  /** Unique identifier for a given wallet. */
  walletId: string;
};

export type TGetWalletInput = { body: TGetWalletBody };

export type TGetWalletAccountResponse = {
  /** The resulting wallet account. */
  account: v1WalletAccount;
};

export type TGetWalletAccountBody = {
  organizationId?: string;
  /** Unique identifier for a given wallet. */
  walletId: string;
  /** Address corresponding to a wallet account. */
  address?: string;
  /** Path corresponding to a wallet account. */
  path?: string;
};

export type TGetWalletAccountInput = { body: TGetWalletAccountBody };

export type TGetActivitiesResponse = {
  /** A list of activities. */
  activities: v1Activity[];
};

export type TGetActivitiesBody = {
  organizationId?: string;
  /** Array of activity statuses filtering which activities will be listed in the response. */
  filterByStatus?: v1ActivityStatus[];
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
  /** Array of activity types filtering which activities will be listed in the response. */
  filterByType?: v1ActivityType[];
};

export type TGetActivitiesInput = { body: TGetActivitiesBody };

export type TGetAppProofsResponse = {
  appProofs: v1AppProof[];
};

export type TGetAppProofsBody = {
  organizationId?: string;
  /** Unique identifier for a given activity. */
  activityId: string;
};

export type TGetAppProofsInput = { body: TGetAppProofsBody };

export type TListOauth2CredentialsResponse = {
  oauth2Credentials: v1Oauth2Credential[];
};

export type TListOauth2CredentialsBody = {
  organizationId?: string;
};

export type TListOauth2CredentialsInput = { body: TListOauth2CredentialsBody };

export type TGetPoliciesResponse = {
  /** A list of policies. */
  policies: v1Policy[];
};

export type TGetPoliciesBody = {
  organizationId?: string;
};

export type TGetPoliciesInput = { body: TGetPoliciesBody };

export type TListPrivateKeyTagsResponse = {
  /** A list of private key tags. */
  privateKeyTags: datav1Tag[];
};

export type TListPrivateKeyTagsBody = {
  organizationId?: string;
};

export type TListPrivateKeyTagsInput = { body: TListPrivateKeyTagsBody };

export type TGetPrivateKeysResponse = {
  /** A list of private keys. */
  privateKeys: v1PrivateKey[];
};

export type TGetPrivateKeysBody = {
  organizationId?: string;
};

export type TGetPrivateKeysInput = { body: TGetPrivateKeysBody };

export type TGetSmartContractInterfacesResponse = {
  /** A list of smart contract interfaces. */
  smartContractInterfaces: v1SmartContractInterface[];
};

export type TGetSmartContractInterfacesBody = {
  organizationId?: string;
};

export type TGetSmartContractInterfacesInput = {
  body: TGetSmartContractInterfacesBody;
};

export type TGetSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type TGetSubOrgIdsBody = {
  organizationId?: string;
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY' */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetSubOrgIdsInput = { body: TGetSubOrgIdsBody };

export type TListUserTagsResponse = {
  /** A list of user tags. */
  userTags: datav1Tag[];
};

export type TListUserTagsBody = {
  organizationId?: string;
};

export type TListUserTagsInput = { body: TListUserTagsBody };

export type TGetUsersResponse = {
  /** A list of users. */
  users: v1User[];
};

export type TGetUsersBody = {
  organizationId?: string;
};

export type TGetUsersInput = { body: TGetUsersBody };

export type TGetVerifiedSubOrgIdsResponse = {
  /** List of unique identifiers for the matching sub-organizations. */
  organizationIds: string[];
};

export type TGetVerifiedSubOrgIdsBody = {
  organizationId?: string;
  /** Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'. */
  filterType?: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or phone number string. */
  filterValue?: string;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetVerifiedSubOrgIdsInput = { body: TGetVerifiedSubOrgIdsBody };

export type TGetWalletAccountsResponse = {
  /** A list of accounts generated from a wallet that share a common seed. */
  accounts: v1WalletAccount[];
};

export type TGetWalletAccountsBody = {
  organizationId?: string;
  /** Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned. */
  walletId?: string;
  /** Optional flag to specify if the wallet details should be included in the response. Default = false. */
  includeWalletDetails?: boolean;
  /** Parameters used for cursor-based pagination. */
  paginationOptions?: v1Pagination;
};

export type TGetWalletAccountsInput = { body: TGetWalletAccountsBody };

export type TGetWalletsResponse = {
  /** A list of wallets. */
  wallets: v1Wallet[];
};

export type TGetWalletsBody = {
  organizationId?: string;
};

export type TGetWalletsInput = { body: TGetWalletsBody };

export type TGetWhoamiResponse = {
  /** Unique identifier for a given organization. */
  organizationId: string;
  /** Human-readable name for an organization. */
  organizationName: string;
  /** Unique identifier for a given user. */
  userId: string;
  /** Human-readable name for a user. */
  username: string;
};

export type TGetWhoamiBody = {
  organizationId?: string;
};

export type TGetWhoamiInput = { body: TGetWhoamiBody };

export type TApproveActivityResponse = {
  activity: v1Activity;
};

export type TApproveActivityBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type TApproveActivityInput = { body: TApproveActivityBody };

export type TCreateApiKeysResponse = {
  activity: v1Activity;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TCreateApiKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of API Keys. */
  apiKeys: v1ApiKeyParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type TCreateApiKeysInput = { body: TCreateApiKeysBody };

export type TCreateApiOnlyUsersResponse = {
  activity: v1Activity;
  /** A list of API-only User IDs. */
  userIds: string[];
};

export type TCreateApiOnlyUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of API-only Users to create. */
  apiOnlyUsers: v1ApiOnlyUserParams[];
};

export type TCreateApiOnlyUsersInput = { body: TCreateApiOnlyUsersBody };

export type TCreateAuthenticatorsResponse = {
  activity: v1Activity;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type TCreateAuthenticatorsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Authenticators. */
  authenticators: v1AuthenticatorParamsV2[];
  /** Unique identifier for a given User. */
  userId: string;
};

export type TCreateAuthenticatorsInput = { body: TCreateAuthenticatorsBody };

export type TCreateInvitationsResponse = {
  activity: v1Activity;
  /** A list of Invitation IDs */
  invitationIds: string[];
};

export type TCreateInvitationsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Invitations. */
  invitations: v1InvitationParams[];
};

export type TCreateInvitationsInput = { body: TCreateInvitationsBody };

export type TCreateOauth2CredentialResponse = {
  activity: v1Activity;
  /** Unique identifier of the OAuth 2.0 credential that was created */
  oauth2CredentialId: string;
};

export type TCreateOauth2CredentialBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The OAuth 2.0 provider */
  provider: v1Oauth2Provider;
  /** The Client ID issued by the OAuth 2.0 provider */
  clientId: string;
  /** The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key */
  encryptedClientSecret: string;
};

export type TCreateOauth2CredentialInput = {
  body: TCreateOauth2CredentialBody;
};

export type TCreateOauthProvidersResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type TCreateOauthProvidersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User to add an Oauth provider to */
  userId: string;
  /** A list of Oauth providers. */
  oauthProviders: v1OauthProviderParams[];
};

export type TCreateOauthProvidersInput = { body: TCreateOauthProvidersBody };

export type TCreatePoliciesResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for the created policies. */
  policyIds: string[];
};

export type TCreatePoliciesBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An array of policy intents to be created. */
  policies: v1CreatePolicyIntentV3[];
};

export type TCreatePoliciesInput = { body: TCreatePoliciesBody };

export type TCreatePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TCreatePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Policy. */
  policyName: string;
  /** The instruction to DENY or ALLOW an activity. */
  effect: v1Effect;
  /** The condition expression that triggers the Effect */
  condition?: string;
  /** The consensus expression that triggers the Effect */
  consensus?: string;
  notes?: string;
};

export type TCreatePolicyInput = { body: TCreatePolicyBody };

export type TCreatePrivateKeyTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TCreatePrivateKeyTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Private Key Tag. */
  privateKeyTagName: string;
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TCreatePrivateKeyTagInput = { body: TCreatePrivateKeyTagBody };

export type TCreatePrivateKeysResponse = {
  activity: v1Activity;
  /** A list of Private Key IDs and addresses. */
  privateKeys: v1PrivateKeyResult[];
};

export type TCreatePrivateKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Private Keys. */
  privateKeys: v1PrivateKeyParams[];
};

export type TCreatePrivateKeysInput = { body: TCreatePrivateKeysBody };

export type TCreateReadOnlySessionResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** String representing a read only session */
  session: string;
  /** UTC timestamp in seconds representing the expiry time for the read only session. */
  sessionExpiry: string;
};

export type TCreateReadOnlySessionBody = {
  timestampMs?: string;
  organizationId?: string;
};

export type TCreateReadOnlySessionInput = { body: TCreateReadOnlySessionBody };

export type TCreateReadWriteSessionResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons. */
  organizationId: string;
  /** Human-readable name for an Organization. */
  organizationName: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  username: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type TCreateReadWriteSessionBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Unique identifier for a given User. */
  userId?: string;
  /** Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated ReadWriteSession API keys */
  invalidateExisting?: boolean;
};

export type TCreateReadWriteSessionInput = {
  body: TCreateReadWriteSessionBody;
};

export type TCreateSmartContractInterfaceResponse = {
  activity: v1Activity;
  /** The ID of the created Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type TCreateSmartContractInterfaceBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Corresponding contract address or program ID */
  smartContractAddress: string;
  /** ABI/IDL as a JSON string */
  smartContractInterface: string;
  type: v1SmartContractInterfaceType;
  /** Human-readable name for a Smart Contract Interface. */
  label: string;
  /** Notes for a Smart Contract Interface. */
  notes?: string;
};

export type TCreateSmartContractInterfaceInput = {
  body: TCreateSmartContractInterfaceBody;
};

export type TCreateSubOrganizationResponse = {
  activity: v1Activity;
  subOrganizationId: string;
  wallet?: v1WalletResult;
  rootUserIds?: string[];
};

export type TCreateSubOrganizationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name for this sub-organization */
  subOrganizationName: string;
  /** Root users to create within this sub-organization */
  rootUsers: v1RootUserParamsV4[];
  /** The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users */
  rootQuorumThreshold: number;
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
  /** Disable email recovery for the sub-organization */
  disableEmailRecovery?: boolean;
  /** Disable email auth for the sub-organization */
  disableEmailAuth?: boolean;
  /** Disable OTP SMS auth for the sub-organization */
  disableSmsAuth?: boolean;
  /** Disable OTP email auth for the sub-organization */
  disableOtpEmailAuth?: boolean;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TCreateSubOrganizationInput = { body: TCreateSubOrganizationBody };

export type TCreateUserTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUserTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a User Tag. */
  userTagName: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUserTagInput = { body: TCreateUserTagBody };

export type TCreateUsersResponse = {
  activity: v1Activity;
  /** A list of User IDs. */
  userIds: string[];
};

export type TCreateUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Users. */
  users: v1UserParamsV3[];
};

export type TCreateUsersInput = { body: TCreateUsersBody };

export type TCreateWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type TCreateWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** A list of wallet Accounts. This field, if not needed, should be an empty array in your request body. */
  accounts: v1WalletAccountParams[];
  /** Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24. */
  mnemonicLength?: number;
};

export type TCreateWalletInput = { body: TCreateWalletBody };

export type TCreateWalletAccountsResponse = {
  activity: v1Activity;
  /** A list of derived addresses. */
  addresses: string[];
};

export type TCreateWalletAccountsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type TCreateWalletAccountsInput = { body: TCreateWalletAccountsBody };

export type TDeleteApiKeysResponse = {
  activity: v1Activity;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TDeleteApiKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of API Key IDs. */
  apiKeyIds: string[];
};

export type TDeleteApiKeysInput = { body: TDeleteApiKeysBody };

export type TDeleteAuthenticatorsResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Authenticator. */
  authenticatorIds: string[];
};

export type TDeleteAuthenticatorsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** A list of Authenticator IDs. */
  authenticatorIds: string[];
};

export type TDeleteAuthenticatorsInput = { body: TDeleteAuthenticatorsBody };

export type TDeleteInvitationResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Invitation. */
  invitationId: string;
};

export type TDeleteInvitationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Invitation object. */
  invitationId: string;
};

export type TDeleteInvitationInput = { body: TDeleteInvitationBody };

export type TDeleteOauth2CredentialResponse = {
  activity: v1Activity;
  /** Unique identifier of the OAuth 2.0 credential that was deleted */
  oauth2CredentialId: string;
};

export type TDeleteOauth2CredentialBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the OAuth 2.0 credential to delete */
  oauth2CredentialId: string;
};

export type TDeleteOauth2CredentialInput = {
  body: TDeleteOauth2CredentialBody;
};

export type TDeleteOauthProvidersResponse = {
  activity: v1Activity;
  /** A list of unique identifiers for Oauth Providers */
  providerIds: string[];
};

export type TDeleteOauthProvidersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User to remove an Oauth provider from */
  userId: string;
  /** Unique identifier for a given Provider. */
  providerIds: string[];
};

export type TDeleteOauthProvidersInput = { body: TDeleteOauthProvidersBody };

export type TDeletePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TDeletePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TDeletePolicyInput = { body: TDeletePolicyBody };

export type TDeletePrivateKeyTagsResponse = {
  activity: v1Activity;
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
  /** A list of Private Key IDs. */
  privateKeyIds: string[];
};

export type TDeletePrivateKeyTagsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of Private Key Tag IDs. */
  privateKeyTagIds: string[];
};

export type TDeletePrivateKeyTagsInput = { body: TDeletePrivateKeyTagsBody };

export type TDeletePrivateKeysResponse = {
  activity: v1Activity;
  /** A list of private key unique identifiers that were removed */
  privateKeyIds: string[];
};

export type TDeletePrivateKeysBody = {
  timestampMs?: string;
  organizationId?: string;
  /** List of unique identifiers for private keys within an organization */
  privateKeyIds: string[];
  /** Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type TDeletePrivateKeysInput = { body: TDeletePrivateKeysBody };

export type TDeleteSmartContractInterfaceResponse = {
  activity: v1Activity;
  /** The ID of the deleted Smart Contract Interface. */
  smartContractInterfaceId: string;
};

export type TDeleteSmartContractInterfaceBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of a Smart Contract Interface intended for deletion. */
  smartContractInterfaceId: string;
};

export type TDeleteSmartContractInterfaceInput = {
  body: TDeleteSmartContractInterfaceBody;
};

export type TDeleteSubOrganizationResponse = {
  activity: v1Activity;
  /** Unique identifier of the sub organization that was removed */
  subOrganizationUuid: string;
};

export type TDeleteSubOrganizationBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false. */
  deleteWithoutExport?: boolean;
};

export type TDeleteSubOrganizationInput = { body: TDeleteSubOrganizationBody };

export type TDeleteUserTagsResponse = {
  activity: v1Activity;
  /** A list of User Tag IDs. */
  userTagIds: string[];
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUserTagsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of User Tag IDs. */
  userTagIds: string[];
};

export type TDeleteUserTagsInput = { body: TDeleteUserTagsBody };

export type TDeleteUsersResponse = {
  activity: v1Activity;
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUsersBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A list of User IDs. */
  userIds: string[];
};

export type TDeleteUsersInput = { body: TDeleteUsersBody };

export type TDeleteWalletsResponse = {
  activity: v1Activity;
  /** A list of wallet unique identifiers that were removed */
  walletIds: string[];
};

export type TDeleteWalletsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** List of unique identifiers for wallets within an organization */
  walletIds: string[];
  /** Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored. */
  deleteWithoutExport?: boolean;
};

export type TDeleteWalletsInput = { body: TDeleteWalletsBody };

export type TEmailAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
};

export type TEmailAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Email of the authenticating user. */
  email: string;
  /** Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Invalidate all other previously generated Email Auth API keys */
  invalidateExisting?: boolean;
  /** Optional custom email address from which to send the email */
  sendFromEmailAddress?: string;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TEmailAuthInput = { body: TEmailAuthBody };

export type TExportPrivateKeyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Export bundle containing a private key encrypted to the client's target public key. */
  exportBundle: string;
};

export type TExportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Private Key. */
  privateKeyId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type TExportPrivateKeyInput = { body: TExportPrivateKeyBody };

export type TExportWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key. */
  exportBundle: string;
};

export type TExportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
  /** The language of the mnemonic to export. Defaults to English. */
  language?: v1MnemonicLanguage;
};

export type TExportWalletInput = { body: TExportWalletBody };

export type TExportWalletAccountResponse = {
  activity: v1Activity;
  /** Address to identify Wallet Account. */
  address: string;
  /** Export bundle containing a private key encrypted by the client's target public key. */
  exportBundle: string;
};

export type TExportWalletAccountBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Address to identify Wallet Account. */
  address: string;
  /** Client-side public key generated by the user, to which the export bundle will be encrypted. */
  targetPublicKey: string;
};

export type TExportWalletAccountInput = { body: TExportWalletAccountBody };

export type TImportPrivateKeyResponse = {
  activity: v1Activity;
  /** Unique identifier for a Private Key. */
  privateKeyId: string;
  /** A list of addresses. */
  addresses: immutableactivityv1Address[];
};

export type TImportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Private Key. */
  userId: string;
  /** Human-readable name for a Private Key. */
  privateKeyName: string;
  /** Bundle containing a raw private key encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** Cryptographic Curve used to generate a given Private Key. */
  curve: v1Curve;
  /** Cryptocurrency-specific formats for a derived address (e.g., Ethereum). */
  addressFormats: v1AddressFormat[];
};

export type TImportPrivateKeyInput = { body: TImportPrivateKeyBody };

export type TImportWalletResponse = {
  activity: v1Activity;
  /** Unique identifier for a Wallet. */
  walletId: string;
  /** A list of account addresses. */
  addresses: string[];
};

export type TImportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Wallet. */
  userId: string;
  /** Human-readable name for a Wallet. */
  walletName: string;
  /** Bundle containing a wallet mnemonic encrypted to the enclave's target public key. */
  encryptedBundle: string;
  /** A list of wallet Accounts. */
  accounts: v1WalletAccountParams[];
};

export type TImportWalletInput = { body: TImportWalletBody };

export type TInitFiatOnRampResponse = {
  activity: v1Activity;
  /** Unique URL for a given fiat on-ramp flow. */
  onRampUrl: string;
  /** Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow. */
  onRampTransactionId: string;
  /** Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project. */
  onRampUrlSignature?: string;
};

export type TInitFiatOnRampBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Enum to specifiy which on-ramp provider to use */
  onrampProvider: v1FiatOnRampProvider;
  /** Destination wallet address for the buy transaction. */
  walletAddress: string;
  /** Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork. */
  network: v1FiatOnRampBlockchainNetwork;
  /** Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset. */
  cryptoCurrencyCode: v1FiatOnRampCryptoCurrency;
  /** Code for the fiat currency to be used in the transaction, e.g., USD, EUR. */
  fiatCurrencyCode?: v1FiatOnRampCurrency;
  /** Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount. */
  fiatCurrencyAmount?: string;
  /** Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider. */
  paymentMethod?: v1FiatOnRampPaymentMethod;
  /** ISO 3166-1 two-digit country code for Coinbase representing the purchasing user’s country of residence, e.g., US, GB. */
  countryCode?: string;
  /** ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing user’s subdivision of residence within their country, e.g. NY. Required if country_code=US. */
  countrySubdivisionCode?: string;
  /** Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false. */
  sandboxMode?: boolean;
  /** Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled. */
  urlForSignature?: string;
};

export type TInitFiatOnRampInput = { body: TInitFiatOnRampBody };

export type TInitImportPrivateKeyResponse = {
  activity: v1Activity;
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type TInitImportPrivateKeyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Private Key. */
  userId: string;
};

export type TInitImportPrivateKeyInput = { body: TInitImportPrivateKeyBody };

export type TInitImportWalletResponse = {
  activity: v1Activity;
  /** Import bundle containing a public key and signature to use for importing client data. */
  importBundle: string;
};

export type TInitImportWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the User importing a Wallet. */
  userId: string;
};

export type TInitImportWalletInput = { body: TInitImportWalletBody };

export type TInitOtpResponse = {
  activity: v1Activity;
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type TInitOtpBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes) */
  expirationSeconds?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TInitOtpInput = { body: TInitOtpBody };

export type TInitOtpAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type TInitOtpAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
  /** Optional length of the OTP code. Default = 9 */
  otpLength?: number;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
  /** Optional parameters for customizing SMS message. If not provided, the default sms message will be used. */
  smsCustomization?: v1SmsCustomizationParams;
  /** Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address. */
  userIdentifier?: string;
  /** Optional custom email address from which to send the OTP email */
  sendFromEmailAddress?: string;
  /** Optional flag to specify if the OTP code should be alphanumeric (Crockford’s Base32). Default = true */
  alphanumeric?: boolean;
  /** Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications' */
  sendFromEmailSenderName?: string;
  /** Optional custom email address to use as reply-to */
  replyToEmailAddress?: string;
};

export type TInitOtpAuthInput = { body: TInitOtpAuthBody };

export type TInitUserEmailRecoveryResponse = {
  activity: v1Activity;
  /** Unique identifier for the user being recovered. */
  userId: string;
};

export type TInitUserEmailRecoveryBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Email of the user starting recovery */
  email: string;
  /** Client-side public key generated by the user, to which the recovery bundle will be encrypted. */
  targetPublicKey: string;
  /** Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Optional parameters for customizing emails. If not provided, the default email will be used. */
  emailCustomization?: v1EmailCustomizationParams;
};

export type TInitUserEmailRecoveryInput = { body: TInitUserEmailRecoveryBody };

export type TOauthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId: string;
  /** HPKE encrypted credential bundle */
  credentialBundle: string;
};

export type TOauthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Oauth API keys */
  invalidateExisting?: boolean;
};

export type TOauthInput = { body: TOauthBody };

export type TOauth2AuthenticateResponse = {
  activity: v1Activity;
  /** Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity */
  oidcToken: string;
};

export type TOauth2AuthenticateBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow */
  oauth2CredentialId: string;
  /** The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow */
  authCode: string;
  /** The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider */
  redirectUri: string;
  /** The code verifier used by OAuth 2.0 PKCE providers */
  codeVerifier: string;
  /** An optional nonce used by the client to prevent replay/substitution of an ID token */
  nonce?: string;
  /** An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token */
  bearerTokenTargetPublicKey?: string;
};

export type TOauth2AuthenticateInput = { body: TOauth2AuthenticateBody };

export type TOauthLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TOauthLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type TOauthLoginInput = { body: TOauthLoginBody };

export type TOtpAuthResponse = {
  activity: v1Activity;
  /** Unique identifier for the authenticating User. */
  userId: string;
  /** Unique identifier for the created API key. */
  apiKeyId?: string;
  /** HPKE encrypted credential bundle */
  credentialBundle?: string;
};

export type TOtpAuthBody = {
  timestampMs?: string;
  organizationId?: string;
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted. */
  targetPublicKey: string;
  /** Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp> */
  apiKeyName?: string;
  /** Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated OTP Auth API keys */
  invalidateExisting?: boolean;
};

export type TOtpAuthInput = { body: TOtpAuthBody };

export type TOtpLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TOtpLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Optional signature associated with the public key passed into the verification step. This must be a hex-encoded ECDSA signature over the verification token. Only required if a public key was provided during the verification step. */
  clientSignature?: string;
};

export type TOtpLoginInput = { body: TOtpLoginBody };

export type TRecoverUserResponse = {
  activity: v1Activity;
  /** ID of the authenticator created. */
  authenticatorId: string[];
};

export type TRecoverUserBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The new authenticator to register. */
  authenticator: v1AuthenticatorParamsV2;
  /** Unique identifier for the user performing recovery. */
  userId: string;
};

export type TRecoverUserInput = { body: TRecoverUserBody };

export type TRejectActivityResponse = {
  activity: v1Activity;
};

export type TRejectActivityBody = {
  timestampMs?: string;
  organizationId?: string;
  /** An artifact verifying a User's action. */
  fingerprint: string;
};

export type TRejectActivityInput = { body: TRejectActivityBody };

export type TRemoveOrganizationFeatureResponse = {
  activity: v1Activity;
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type TRemoveOrganizationFeatureBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name of the feature to remove */
  name: v1FeatureName;
};

export type TRemoveOrganizationFeatureInput = {
  body: TRemoveOrganizationFeatureBody;
};

export type TSetOrganizationFeatureResponse = {
  activity: v1Activity;
  /** Resulting list of organization features. */
  features: v1Feature[];
};

export type TSetOrganizationFeatureBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Name of the feature to set */
  name: v1FeatureName;
  /** Optional value for the feature. Will override existing values if feature is already set. */
  value: string;
};

export type TSetOrganizationFeatureInput = {
  body: TSetOrganizationFeatureBody;
};

export type TSignRawPayloadResponse = {
  activity: v1Activity;
  /** Component of an ECSDA signature. */
  r: string;
  /** Component of an ECSDA signature. */
  s: string;
  /** Component of an ECSDA signature. */
  v: string;
};

export type TSignRawPayloadBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned payload to be signed. */
  payload: string;
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type TSignRawPayloadInput = { body: TSignRawPayloadBody };

export type TSignRawPayloadsResponse = {
  activity: v1Activity;
  signatures?: v1SignRawPayloadResult[];
};

export type TSignRawPayloadsBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** An array of raw unsigned payloads to be signed. */
  payloads: string[];
  /** Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8). */
  encoding: v1PayloadEncoding;
  /** Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032. */
  hashFunction: v1HashFunction;
};

export type TSignRawPayloadsInput = { body: TSignRawPayloadsBody };

export type TSignTransactionResponse = {
  activity: v1Activity;
  signedTransaction: string;
};

export type TSignTransactionBody = {
  timestampMs?: string;
  organizationId?: string;
  /** A Wallet account address, Private Key address, or Private Key identifier. */
  signWith: string;
  /** Raw unsigned transaction to be signed */
  unsignedTransaction: string;
  type: v1TransactionType;
};

export type TSignTransactionInput = { body: TSignTransactionBody };

export type TStampLoginResponse = {
  activity: v1Activity;
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type TStampLoginBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request */
  publicKey: string;
  /** Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used. */
  expirationSeconds?: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
};

export type TStampLoginInput = { body: TStampLoginBody };

export type TUpdateOauth2CredentialResponse = {
  activity: v1Activity;
  /** Unique identifier of the OAuth 2.0 credential that was updated */
  oauth2CredentialId: string;
};

export type TUpdateOauth2CredentialBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The ID of the OAuth 2.0 credential to update */
  oauth2CredentialId: string;
  /** The OAuth 2.0 provider */
  provider: v1Oauth2Provider;
  /** The Client ID issued by the OAuth 2.0 provider */
  clientId: string;
  /** The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key */
  encryptedClientSecret: string;
};

export type TUpdateOauth2CredentialInput = {
  body: TUpdateOauth2CredentialBody;
};

export type TUpdatePolicyResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Policy. */
  policyId: string;
};

export type TUpdatePolicyBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Policy. */
  policyId: string;
  /** Human-readable name for a Policy. */
  policyName?: string;
  /** The instruction to DENY or ALLOW an activity (optional). */
  policyEffect?: v1Effect;
  /** The condition expression that triggers the Effect (optional). */
  policyCondition?: string;
  /** The consensus expression that triggers the Effect (optional). */
  policyConsensus?: string;
  /** Accompanying notes for a Policy (optional). */
  policyNotes?: string;
};

export type TUpdatePolicyInput = { body: TUpdatePolicyBody };

export type TUpdatePrivateKeyTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
};

export type TUpdatePrivateKeyTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Private Key Tag. */
  privateKeyTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newPrivateKeyTagName?: string;
  /** A list of Private Keys IDs to add this tag to. */
  addPrivateKeyIds: string[];
  /** A list of Private Key IDs to remove this tag from. */
  removePrivateKeyIds: string[];
};

export type TUpdatePrivateKeyTagInput = { body: TUpdatePrivateKeyTagBody };

export type TUpdateRootQuorumResponse = {
  activity: v1Activity;
};

export type TUpdateRootQuorumBody = {
  timestampMs?: string;
  organizationId?: string;
  /** The threshold of unique approvals to reach quorum. */
  threshold: number;
  /** The unique identifiers of users who comprise the quorum set. */
  userIds: string[];
};

export type TUpdateRootQuorumInput = { body: TUpdateRootQuorumBody };

export type TUpdateUserResponse = {
  activity: v1Activity;
  /** A User ID. */
  userId: string;
};

export type TUpdateUserBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName?: string;
  /** The user's email address. */
  userEmail?: string;
  /** An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body. */
  userTagIds?: string[];
  /** The user's phone number in E.164 format e.g. +13214567890 */
  userPhoneNumber?: string;
};

export type TUpdateUserInput = { body: TUpdateUserBody };

export type TUpdateUserEmailResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose email was updated. */
  userId: string;
};

export type TUpdateUserEmailBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's email address. Setting this to an empty string will remove the user's email. */
  userEmail: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TUpdateUserEmailInput = { body: TUpdateUserEmailBody };

export type TUpdateUserNameResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose name was updated. */
  userId: string;
};

export type TUpdateUserNameBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** Human-readable name for a User. */
  userName: string;
};

export type TUpdateUserNameInput = { body: TUpdateUserNameBody };

export type TUpdateUserPhoneNumberResponse = {
  activity: v1Activity;
  /** Unique identifier of the User whose phone number was updated. */
  userId: string;
};

export type TUpdateUserPhoneNumberBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User. */
  userId: string;
  /** The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number. */
  userPhoneNumber: string;
  /** Signed JWT containing a unique id, expiry, verification type, contact */
  verificationToken?: string;
};

export type TUpdateUserPhoneNumberInput = { body: TUpdateUserPhoneNumberBody };

export type TUpdateUserTagResponse = {
  activity: v1Activity;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
};

export type TUpdateUserTagBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given User Tag. */
  userTagId: string;
  /** The new, human-readable name for the tag with the given ID. */
  newUserTagName?: string;
  /** A list of User IDs to add this tag to. */
  addUserIds: string[];
  /** A list of User IDs to remove this tag from. */
  removeUserIds: string[];
};

export type TUpdateUserTagInput = { body: TUpdateUserTagBody };

export type TUpdateWalletResponse = {
  activity: v1Activity;
  /** A Wallet ID. */
  walletId: string;
};

export type TUpdateWalletBody = {
  timestampMs?: string;
  organizationId?: string;
  /** Unique identifier for a given Wallet. */
  walletId: string;
  /** Human-readable name for a Wallet. */
  walletName?: string;
};

export type TUpdateWalletInput = { body: TUpdateWalletBody };

export type TVerifyOtpResponse = {
  activity: v1Activity;
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type TVerifyOtpBody = {
  timestampMs?: string;
  organizationId?: string;
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours) */
  expirationSeconds?: string;
  /** Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature */
  publicKey?: string;
};

export type TVerifyOtpInput = { body: TVerifyOtpBody };

export type TNOOPCodegenAnchorResponse = {
  activity: v1Activity;
};

export type TTestRateLimitsResponse = {};

export type TTestRateLimitsBody = {
  organizationId?: string;
  /** Whether or not to set a limit on this request. */
  isSetLimit: boolean;
  /** Rate limit to set for org, if is_set_limit is set to true. */
  limit: number;
};

export type TTestRateLimitsInput = { body: TTestRateLimitsBody };

export type ProxyTGetAccountResponse = {
  organizationId: string;
};

export type ProxyTGetAccountBody = {
  /** Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY' */
  filterType: string;
  /** The value of the filter to apply for the specified type. For example, a specific email or name string. */
  filterValue: string;
};

export type ProxyTGetAccountInput = { body: ProxyTGetAccountBody };

export type ProxyTOAuth2AuthenticateResponse = {
  /** A Turnkey issued OIDC token to be used with the LoginWithOAuth activity */
  oidcToken: string;
};

export type ProxyTOAuth2AuthenticateBody = {
  /** The OAuth 2.0 provider to authenticate with */
  provider: v1Oauth2Provider;
  /** The auth_code provided by the OAuth 2.0 to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow */
  authCode: string;
  /** The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider */
  redirectUri: string;
  /** The code verifier used by OAuth 2.0 PKCE providers */
  codeVerifier: string;
  /** An optional nonce used by the client to prevent replay/substitution of an ID token */
  nonce?: string;
  /** The client ID registered with the OAuth 2.0 provider */
  clientId: string;
};

export type ProxyTOAuth2AuthenticateInput = {
  body: ProxyTOAuth2AuthenticateBody;
};

export type ProxyTOAuthLoginResponse = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type ProxyTOAuthLoginBody = {
  /** Base64 encoded OIDC token */
  oidcToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request */
  publicKey: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the OIDC token to look up the associated organization id. */
  organizationId?: string;
};

export type ProxyTOAuthLoginInput = { body: ProxyTOAuthLoginBody };

export type ProxyTInitOtpResponse = {
  /** Unique identifier for an OTP authentication */
  otpId: string;
};

export type ProxyTInitOtpBody = {
  /** Enum to specifiy whether to send OTP via SMS or email */
  otpType: string;
  /** Email or phone number to send the OTP code to */
  contact: string;
};

export type ProxyTInitOtpInput = { body: ProxyTInitOtpBody };

export type ProxyTOtpLoginResponse = {
  /** Signed JWT containing an expiry, public key, session type, user id, and organization id */
  session: string;
};

export type ProxyTOtpLoginBody = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
  /** Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token */
  publicKey: string;
  /** Invalidate all other previously generated Login API keys */
  invalidateExisting?: boolean;
  /** Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the verification token to look up the verified sub-organization based on the contact and verification type. */
  organizationId?: string;
  /** Optional signature associated with the public key passed into the verification step. This must be a hex-encoded ECDSA signature over the verification token. Only required if a public key was provided during the verification step. */
  clientSignature?: string;
};

export type ProxyTOtpLoginInput = { body: ProxyTOtpLoginBody };

export type ProxyTVerifyOtpResponse = {
  /** Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests) */
  verificationToken: string;
};

export type ProxyTVerifyOtpBody = {
  /** ID representing the result of an init OTP activity. */
  otpId: string;
  /** OTP sent out to a user's contact (email or SMS) */
  otpCode: string;
  /** Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature */
  publicKey?: string;
};

export type ProxyTVerifyOtpInput = { body: ProxyTVerifyOtpBody };

export type ProxyTSignupResponse = {
  organizationId: string;
  /** Wallet created for the sub-organization, if provided in the request */
  wallet?: v1WalletResult;
  /** Root user ID created for this sub-organization */
  userId: string;
};

export type ProxyTSignupBody = {
  userEmail?: string;
  userPhoneNumber?: string;
  userTag?: string;
  userName?: string;
  organizationName?: string;
  verificationToken?: string;
  /** A list of API Key parameters. This field, if not needed, should be an empty array in your request body. */
  apiKeys: v1ApiKeyParamsV2[];
  /** A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body. */
  authenticators: v1AuthenticatorParamsV2[];
  /** A list of Oauth providers. This field, if not needed, should be an empty array in your request body. */
  oauthProviders: v1OauthProviderParams[];
  /** The wallet to create for the sub-organization */
  wallet?: v1WalletParams;
};

export type ProxyTSignupInput = { body: ProxyTSignupBody };

export type ProxyTGetWalletKitConfigResponse = {
  /** List of enabled authentication providers (e.g., 'facebook', 'google', 'apple', 'email', 'sms', 'passkey', 'wallet') */
  enabledProviders: string[];
  /** Session expiration duration in seconds */
  sessionExpirationSeconds: string;
  /** The organization ID this configuration applies to */
  organizationId: string;
  /** Mapping of social login providers to their OAuth client IDs. */
  oauthClientIds?: Record<string, any>;
  /** OAuth redirect URL to be used for social login flows. */
  oauthRedirectUrl?: string;
  otpAlphanumeric?: boolean;
  otpLength?: string;
};

export type ProxyTGetWalletKitConfigBody = {};

export type ProxyTGetWalletKitConfigInput = {
  body: ProxyTGetWalletKitConfigBody;
};
