const fs = require("fs");
const path = require("path");

// Paths
const swaggerPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.swagger.json",
);
const typesPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.types.ts",
);
const authProxySwaggerPath = path.resolve(
  __dirname,
  "../src/__inputs__/auth_proxy.swagger.json",
);
const outputPath = path.resolve(__dirname, "../src/__generated__/types.ts");

const COMMENT_HEADER = "/* @generated by codegen. DO NOT EDIT BY HAND */";

const VERSIONED_ACTIVITY_TYPES = {
  ACTIVITY_TYPE_CREATE_AUTHENTICATORS: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
  ACTIVITY_TYPE_CREATE_API_KEYS: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
  ACTIVITY_TYPE_CREATE_POLICY: "ACTIVITY_TYPE_CREATE_POLICY_V3",
  ACTIVITY_TYPE_CREATE_PRIVATE_KEYS: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
  ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION:
    "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
  ACTIVITY_TYPE_CREATE_USERS: "ACTIVITY_TYPE_CREATE_USERS_V3",
  ACTIVITY_TYPE_SIGN_RAW_PAYLOAD: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
  ACTIVITY_TYPE_SIGN_TRANSACTION: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
  ACTIVITY_TYPE_EMAIL_AUTH: "ACTIVITY_TYPE_EMAIL_AUTH_V2",
  ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION:
    "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
  ACTIVITY_TYPE_UPDATE_POLICY: "ACTIVITY_TYPE_UPDATE_POLICY_V2",
  ACTIVITY_TYPE_INIT_OTP_AUTH: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
};

const METHODS_WITH_ONLY_OPTIONAL_PARAMETERS = [
  "getActivities",
  "getApiKeys",
  "getOrganization",
  "getPolicies",
  "getPrivateKeys",
  "getSubOrgIds",
  "getUsers",
  "getWallets",
  "getWhoami",
  "listPrivateKeys",
  "listUserTags",
];

// Helper: Convert Swagger type to TS type
/**
 * @param {string} type
 * @param {object} schema
 * @returns {string}
 */
function swaggerTypeToTs(type, schema) {
  if (type === "integer" || type === "number") return "number";
  if (type === "boolean") return "boolean";
  if (type === "string") return "string";
  if (type === "array") {
    if (schema.items) {
      if (schema.items.$ref) {
        return refToTs(schema.items.$ref) + "[]";
      } else if (schema.items.type) {
        return swaggerTypeToTs(schema.items.type, schema.items) + "[]";
      }
    }
    return "any[]";
  }
  if (type === "object") {
    if (schema?.properties) return "{ [key: string]: any }";
    return "Record<string, any>";
  }
  return "any";
}

/**
 * @param {string} name
 * @returns {string}
 */
function stripVersionPrefix(name) {
  return name.replace(/^v\d+/, "");
}

/**
 * @param {string} ref
 * @returns {string}
 */
function refToTs(ref) {
  return ref.replace(/^#\/definitions\//, "");
}

// Helper that takes in swagger definitions and returns a map containing the latest version of a field.
// The intent is to consolidate a field with multiple versions (e.g. v1CreateSubOrganizationResult, v1CreateSubOrganizationResultV2...)
// in order to get just the latest (v1CreateSubOrganizationResultV4).
function extractLatestVersions(definitions) {
  const latestVersions = {};

  // Regex to separate the version prefix, base activity details, and (optional) activity version
  const keyVersionRegex = /^(v\d+)([A-Z][A-Za-z0-9]*?)(V\d+)?$/;

  Object.keys(definitions).forEach((key) => {
    const match = key.match(keyVersionRegex);

    if (match) {
      const fullName = match[0];
      const baseName = match[2]; // Field without any version-related prefixes or suffixes
      const versionSuffix = match[3]; // Version (optional)
      const formattedKeyName =
        baseName.charAt(0).toLowerCase() +
        baseName.slice(1) +
        (versionSuffix || ""); // Reconstruct the original key with version

      // Determine if this version is newer or if no version was previously stored
      if (
        !latestVersions[baseName] ||
        versionSuffix > (latestVersions[baseName].versionSuffix || "")
      ) {
        latestVersions[baseName] = {
          fullName,
          formattedKeyName,
          versionSuffix,
        };
      }
    }
  });

  return latestVersions;
}

/**
 * @param {string} name
 * @returns {boolean}
 */
function isValidIdentifier(name) {
  return /^[$A-Z_][0-9A-Z_$]*$/i.test(name);
}

/**
 * @param {string} methodName
 * @returns {string}
 */
function methodTypeFromMethodName(methodName) {
  methodName = methodName.toLowerCase();
  if (["approveActivity", "rejectActivity"].includes(methodName)) {
    return "activityDecision";
  }
  if (methodName.startsWith("nOOP")) {
    return "noop";
  }
  if (methodName.startsWith("proxy")) {
    return "proxy";
  }
  // TODO: filter out unnecessary client methods, whether here or from the source
  if (
    methodName.startsWith("tget") ||
    methodName.startsWith("tlist") ||
    methodName.startsWith("ttest")
  ) {
    return "query";
  }
  // Rename to submit?
  return "command";
}

/**
 * @param {string} name
 * @param {object} def
 * @returns {string}
 */
function generateTsType(name, def) {
  if (
    def.type === "object" &&
    (def.properties || def.additionalProperties !== undefined)
  ) {
    let out = `export type ${name} = {\n`;
    if (def.properties) {
      for (const [prop, schema] of Object.entries(def.properties)) {
        const required = def.required && def.required.includes(prop) ? "" : "?";
        let type = "any";
        if (schema.$ref) {
          type = refToTs(schema.$ref);
        } else if (schema.type) {
          type = swaggerTypeToTs(schema.type, schema);
        }
        const desc = schema.description
          ? `  /** ${schema.description} */\n`
          : "";
        // Quote property if not a valid identifier
        const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
        out += `${desc}  ${propName}${required}: ${type};\n`;
      }
    }
    // If additionalProperties is present, allow arbitrary keys
    if (def.additionalProperties !== undefined) {
      out += `  [key: string]: any;\n`;
    }
    out += "};\n";
    return out;
  }
  if (def.type === "string" && def.enum) {
    return `export type ${name} =\n  ${def.enum.map((e) => `"${e}"`).join(" |\n  ")};\n`;
  }
  return `export type ${name} = {};\n`;
}

function generateInlineProperties(def, isAllOptional = false) {
  let out = "";
  if (def && def.properties) {
    const requiredProps = Array.isArray(def.required) ? def.required : [];
    for (const [prop, schema] of Object.entries(def.properties)) {
      let type = "any";
      if (schema.$ref) {
        type = refToTs(schema.$ref);
      } else if (schema.type) {
        type = swaggerTypeToTs(schema.type, schema);
      }
      const desc = schema.description ? `  /** ${schema.description} */\n` : "";
      const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
      const required = isAllOptional
        ? "?"
        : requiredProps.includes(prop)
          ? ""
          : "?";
      out += `${desc}  ${propName}${required}: ${type};\n`;
    }
  }
  return out;
}

function generateApiTypes(swagger, prefix = "") {
  const namespace = swagger.tags?.find((item) => item.name != null)?.name;
  let output = "";
  const latestVersions = extractLatestVersions(swagger.definitions);
  const definitions = swagger.definitions;

  for (const [path, methods] of Object.entries(swagger.paths)) {
    const methodMap = swagger.paths[path];
    const operation = methodMap.post;
    const operationId = operation && operation.operationId;

    const operationNameWithoutNamespace = operationId.replace(
      new RegExp(`${namespace}_`),
      `${prefix}T`,
    );
    const methodName =
      operationNameWithoutNamespace.charAt(0).toLowerCase() +
      operationNameWithoutNamespace.slice(1);
    const methodType = methodTypeFromMethodName(methodName);

    // Get response schema $ref
    const responseSchema =
      operation.responses &&
      operation.responses["200"] &&
      operation.responses["200"].schema &&
      operation.responses["200"].schema.$ref;
    const responseTypeName = responseSchema ? refToTs(responseSchema) : null;

    // Compose API Response type name
    const apiTypeName =
      operationNameWithoutNamespace.replace(/^./, (c) => c.toUpperCase()) +
      "Response";
    const apiBodyTypeName =
      operationNameWithoutNamespace.replace(/^./, (c) => c.toUpperCase()) +
      "Body";

    const apiInputTypeName =
      operationNameWithoutNamespace.replace(/^./, (c) => c.toUpperCase()) +
      "Input";

    // --- RESPONSE TYPE GENERATION ---
    if (methodType === "command") {
      // Try to find the corresponding Result type from the response schema or activity type
      let resultTypeName = null;
      let activityTypeKey = null;
      let versionSuffix = null;

      const parameters = operation.parameters || [];
      for (const param of parameters) {
        if (
          param.in === "body" &&
          param.schema &&
          param.schema.$ref &&
          definitions[refToTs(param.schema.$ref)]
        ) {
          const reqDef = definitions[refToTs(param.schema.$ref)];
          if (
            reqDef.properties &&
            reqDef.properties.type &&
            reqDef.properties.type.enum &&
            reqDef.properties.type.enum.length > 0
          ) {
            // Compose the activity type key from the request type
            // Example: v1CreatePoliciesRequest -> ACTIVITY_TYPE_CREATE_POLICIES
            const reqTypeName = refToTs(param.schema.$ref);
            const baseActivity = reqTypeName
              .replace(/^v\d+/, "")
              .replace(/Request(V\d+)?$/, "");
            activityTypeKey = reqDef.properties.type.enum[0];
            const mapped = VERSIONED_ACTIVITY_TYPES[activityTypeKey];
            if (mapped) {
              // Extract version suffix from mapped value
              const mappedVersionSuffixMatch = mapped.match(/(V\d+)$/);
              versionSuffix = mappedVersionSuffixMatch
                ? mappedVersionSuffixMatch[1]
                : "";
            }
            // Now, find the latest version of the Result type using latestVersions
            const resultBase = baseActivity + "Result";
            let resultKey = null;
            if (latestVersions[resultBase]) {
              // If versionSuffix is present, use it to pick the correct version
              if (versionSuffix) {
                const candidate = Object.keys(definitions).find(
                  (k) =>
                    k.startsWith("v1" + baseActivity + "Result") &&
                    k.endsWith(versionSuffix),
                );
                if (candidate) {
                  resultKey = candidate;
                }
              }
              // Fallback to latest version if not found
              if (!resultKey) {
                resultKey = latestVersions[resultBase].fullName;
              }
            }
            if (resultKey) {
              resultTypeName = resultKey;
            }
          }
        }
      }

      // Compose the type
      output += `export type ${apiTypeName} = {\n  activity: v1Activity;\n`;
      if (resultTypeName && definitions[resultTypeName]) {
        output += generateInlineProperties(definitions[resultTypeName]);
      }
      output += "}\n\n";
    } else if (
      methodType === "query" ||
      methodType === "noop" ||
      methodType === "proxy"
    ) {
      const respDef = definitions[responseTypeName];
      if (respDef) {
        if (respDef.properties) {
          output += `export type ${apiTypeName} = {\n`;
          output += generateInlineProperties(respDef);
          output += "}\n\n";
        } else {
          output += `export type ${apiTypeName} = {};\n\n`;
        }
      }
    } else if (methodType === "activityDecision") {
      const activityType = definitions[responseTypeName];
      if (activityType && activityType.properties) {
        output += `export type ${apiTypeName} = {\n`;
        output += generateInlineProperties(activityType);
        output += "}\n\n";
      }
    }

    // --- REQUEST TYPE GENERATION ---
    // Find the request type definition
    let requestTypeDef = null;
    let requestTypeName = null;
    const parameters = operation.parameters || [];
    for (const param of parameters) {
      if (
        param.in === "body" &&
        param.schema &&
        param.schema.$ref &&
        definitions[refToTs(param.schema.$ref)]
      ) {
        requestTypeName = refToTs(param.schema.$ref);
        requestTypeDef = definitions[requestTypeName];
      }
    }

    if (!requestTypeDef) continue;

    output += `export type ${apiBodyTypeName} = {\n`;

    if (methodType === "command" || methodType === "activityDecision") {
      output += `  timestampMs?: string;\n  organizationId?: string;\n`;
      if (
        requestTypeDef.properties &&
        requestTypeDef.properties.parameters &&
        requestTypeDef.properties.parameters.$ref
      ) {
        const isAllOptional =
          METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.includes(methodName);
        const intentTypeName = refToTs(
          requestTypeDef.properties.parameters.$ref,
        );
        const intentDef = definitions[intentTypeName];
        output += generateInlineProperties(intentDef, isAllOptional);
      }
    } else if (methodType === "query" || methodType === "noop") {
      output += `  organizationId?: string;\n`;
      if (requestTypeDef.properties) {
        const isAllOptional =
          METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.includes(methodName);
        const requiredProps = Array.isArray(requestTypeDef.required)
          ? requestTypeDef.required
          : [];
        for (const [prop, schema] of Object.entries(
          requestTypeDef.properties,
        )) {
          if (prop === "organizationId") continue;
          let type = "any";
          if (schema.$ref) {
            type = refToTs(schema.$ref);
          } else if (schema.type) {
            type = swaggerTypeToTs(schema.type, schema);
          }
          const desc = schema.description
            ? `  /** ${schema.description} */\n`
            : "";
          const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
          const required = isAllOptional
            ? "?"
            : requiredProps.includes(prop)
              ? ""
              : "?";
          output += `${desc}  ${propName}${required}: ${type};\n`;
        }
      }
    } else if (methodType === "proxy") {
      if (requestTypeDef.properties) {
        const isAllOptional =
          METHODS_WITH_ONLY_OPTIONAL_PARAMETERS.includes(methodName);
        const requiredProps = Array.isArray(requestTypeDef.required)
          ? requestTypeDef.required
          : [];
        for (const [prop, schema] of Object.entries(
          requestTypeDef.properties,
        )) {
          if (prop === "organizationId") continue;
          let type = "any";
          if (schema.$ref) {
            type = refToTs(schema.$ref);
          } else if (schema.type) {
            type = swaggerTypeToTs(schema.type, schema);
          }
          const desc = schema.description
            ? `  /** ${schema.description} */\n`
            : "";
          const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
          const required = isAllOptional
            ? "?"
            : requiredProps.includes(prop)
              ? ""
              : "?";
          output += `${desc}  ${propName}${required}: ${type};\n`;
        }
      }
    }
    output += "}\n\n";

    output += `export type ${apiInputTypeName} = { body: ${apiBodyTypeName} };\n\n`;
  }
  return output;
}

function main() {
  const swaggerMain = JSON.parse(fs.readFileSync(swaggerPath, "utf8"));
  const swaggerAuthProxy = JSON.parse(
    fs.readFileSync(authProxySwaggerPath, "utf8"),
  );

  const typesSrc = fs.readFileSync(typesPath, "utf8");

  const typeDefRegex = /export type (\w+) = ([^;]+);/g;
  const interfaceDefRegex = /export type (\w+) = {([^}]+)}/g;

  let match;
  const typeDefs = {};
  while ((match = typeDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = match[2].trim();
  }
  while ((match = interfaceDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = `{${match[2]}}`;
  }

  let output = COMMENT_HEADER + "\n\n";

  // --- Base Types ---
  output += `// --- Base Types from Swagger Definitions ---\n`;

  for (const [defName, def] of Object.entries(swaggerMain.definitions)) {
    if (
      (def.type === "object" && def.properties) ||
      (def.type === "string" && def.enum)
    ) {
      output += generateTsType(defName, def) + "\n";
    } else {
      output += `export type ${defName} = {};\n`;
    }
  }

  // -- Api Types --
  output += "\n// --- API Types from Swagger Paths ---\n";

  output += generateApiTypes(swaggerMain);
  output += generateApiTypes(swaggerAuthProxy, "Proxy");

  fs.writeFileSync(outputPath, output);
}

main();
