const fs = require("fs");
const path = require("path");

// Paths
const swaggerPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.swagger.json",
);
const typesPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.types.ts",
);
const outputPath = path.resolve(__dirname, "../src/__generated__/types.ts");

const COMMENT_HEADER = "/* @generated by codegen. DO NOT EDIT BY HAND */";

const VERSIONED_ACTIVITY_TYPES = {
  ACTIVITY_TYPE_CREATE_AUTHENTICATORS: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
  ACTIVITY_TYPE_CREATE_API_KEYS: "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
  ACTIVITY_TYPE_CREATE_POLICY: "ACTIVITY_TYPE_CREATE_POLICY_V3",
  ACTIVITY_TYPE_CREATE_PRIVATE_KEYS: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
  ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION:
    "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
  ACTIVITY_TYPE_CREATE_USERS: "ACTIVITY_TYPE_CREATE_USERS_V3",
  ACTIVITY_TYPE_SIGN_RAW_PAYLOAD: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
  ACTIVITY_TYPE_SIGN_TRANSACTION: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
  ACTIVITY_TYPE_EMAIL_AUTH: "ACTIVITY_TYPE_EMAIL_AUTH_V2",
  ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION:
    "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
  ACTIVITY_TYPE_UPDATE_POLICY: "ACTIVITY_TYPE_UPDATE_POLICY_V2",
  ACTIVITY_TYPE_INIT_OTP_AUTH: "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
};

// Helper: Convert Swagger type to TS type
/**
 * @param {string} type
 * @param {object} schema
 * @returns {string}
 */
function swaggerTypeToTs(type, schema) {
  if (type === "integer" || type === "number") return "number";
  if (type === "boolean") return "boolean";
  if (type === "string") return "string";
  if (type === "array") {
    if (schema.items) {
      if (schema.items.$ref) {
        return refToTs(schema.items.$ref) + "[]";
      } else if (schema.items.type) {
        return swaggerTypeToTs(schema.items.type, schema.items) + "[]";
      }
    }
    return "any[]";
  }
  if (type === "object") {
    if (schema?.properties) return "{ [key: string]: any }";
    return "Record<string, any>";
  }
  return "any";
}

/**
 * @param {string} name
 * @returns {string}
 */
function stripVersionPrefix(name) {
  return name.replace(/^v\d+/, "");
}

/**
 * @param {string} ref
 * @returns {string}
 */
function refToTs(ref) {
  return ref.replace(/^#\/definitions\//, "");
}

// /**
//  * @param {string} ref
//  * @returns {string}
//  */
// function refToTsWithVersionPrefixAndSuffixStrip(ref) {
//   return stripVersionPrefixAndSuffix(ref.replace(/^#\/definitions\//, ""));
// }

/**
 * @param {string} methodName
 * @returns {string}
 */
function methodTypeFromMethodName(methodName) {
  if (["approveActivity", "rejectActivity"].includes(methodName)) {
    return "activityDecision";
  }
  if (methodName.startsWith("nOOP")) {
    return "noop";
  }
  // TODO: filter out unnecessary client methods, whether here or from the source
  if (
    methodName.startsWith("get") ||
    methodName.startsWith("list") ||
    methodName.startsWith("test")
  ) {
    return "query";
  }
  // Rename to submit?
  return "command";
}

/**
 * Maps activity types to their most recent versions in VERSIONED_ACTIVITY_TYPES.
 * If a type has multiple versions, it will return the latest one based on the versioning scheme.
 * @param {object} definitions - Swagger definitions object
 * @returns {object} - Map of base type to most recent versioned type
 */
function buildLatestVersionMap(definitions) {
  const versionMap = {};

  // Group definitions by their base name (without version)
  const groupedDefs = {};
  for (const defName of Object.keys(definitions)) {
    if (!defName.match(/^v\d+/)) {
      continue;
    }

    const baseName = stripVersionPrefixAndSuffix(defName);

    if (!groupedDefs[baseName]) {
      groupedDefs[baseName] = [];
    }
    groupedDefs[baseName].push(defName);
  }

  // For each group, find the latest versioned type
  for (const [baseName, defNames] of Object.entries(groupedDefs)) {
    // Remove REQUEST/RESPONSE/RESULT/INTENT suffix for activityTypeKey
    const activityBase = baseName.replace(
      /(Request|Response|Result|Intent)$/,
      "",
    );
    const activityTypeKey = `ACTIVITY_TYPE_${activityBase.replace(/([a-z])([A-Z])/g, "$1_$2").toUpperCase()}`;
    const mappedVersion = VERSIONED_ACTIVITY_TYPES[activityTypeKey];
    if (mappedVersion) {
      const versionSuffixMatch = mappedVersion.match(/(V\d+)$/);
      const versionSuffix = versionSuffixMatch ? versionSuffixMatch[1] : "";
      // Try to find a defName that ends with the version suffix (e.g., V2)
      const matchedDef = defNames.find((name) => name.endsWith(versionSuffix));
      if (matchedDef) {
        versionMap[baseName] = matchedDef;
        continue;
      }
    }
    let latest = defNames[0];
    let latestVersion = 1;
    for (const name of defNames) {
      const match = name.match(/V(\d+)$/);
      const version = match ? parseInt(match[1], 10) : 1;
      if (version > latestVersion) {
        latest = name;
        latestVersion = version;
      }
    }
    versionMap[baseName] = latest;
  }

  return versionMap;
}

/**
 * Strip both prefix and suffix version numbers
 * @param {string} name - Type name with version info
 * @returns {string} - Clean base name
 */
function stripVersionPrefixAndSuffix(name) {
  let baseName = stripVersionPrefix(name);
  baseName = baseName.replace(/V\d+$/, "");

  return baseName;
}

/**
 * @param {string} name
 * @returns {boolean}
 */
function isValidIdentifier(name) {
  return /^[$A-Z_][0-9A-Z_$]*$/i.test(name);
}

/**
 * @param {string} name
 * @param {object} def
 * @returns {string}
 */
function generateTsType(name, def) {
  if (
    def.type === "object" &&
    (def.properties || def.additionalProperties !== undefined)
  ) {
    let out = `export type ${name} = {\n`;
    if (def.properties) {
      for (const [prop, schema] of Object.entries(def.properties)) {
        const required = def.required && def.required.includes(prop) ? "" : "?";
        let type = "any";
        if (schema.$ref) {
          type = refToTs(schema.$ref);
        } else if (schema.type) {
          type = swaggerTypeToTs(schema.type, schema);
        }
        const desc = schema.description
          ? `  /** ${schema.description} */\n`
          : "";
        // Quote property if not a valid identifier
        const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
        out += `${desc}  ${propName}${required}: ${type};\n`;
      }
    }
    // If additionalProperties is present, allow arbitrary keys
    if (def.additionalProperties !== undefined) {
      out += `  [key: string]: any;\n`;
    }
    out += "};\n";
    return out;
  }
  if (def.type === "string" && def.enum) {
    return `export type ${name} =\n  ${def.enum.map((e) => `"${e}"`).join(" |\n  ")};\n`;
  }
  return `export type ${name} = any;\n`;
}

function main() {
  const swagger = JSON.parse(fs.readFileSync(swaggerPath, "utf8"));
  const typesSrc = fs.readFileSync(typesPath, "utf8");

  const typeDefRegex = /export type (\w+) = ([^;]+);/g;
  const interfaceDefRegex = /export type (\w+) = {([^}]+)}/g;

  let match;
  const typeDefs = {};
  while ((match = typeDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = match[2].trim();
  }
  while ((match = interfaceDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = `{${match[2]}}`;
  }

  let output = COMMENT_HEADER + "\n\n";

  // --- Base Types ---
  output += `// --- Base Types from Swagger Definitions ---\n`;

  // First generate all versioned types
  for (const [defName, def] of Object.entries(swagger.definitions)) {
    // Only parse object and enum types
    if (
      (def.type === "object" && def.properties) ||
      (def.type === "string" && def.enum)
    ) {
      output += generateTsType(defName, def) + "\n";
    } else {
      output += `export type ${defName} = any;\n`;
    }
  }

  // Build a map of base types to their latest versioned counterparts
  const latestVersionMap = buildLatestVersionMap(swagger.definitions);

  // Check all Request types for organizationId, if present modify their respective Intent types and add optional organizationId
  //    Also check Result types and add Response type for them
  for (const [baseName, latestVersionName] of Object.entries(
    latestVersionMap,
  )) {
    const def = swagger.definitions[latestVersionName];
    if (def && def.type === "object" && def.properties) {
      // If the baseName ends with "Request", check for organizationId

      if (baseName.endsWith("Request") && def.properties.organizationId) {
        // Modify the corresponding Intent type to make organizationId optional
        const intentTypeName = latestVersionName.replace(/Request$/, "Intent");
        if (
          swagger.definitions[intentTypeName] &&
          swagger.definitions[intentTypeName].properties
        ) {
          if (swagger.definitions[intentTypeName]?.organizationId) {
            swagger.definitions[intentTypeName].organizationId = {
              ...swagger.definitions[intentTypeName]?.properties.organizationId,
              required: false,
            };
          }
          // Add organizationId if it doesn't exist
          if (!swagger.definitions[intentTypeName]?.organizationId) {
            swagger.definitions[intentTypeName].properties.organizationId = {
              type: "string",
              description: "Unique identifier for a given Organization.",
            };
          }
          // Always make it optional
          swagger.definitions[intentTypeName].required = (
            swagger.definitions[intentTypeName].required || []
          ).filter((r) => r !== "organizationId");
        }
      } else if (
        baseName.endsWith("Result") &&
        !/^v\d+Result$/.test(latestVersionName)
      ) {
        // If baseName ends with "Result" and not just vXResult, create a corresponding Response type
        if (swagger.definitions[latestVersionName]) {
          const responseTypeName = stripVersionPrefixAndSuffix(
            latestVersionName.replace(/(.+)Result$/, (m, p1) => `${p1}Response`)
          );
          
          swagger.definitions[responseTypeName] = {
            type: "object",
            properties: {
                activity: {
                    $ref: `#/definitions/v1Activity`,
                    description: "The activity that was processed.",
                },
                ...swagger.definitions[latestVersionName].properties,
            },
            required: [
              "activity",
              ...(Array.isArray(swagger.definitions[latestVersionName].required)
                ? swagger.definitions[latestVersionName].required
                : [])
            ],
          };

          console.log(swagger.definitions[responseTypeName]);

        //   Add the new Response type to latestVersionMap
          latestVersionMap[responseTypeName] = responseTypeName;
        }
      }
    }
  }

  // Then generate the abstracted types that reference the correct versioned types
  output += "\n// --- Latest Version Type Aliases ---\n";
  for (const [baseName, latestVersionName] of Object.entries(
    latestVersionMap,
  )) {
    const def = swagger.definitions[latestVersionName];

    // If baseName ends with "Intent" and has characters before "Intent", also emit a corresponding Request type
    if (
      /(.+)Intent$/.test(baseName) &&
      def &&
      def.type === "object" &&
      def.properties
    ) {
      const requestTypeName = baseName.replace(/Intent$/, "Request");
      output += generateTsType(requestTypeName, def) + "\n";
    }

    if (/(.+)Intent$/.test(baseName) || /(.+)Request$/.test(baseName)) {
      continue;
    }

    if (def && def.type === "object" && def.properties) {
      // Redefine the type with all properties, making organizationId optional if present
      output += generateTsType(baseName, def) + "\n";
    } else {
      output += `export type ${baseName} = ${latestVersionName};\n`;
    }
  }

  // 5. Write output
  fs.writeFileSync(outputPath, output);

  console.log(`Nice types generated at ${outputPath}`);
}

main();
