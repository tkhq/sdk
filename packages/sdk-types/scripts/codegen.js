const fs = require("fs");
const path = require("path");

// Paths
const swaggerPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.swagger.json",
);
const typesPath = path.resolve(
  __dirname,
  "../src/__inputs__/public_api.types.ts",
);
const outputPath = path.resolve(__dirname, "../src/__generated__/types.ts");

// Helper: Convert Swagger type to TS type
/**
 * @param {string} type
 * @param {object} schema
 * @returns {string}
 */
function swaggerTypeToTs(type, schema) {
  if (type === "integer" || type === "number") return "number";
  if (type === "boolean") return "boolean";
  if (type === "string") return "string";
  if (type === "array") {
    if (schema.items) {
      if (schema.items.$ref) {
        return refToTs(schema.items.$ref) + "[]";
      } else if (schema.items.type) {
        return swaggerTypeToTs(schema.items.type, schema.items) + "[]";
      }
    }
    return "any[]";
  }
  if (type === "object") {
    if (schema?.properties) return "{ [key: string]: any }";
    return "Record<string, any>";
  }
  return "any";
}

/**
 * @param {string} name
 * @returns {string}
 */
function stripVersionPrefix(name) {
  return name.replace(/^v\d+/, "");
}

/**
 * @param {string} ref
 * @returns {string}
 */
function refToTs(ref) {
  // "#/definitions/v1GetAuthenticatorRequest" -> "GetAuthenticatorRequest"
  return stripVersionPrefix(ref.replace(/^#\/definitions\//, ""));
}

/**
 * @param {string} name
 * @returns {boolean}
 */
function isValidIdentifier(name) {
  return /^[$A-Z_][0-9A-Z_$]*$/i.test(name);
}

/**
 * @param {string} name
 * @param {object} def
 * @returns {string}
 */
function generateTsType(name, def) {
  const cleanName = stripVersionPrefix(name);
  if (
    def.type === "object" &&
    (def.properties || def.additionalProperties !== undefined)
  ) {
    let out = `export type ${cleanName} = {\n`;
    if (def.properties) {
      for (const [prop, schema] of Object.entries(def.properties)) {
        const required = def.required && def.required.includes(prop) ? "" : "?";
        let type = "any";
        if (schema.$ref) {
          type = refToTs(schema.$ref);
        } else if (schema.type) {
          type = swaggerTypeToTs(schema.type, schema);
        }
        const desc = schema.description
          ? `  /** ${schema.description} */\n`
          : "";
        // Quote property if not a valid identifier
        const propName = isValidIdentifier(prop) ? prop : `"${prop}"`;
        out += `${desc}  ${propName}${required}: ${type};\n`;
      }
    }
    // If additionalProperties is present, allow arbitrary keys
    if (def.additionalProperties !== undefined) {
      out += `  [key: string]: any;\n`;
    }
    out += "};\n";
    return out;
  }
  // enums
  if (def.type === "string" && def.enum) {
    return `export type ${cleanName} =\n  ${def.enum.map((e) => `"${e}"`).join(" |\n  ")};\n`;
  }
  // fallback
  return `export type ${cleanName} = any;\n`;
}

function main() {
  // 1. Load files
  const swagger = JSON.parse(fs.readFileSync(swaggerPath, "utf8"));
  const typesSrc = fs.readFileSync(typesPath, "utf8");

  // 2. Extract type definitions from types file (very basic, just for demo)
  const typeDefRegex = /export type (\w+) = ([^;]+);/g;
  const interfaceDefRegex = /export type (\w+) = {([^}]+)}/g;

  let match;
  const typeDefs = {};
  while ((match = typeDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = match[2].trim();
  }
  while ((match = interfaceDefRegex.exec(typesSrc))) {
    typeDefs[match[1]] = `{${match[2]}}`;
  }

  // 3. Generate base types from swagger definitions
  let output = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by codegen.js\n\n`;

  // --- Base Types ---
  output += `// --- Base Types from Swagger Definitions ---\n`;
  for (const [defName, def] of Object.entries(swagger.definitions)) {
    // Only parse object and enum types
    if (
      (def.type === "object" && def.properties) ||
      (def.type === "string" && def.enum)
    ) {
      output += generateTsType(defName, def) + "\n";
    } else {
      output += `export type ${stripVersionPrefix(defName)} = any;\n`;
    }
  }

  // 5. Write output
  fs.writeFileSync(outputPath, output);

  console.log(`Nice types generated at ${outputPath}`);
}

main();
